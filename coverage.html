
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>v1beta1: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/oracle/cluster-api-provider-oci/api/v1beta1/conversion.go (89.1%)</option>
				
				<option value="file1">github.com/oracle/cluster-api-provider-oci/api/v1beta1/ocicluster_conversion.go (81.4%)</option>
				
				<option value="file2">github.com/oracle/cluster-api-provider-oci/api/v1beta1/ocicluster_types.go (25.0%)</option>
				
				<option value="file3">github.com/oracle/cluster-api-provider-oci/api/v1beta1/ociclusteridentity_conversion.go (81.8%)</option>
				
				<option value="file4">github.com/oracle/cluster-api-provider-oci/api/v1beta1/ociclusteridentity_types.go (100.0%)</option>
				
				<option value="file5">github.com/oracle/cluster-api-provider-oci/api/v1beta1/ociclustertemplate_conversion.go (73.9%)</option>
				
				<option value="file6">github.com/oracle/cluster-api-provider-oci/api/v1beta1/ociclustertemplate_types.go (100.0%)</option>
				
				<option value="file7">github.com/oracle/cluster-api-provider-oci/api/v1beta1/ocimachine_conversion.go (59.4%)</option>
				
				<option value="file8">github.com/oracle/cluster-api-provider-oci/api/v1beta1/ocimachine_types.go (33.3%)</option>
				
				<option value="file9">github.com/oracle/cluster-api-provider-oci/api/v1beta1/ocimachinetemplate_types.go (100.0%)</option>
				
				<option value="file10">github.com/oracle/cluster-api-provider-oci/api/v1beta1/ocimanagedcluster_conversion.go (82.1%)</option>
				
				<option value="file11">github.com/oracle/cluster-api-provider-oci/api/v1beta1/ocimanagedcluster_types.go (33.3%)</option>
				
				<option value="file12">github.com/oracle/cluster-api-provider-oci/api/v1beta1/ocimanagedclustertemplate_types.go (100.0%)</option>
				
				<option value="file13">github.com/oracle/cluster-api-provider-oci/api/v1beta1/ocimanagedcontrolplane_conversion.go (87.5%)</option>
				
				<option value="file14">github.com/oracle/cluster-api-provider-oci/api/v1beta1/ocimanagedcontrolplane_types.go (33.3%)</option>
				
				<option value="file15">github.com/oracle/cluster-api-provider-oci/api/v1beta1/ocimanagedcontrolplanetemplate_types.go (100.0%)</option>
				
				<option value="file16">github.com/oracle/cluster-api-provider-oci/api/v1beta1/validator.go (0.0%)</option>
				
				<option value="file17">github.com/oracle/cluster-api-provider-oci/api/v1beta2/conversion.go (0.0%)</option>
				
				<option value="file18">github.com/oracle/cluster-api-provider-oci/api/v1beta2/ocicluster_types.go (100.0%)</option>
				
				<option value="file19">github.com/oracle/cluster-api-provider-oci/api/v1beta2/ocicluster_webhook.go (70.1%)</option>
				
				<option value="file20">github.com/oracle/cluster-api-provider-oci/api/v1beta2/ociclusteridentity_types.go (100.0%)</option>
				
				<option value="file21">github.com/oracle/cluster-api-provider-oci/api/v1beta2/ociclustertemplate_types.go (100.0%)</option>
				
				<option value="file22">github.com/oracle/cluster-api-provider-oci/api/v1beta2/ocimachine_types.go (100.0%)</option>
				
				<option value="file23">github.com/oracle/cluster-api-provider-oci/api/v1beta2/ocimachinetemplate_types.go (100.0%)</option>
				
				<option value="file24">github.com/oracle/cluster-api-provider-oci/api/v1beta2/ocimachinetemplate_webhook.go (88.6%)</option>
				
				<option value="file25">github.com/oracle/cluster-api-provider-oci/api/v1beta2/ocimanagedcluster_types.go (100.0%)</option>
				
				<option value="file26">github.com/oracle/cluster-api-provider-oci/api/v1beta2/ocimanagedcluster_webhook.go (92.9%)</option>
				
				<option value="file27">github.com/oracle/cluster-api-provider-oci/api/v1beta2/ocimanagedclustertemplate_types.go (100.0%)</option>
				
				<option value="file28">github.com/oracle/cluster-api-provider-oci/api/v1beta2/ocimanagedcontrolplane_types.go (66.7%)</option>
				
				<option value="file29">github.com/oracle/cluster-api-provider-oci/api/v1beta2/ocimanagedcontrolplane_webhook.go (80.8%)</option>
				
				<option value="file30">github.com/oracle/cluster-api-provider-oci/api/v1beta2/ocimanagedcontrolplanetemplate_types.go (100.0%)</option>
				
				<option value="file31">github.com/oracle/cluster-api-provider-oci/api/v1beta2/validator.go (97.9%)</option>
				
				<option value="file32">github.com/oracle/cluster-api-provider-oci/cloud/config/config.go (86.1%)</option>
				
				<option value="file33">github.com/oracle/cluster-api-provider-oci/cloud/metrics/http_request_dispatcher_wrapper.go (0.0%)</option>
				
				<option value="file34">github.com/oracle/cluster-api-provider-oci/cloud/metrics/metrics.go (0.0%)</option>
				
				<option value="file35">github.com/oracle/cluster-api-provider-oci/cloud/ociutil/ociutil.go (23.2%)</option>
				
				<option value="file36">github.com/oracle/cluster-api-provider-oci/cloud/ociutil/ptr/from_ptr.go (100.0%)</option>
				
				<option value="file37">github.com/oracle/cluster-api-provider-oci/cloud/scope/clients.go (72.1%)</option>
				
				<option value="file38">github.com/oracle/cluster-api-provider-oci/cloud/scope/clients_mock.go (71.4%)</option>
				
				<option value="file39">github.com/oracle/cluster-api-provider-oci/cloud/scope/cluster.go (81.0%)</option>
				
				<option value="file40">github.com/oracle/cluster-api-provider-oci/cloud/scope/drg_reconciler.go (84.5%)</option>
				
				<option value="file41">github.com/oracle/cluster-api-provider-oci/cloud/scope/drg_rpc_attachment_reconciler.go (74.1%)</option>
				
				<option value="file42">github.com/oracle/cluster-api-provider-oci/cloud/scope/drg_vcn_attachment_reconciler.go (70.2%)</option>
				
				<option value="file43">github.com/oracle/cluster-api-provider-oci/cloud/scope/internet_gateway_reconciler.go (89.7%)</option>
				
				<option value="file44">github.com/oracle/cluster-api-provider-oci/cloud/scope/load_balancer_reconciler.go (88.4%)</option>
				
				<option value="file45">github.com/oracle/cluster-api-provider-oci/cloud/scope/machine.go (83.2%)</option>
				
				<option value="file46">github.com/oracle/cluster-api-provider-oci/cloud/scope/machine_pool.go (57.9%)</option>
				
				<option value="file47">github.com/oracle/cluster-api-provider-oci/cloud/scope/managed_control_plane.go (64.8%)</option>
				
				<option value="file48">github.com/oracle/cluster-api-provider-oci/cloud/scope/managed_machine_pool.go (76.9%)</option>
				
				<option value="file49">github.com/oracle/cluster-api-provider-oci/cloud/scope/mocks/cluster_client_mock.go (0.0%)</option>
				
				<option value="file50">github.com/oracle/cluster-api-provider-oci/cloud/scope/nat_gateway_reconciler.go (79.4%)</option>
				
				<option value="file51">github.com/oracle/cluster-api-provider-oci/cloud/scope/network_load_balancer_reconciler.go (91.2%)</option>
				
				<option value="file52">github.com/oracle/cluster-api-provider-oci/cloud/scope/nsg_reconciler.go (83.2%)</option>
				
				<option value="file53">github.com/oracle/cluster-api-provider-oci/cloud/scope/oci_managed_cluster.go (22.7%)</option>
				
				<option value="file54">github.com/oracle/cluster-api-provider-oci/cloud/scope/oci_selfmanaged_cluster.go (63.6%)</option>
				
				<option value="file55">github.com/oracle/cluster-api-provider-oci/cloud/scope/route_table_reconciler.go (91.3%)</option>
				
				<option value="file56">github.com/oracle/cluster-api-provider-oci/cloud/scope/security_list_reconciler.go (68.1%)</option>
				
				<option value="file57">github.com/oracle/cluster-api-provider-oci/cloud/scope/service_gateway_reconciler.go (83.1%)</option>
				
				<option value="file58">github.com/oracle/cluster-api-provider-oci/cloud/scope/subnet_reconciler.go (70.0%)</option>
				
				<option value="file59">github.com/oracle/cluster-api-provider-oci/cloud/scope/util.go (76.9%)</option>
				
				<option value="file60">github.com/oracle/cluster-api-provider-oci/cloud/scope/vcn_reconciler.go (92.6%)</option>
				
				<option value="file61">github.com/oracle/cluster-api-provider-oci/cloud/scope/virtual_machine_pool.go (67.8%)</option>
				
				<option value="file62">github.com/oracle/cluster-api-provider-oci/cloud/scope/vnic_reconciler.go (75.0%)</option>
				
				<option value="file63">github.com/oracle/cluster-api-provider-oci/cloud/services/base/BaseClient.go (0.0%)</option>
				
				<option value="file64">github.com/oracle/cluster-api-provider-oci/cloud/services/base/mock_base/client_mock.go (0.0%)</option>
				
				<option value="file65">github.com/oracle/cluster-api-provider-oci/cloud/services/compute/mock_compute/client_mock.go (0.0%)</option>
				
				<option value="file66">github.com/oracle/cluster-api-provider-oci/cloud/services/computemanagement/mock_computemanagement/client_mock.go (0.0%)</option>
				
				<option value="file67">github.com/oracle/cluster-api-provider-oci/cloud/services/containerengine/mock_containerengine/client_mock.go (0.0%)</option>
				
				<option value="file68">github.com/oracle/cluster-api-provider-oci/cloud/services/identity/mock_identity/client_mock.go (0.0%)</option>
				
				<option value="file69">github.com/oracle/cluster-api-provider-oci/cloud/services/loadbalancer/mock_lb/client_mock.go (0.0%)</option>
				
				<option value="file70">github.com/oracle/cluster-api-provider-oci/cloud/services/networkloadbalancer/mock_nlb/client_mock.go (0.0%)</option>
				
				<option value="file71">github.com/oracle/cluster-api-provider-oci/cloud/services/vcn/mock_vcn/client_mock.go (0.0%)</option>
				
				<option value="file72">github.com/oracle/cluster-api-provider-oci/cloud/services/workrequests/mock_workrequests/client_mock.go (0.0%)</option>
				
				<option value="file73">github.com/oracle/cluster-api-provider-oci/cloud/util/conversion.go (0.0%)</option>
				
				<option value="file74">github.com/oracle/cluster-api-provider-oci/cloud/util/util.go (60.9%)</option>
				
				<option value="file75">github.com/oracle/cluster-api-provider-oci/controllers/ocicluster_controller.go (68.7%)</option>
				
				<option value="file76">github.com/oracle/cluster-api-provider-oci/controllers/ocimachine_controller.go (61.5%)</option>
				
				<option value="file77">github.com/oracle/cluster-api-provider-oci/controllers/ocimanagedcluster_controller.go (57.1%)</option>
				
				<option value="file78">github.com/oracle/cluster-api-provider-oci/controllers/ocimanagedcluster_controlplane_controller.go (47.3%)</option>
				
				<option value="file79">github.com/oracle/cluster-api-provider-oci/exp/api/v1beta1/conversion.go (50.0%)</option>
				
				<option value="file80">github.com/oracle/cluster-api-provider-oci/exp/api/v1beta1/ocimachinepool_conversion.go (76.9%)</option>
				
				<option value="file81">github.com/oracle/cluster-api-provider-oci/exp/api/v1beta1/ocimachinepool_machine_types.go (100.0%)</option>
				
				<option value="file82">github.com/oracle/cluster-api-provider-oci/exp/api/v1beta1/ocimachinepool_types.go (33.3%)</option>
				
				<option value="file83">github.com/oracle/cluster-api-provider-oci/exp/api/v1beta1/ocimachinepoolmachine_conversion.go (0.0%)</option>
				
				<option value="file84">github.com/oracle/cluster-api-provider-oci/exp/api/v1beta1/ocimanagedmachinepool_conversion.go (78.6%)</option>
				
				<option value="file85">github.com/oracle/cluster-api-provider-oci/exp/api/v1beta1/ocimanagedmachinepool_types.go (33.3%)</option>
				
				<option value="file86">github.com/oracle/cluster-api-provider-oci/exp/api/v1beta1/ocimanagedmachinepooltemplate_types.go (100.0%)</option>
				
				<option value="file87">github.com/oracle/cluster-api-provider-oci/exp/api/v1beta1/ocivirtualmachinepool_conversion.go (0.0%)</option>
				
				<option value="file88">github.com/oracle/cluster-api-provider-oci/exp/api/v1beta1/ocivirtualmachinepool_types.go (33.3%)</option>
				
				<option value="file89">github.com/oracle/cluster-api-provider-oci/exp/api/v1beta2/conversion.go (0.0%)</option>
				
				<option value="file90">github.com/oracle/cluster-api-provider-oci/exp/api/v1beta2/ocimachinepool_machine_types.go (100.0%)</option>
				
				<option value="file91">github.com/oracle/cluster-api-provider-oci/exp/api/v1beta2/ocimachinepool_types.go (33.3%)</option>
				
				<option value="file92">github.com/oracle/cluster-api-provider-oci/exp/api/v1beta2/ocimanagedmachinepool_types.go (33.3%)</option>
				
				<option value="file93">github.com/oracle/cluster-api-provider-oci/exp/api/v1beta2/ocimanagedmachinepool_webhook.go (85.4%)</option>
				
				<option value="file94">github.com/oracle/cluster-api-provider-oci/exp/api/v1beta2/ocimanagedmachinepooltemplate_types.go (100.0%)</option>
				
				<option value="file95">github.com/oracle/cluster-api-provider-oci/exp/api/v1beta2/ocivirtualmachinepool_types.go (33.3%)</option>
				
				<option value="file96">github.com/oracle/cluster-api-provider-oci/exp/api/v1beta2/ocivirtualmachinepool_webhook.go (0.0%)</option>
				
				<option value="file97">github.com/oracle/cluster-api-provider-oci/exp/controllers/ocimachinepool_controller.go (48.9%)</option>
				
				<option value="file98">github.com/oracle/cluster-api-provider-oci/exp/controllers/ocimachinepoolmachine_controller.go (0.0%)</option>
				
				<option value="file99">github.com/oracle/cluster-api-provider-oci/exp/controllers/ocimanaged_machinepool_controller.go (53.5%)</option>
				
				<option value="file100">github.com/oracle/cluster-api-provider-oci/exp/controllers/ocivirtual_machinepool_controller.go (51.6%)</option>
				
				<option value="file101">github.com/oracle/cluster-api-provider-oci/feature/feature.go (0.0%)</option>
				
				<option value="file102">github.com/oracle/cluster-api-provider-oci/main.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">/*
 Copyright (c) 2023 Oracle and/or its affiliates.

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

      https://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
*/

package v1beta1

import (
        "github.com/oracle/cluster-api-provider-oci/api/v1beta2"
        "k8s.io/apimachinery/pkg/conversion"
)

// Convert_v1beta1_VCN_To_v1beta2_VCN converts v1beta1 VCN to v1beta2 VCN
func Convert_v1beta1_VCN_To_v1beta2_VCN(in *VCN, out *v1beta2.VCN, s conversion.Scope) error <span class="cov8" title="1">{
        err := autoConvert_v1beta1_VCN_To_v1beta2_VCN(in, out, s)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if in.InternetGatewayId != nil </span><span class="cov8" title="1">{
                out.InternetGateway.Id = in.InternetGatewayId
        }</span>
        <span class="cov8" title="1">if in.NatGatewayId != nil </span><span class="cov8" title="1">{
                out.NATGateway.Id = in.NatGatewayId
        }</span>
        <span class="cov8" title="1">if in.ServiceGatewayId != nil </span><span class="cov8" title="1">{
                out.ServiceGateway.Id = in.ServiceGatewayId
        }</span>
        <span class="cov8" title="1">if in.PrivateRouteTableId != nil </span><span class="cov8" title="1">{
                out.RouteTable.PrivateRouteTableId = in.PrivateRouteTableId
        }</span>
        <span class="cov8" title="1">if in.PublicRouteTableId != nil </span><span class="cov8" title="1">{
                out.RouteTable.PublicRouteTableId = in.PublicRouteTableId
        }</span>
        <span class="cov8" title="1">if in.NetworkSecurityGroups != nil </span><span class="cov8" title="1">{
                nsgList, err := convertv1beta1NSGListTov1beta2NSGList(in.NetworkSecurityGroups)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">out.NetworkSecurityGroup.List = nsgList</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// Convert_v1beta2_VCN_To_v1beta1_VCN converts v1beta2 VCN to v1beta1 VCN
func Convert_v1beta2_VCN_To_v1beta1_VCN(in *v1beta2.VCN, out *VCN, s conversion.Scope) error <span class="cov8" title="1">{
        err := autoConvert_v1beta2_VCN_To_v1beta1_VCN(in, out, s)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if in.InternetGateway.Id != nil </span><span class="cov8" title="1">{
                out.InternetGatewayId = in.InternetGateway.Id
        }</span>
        <span class="cov8" title="1">if in.NATGateway.Id != nil </span><span class="cov8" title="1">{
                out.NatGatewayId = in.NATGateway.Id
        }</span>
        <span class="cov8" title="1">if in.ServiceGateway.Id != nil </span><span class="cov8" title="1">{
                out.ServiceGatewayId = in.ServiceGateway.Id
        }</span>
        <span class="cov8" title="1">if in.RouteTable.PublicRouteTableId != nil </span><span class="cov8" title="1">{
                out.PublicRouteTableId = in.RouteTable.PublicRouteTableId
        }</span>
        <span class="cov8" title="1">if in.RouteTable.PrivateRouteTableId != nil </span><span class="cov8" title="1">{
                out.PrivateRouteTableId = in.RouteTable.PrivateRouteTableId
        }</span>
        <span class="cov8" title="1">if in.NetworkSecurityGroup.List != nil </span><span class="cov8" title="1">{
                nsgList, err := convertv1beta2NSGListTov1beta1NSGList(in.NetworkSecurityGroup.List)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">out.NetworkSecurityGroups = nsgList</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// Convert_v1beta1_OCIClusterStatus_To_v1beta2_OCIClusterStatus converts v1beta1 OCIClusterStatus to v1beta2 OCIClusterStatus
func Convert_v1beta1_OCIClusterStatus_To_v1beta2_OCIClusterStatus(in *OCIClusterStatus, out *v1beta2.OCIClusterStatus, s conversion.Scope) error <span class="cov8" title="1">{
        return autoConvert_v1beta1_OCIClusterStatus_To_v1beta2_OCIClusterStatus(in, out, s)
}</span>

// Convert_v1beta2_OCIClusterSpec_To_v1beta1_OCIClusterSpec converts v1beta2 OCIClusterStatus to v1beta1 OCIClusterStatus
func Convert_v1beta2_OCIClusterSpec_To_v1beta1_OCIClusterSpec(in *v1beta2.OCIClusterSpec, out *OCIClusterSpec, s conversion.Scope) error <span class="cov8" title="1">{
        return autoConvert_v1beta2_OCIClusterSpec_To_v1beta1_OCIClusterSpec(in, out, s)
}</span>

// Convert_v1beta1_EgressSecurityRuleForNSG_To_v1beta2_EgressSecurityRuleForNSG converts v1beta1 EgressSecurityRuleForNSG to v1beta2 EgressSecurityRuleForNSG
func Convert_v1beta1_EgressSecurityRuleForNSG_To_v1beta2_EgressSecurityRuleForNSG(in *EgressSecurityRuleForNSG, out *v1beta2.EgressSecurityRuleForNSG, s conversion.Scope) error <span class="cov8" title="1">{
        return autoConvert_v1beta1_EgressSecurityRuleForNSG_To_v1beta2_EgressSecurityRuleForNSG(in, out, s)
}</span>

// Convert_v1beta1_IngressSecurityRuleForNSG_To_v1beta2_IngressSecurityRuleForNSG converts v1beta1 IngressSecurityRuleForNSG to v1beta2 IngressSecurityRuleForNSG
func Convert_v1beta1_IngressSecurityRuleForNSG_To_v1beta2_IngressSecurityRuleForNSG(in *IngressSecurityRuleForNSG, out *v1beta2.IngressSecurityRuleForNSG, s conversion.Scope) error <span class="cov8" title="1">{
        return autoConvert_v1beta1_IngressSecurityRuleForNSG_To_v1beta2_IngressSecurityRuleForNSG(in, out, s)
}</span>

// Convert_v1beta1_NetworkDetails_To_v1beta2_NetworkDetails converts v1beta1 NetworkDetails to v1beta2 NetworkDetails
func Convert_v1beta1_NetworkDetails_To_v1beta2_NetworkDetails(in *NetworkDetails, out *v1beta2.NetworkDetails, s conversion.Scope) error <span class="cov8" title="1">{
        return autoConvert_v1beta1_NetworkDetails_To_v1beta2_NetworkDetails(in, out, s)
}</span>

// Convert_v1beta1_OCIMachineSpec_To_v1beta2_OCIMachineSpec converts v1beta1 OCIMachineSpec to v1beta2 OCIMachineSpec
func Convert_v1beta1_OCIMachineSpec_To_v1beta2_OCIMachineSpec(in *OCIMachineSpec, out *v1beta2.OCIMachineSpec, s conversion.Scope) error <span class="cov8" title="1">{
        err := autoConvert_v1beta1_OCIMachineSpec_To_v1beta2_OCIMachineSpec(in, out, s)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if in.NSGName != "" &amp;&amp; len(in.NetworkDetails.NsgNames) == 0 </span><span class="cov0" title="0">{
                out.NetworkDetails.NsgNames = []string{in.NSGName}
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// Convert_v1beta2_LoadBalancer_To_v1beta1_LoadBalancer converts v1beta2 LoadBalancer to v1beta1 LoadBalancer
func Convert_v1beta2_LoadBalancer_To_v1beta1_LoadBalancer(in *v1beta2.LoadBalancer, out *LoadBalancer, s conversion.Scope) error <span class="cov8" title="1">{
        return autoConvert_v1beta2_LoadBalancer_To_v1beta1_LoadBalancer(in, out, s)
}</span>

func Convert_v1beta2_OCIManagedControlPlaneStatus_To_v1beta1_OCIManagedControlPlaneStatus(in *v1beta2.OCIManagedControlPlaneStatus, out *OCIManagedControlPlaneStatus, s conversion.Scope) error <span class="cov8" title="1">{
        return autoConvert_v1beta2_OCIManagedControlPlaneStatus_To_v1beta1_OCIManagedControlPlaneStatus(in, out, s)
}</span>

func Convert_v1beta2_OCIManagedControlPlaneSpec_To_v1beta1_OCIManagedControlPlaneSpec(in *v1beta2.OCIManagedControlPlaneSpec, out *OCIManagedControlPlaneSpec, s conversion.Scope) error <span class="cov8" title="1">{
        return autoConvert_v1beta2_OCIManagedControlPlaneSpec_To_v1beta1_OCIManagedControlPlaneSpec(in, out, s)
}</span>

// Convert_v1beta1_OCIManagedClusterStatus_To_v1beta2_OCIManagedClusterStatus converts v1beta1 OCIManagedClusterStatus to v1beta2 OCIManagedClusterStatus
func Convert_v1beta1_OCIManagedClusterStatus_To_v1beta2_OCIManagedClusterStatus(in *OCIManagedClusterStatus, out *v1beta2.OCIManagedClusterStatus, s conversion.Scope) error <span class="cov8" title="1">{
        return autoConvert_v1beta1_OCIManagedClusterStatus_To_v1beta2_OCIManagedClusterStatus(in, out, s)
}</span>

// Convert_v1beta2_OCIManagedClusterSpec_To_v1beta1_OCIManagedClusterSpec converts v1beta1 OCIManagedClusterSpec to v1beta2 OCIManagedClusterSpec
func Convert_v1beta2_OCIManagedClusterSpec_To_v1beta1_OCIManagedClusterSpec(in *v1beta2.OCIManagedClusterSpec, out *OCIManagedClusterSpec, s conversion.Scope) error <span class="cov8" title="1">{
        return autoConvert_v1beta2_OCIManagedClusterSpec_To_v1beta1_OCIManagedClusterSpec(in, out, s)
}</span>

// Convert_v1beta2_ClusterOptions_To_v1beta1_ClusterOptions converts v1beta2 ClusterOptions to v1beta1 ClusterOptions
func Convert_v1beta2_ClusterOptions_To_v1beta1_ClusterOptions(in *v1beta2.ClusterOptions, out *ClusterOptions, s conversion.Scope) error <span class="cov8" title="1">{
        return autoConvert_v1beta2_ClusterOptions_To_v1beta1_ClusterOptions(in, out, s)
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">/*
 Copyright (c) 2023 Oracle and/or its affiliates.

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

      https://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
*/

package v1beta1

import (
        "github.com/oracle/cluster-api-provider-oci/api/v1beta2"
        utilconversion "sigs.k8s.io/cluster-api/util/conversion"
        "sigs.k8s.io/controller-runtime/pkg/conversion"
)

// ConvertTo converts the v1beta1 OCICluster receiver to a v1beta2 OCICluster.
func (src *OCICluster) ConvertTo(dstRaw conversion.Hub) error <span class="cov8" title="1">{
        dst := dstRaw.(*v1beta2.OCICluster)

        if err := Convert_v1beta1_OCICluster_To_v1beta2_OCICluster(src, dst, nil); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">ad, err := Convertv1beta1AdMapTov1beta2AdMap(src.Status.AvailabilityDomains)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">dst.Spec.AvailabilityDomains = ad

        // Manually restore data.
        restored := &amp;v1beta2.OCICluster{}
        if ok, err := utilconversion.UnmarshalData(src, restored); err != nil || !ok </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">dst.Spec.NetworkSpec.Vcn.NetworkSecurityGroup.Skip = restored.Spec.NetworkSpec.Vcn.NetworkSecurityGroup.Skip
        dst.Spec.NetworkSpec.Vcn.NATGateway.Skip = restored.Spec.NetworkSpec.Vcn.NATGateway.Skip
        dst.Spec.NetworkSpec.Vcn.ServiceGateway.Skip = restored.Spec.NetworkSpec.Vcn.ServiceGateway.Skip
        dst.Spec.NetworkSpec.Vcn.InternetGateway.Skip = restored.Spec.NetworkSpec.Vcn.InternetGateway.Skip
        dst.Spec.NetworkSpec.Vcn.RouteTable.Skip = restored.Spec.NetworkSpec.Vcn.RouteTable.Skip
        dst.Spec.NetworkSpec.APIServerLB.LoadBalancerType = restored.Spec.NetworkSpec.APIServerLB.LoadBalancerType
        dst.Spec.ClientOverrides = restored.Spec.ClientOverrides

        return nil</span>
}

func convertv1beta1NSGListTov1beta2NSGList(in []*NSG) ([]*v1beta2.NSG, error) <span class="cov8" title="1">{
        out := make([]*v1beta2.NSG, len(in))
        for i, nsg := range in </span><span class="cov8" title="1">{
                if nsg == nil </span><span class="cov8" title="1">{
                        out[i] = nil
                        continue</span>
                }
                <span class="cov8" title="1">out[i] = &amp;v1beta2.NSG{}
                err := Convert_v1beta1_NSG_To_v1beta2_NSG(nsg, out[i], nil)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }
        <span class="cov8" title="1">return out, nil</span>
}
func convertv1beta2NSGListTov1beta1NSGList(in []*v1beta2.NSG) ([]*NSG, error) <span class="cov8" title="1">{
        out := make([]*NSG, len(in))
        for i, nsg := range in </span><span class="cov8" title="1">{
                if nsg == nil </span><span class="cov8" title="1">{
                        out[i] = nil
                        continue</span>
                }
                <span class="cov8" title="1">out[i] = &amp;NSG{}
                err := Convert_v1beta2_NSG_To_v1beta1_NSG(nsg, out[i], nil)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }
        <span class="cov8" title="1">return out, nil</span>
}

func Convertv1beta1AdMapTov1beta2AdMap(in map[string]OCIAvailabilityDomain) (map[string]v1beta2.OCIAvailabilityDomain, error) <span class="cov8" title="1">{
        out := make(map[string]v1beta2.OCIAvailabilityDomain)
        for k, _ := range in </span><span class="cov8" title="1">{
                outV := &amp;v1beta2.OCIAvailabilityDomain{}
                inDomain := in[k]
                err := Convert_v1beta1_OCIAvailabilityDomain_To_v1beta2_OCIAvailabilityDomain(&amp;inDomain, outV, nil)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">out[k] = *outV</span>
        }
        <span class="cov8" title="1">return out, nil</span>
}

func Convertv1beta2AdMapTov1beta1AdMap(in map[string]v1beta2.OCIAvailabilityDomain) (map[string]OCIAvailabilityDomain, error) <span class="cov8" title="1">{
        out := make(map[string]OCIAvailabilityDomain)
        for k, _ := range in </span><span class="cov8" title="1">{
                outV := &amp;OCIAvailabilityDomain{}
                inDomain := in[k]
                err := Convert_v1beta2_OCIAvailabilityDomain_To_v1beta1_OCIAvailabilityDomain(&amp;inDomain, outV, nil)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">out[k] = *outV</span>
        }
        <span class="cov8" title="1">return out, nil</span>
}

// ConvertFrom converts receiver to a v1beta2 OCICluster.
func (r *OCICluster) ConvertFrom(srcRaw conversion.Hub) error <span class="cov8" title="1">{
        src := srcRaw.(*v1beta2.OCICluster)

        if err := Convert_v1beta2_OCICluster_To_v1beta1_OCICluster(src, r, nil); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">ad, err := Convertv1beta2AdMapTov1beta1AdMap(src.Spec.AvailabilityDomains)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">r.Status.AvailabilityDomains = ad

        // Preserve Hub data on down-conversion.
        if err := utilconversion.MarshalData(src, r); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// ConvertTo converts the v1beta1 OCIClusterList receiver to a v1beta2 OCIClusterList.
func (src *OCIClusterList) ConvertTo(dstRaw conversion.Hub) error <span class="cov0" title="0">{
        dst := dstRaw.(*v1beta2.OCIClusterList)

        return Convert_v1beta1_OCIClusterList_To_v1beta2_OCIClusterList(src, dst, nil)
}</span>

// ConvertFrom converts the v1beta2 AWSClusterList receiver to a v1beta1 OCIClusterList.
func (r *OCIClusterList) ConvertFrom(srcRaw conversion.Hub) error <span class="cov0" title="0">{
        src := srcRaw.(*v1beta2.OCIClusterList)

        return Convert_v1beta2_OCIClusterList_To_v1beta1_OCIClusterList(src, r, nil)
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">/*
Copyright (c) 2021, 2022 Oracle and/or its affiliates.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1beta1

import (
        corev1 "k8s.io/api/core/v1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        clusterv1 "sigs.k8s.io/cluster-api/api/core/v1beta1"
)

// NOTE: json tags are required.  Any new fields you add must have json tags for the fields to be serialized.
// Important: Run "make" to regenerate code after modifying this file

const (
        // ClusterFinalizer allows OCIClusterReconciler to clean up OCI resources associated with OCICluster before
        // removing it from the apiserver.
        ClusterFinalizer = "ocicluster.infrastructure.cluster.x-k8s.io"
)

// OCIClusterSpec defines the desired state of OciCluster
type OCIClusterSpec struct {

        // The unique ID which will be used to tag all the resources created by this Cluster.
        // The tag will be used to identify resources belonging to this cluster.
        // this will be auto-generated and should not be set by the user.
        // +optional
        OCIResourceIdentifier string `json:"ociResourceIdentifier,omitempty"`

        // IdentityRef is a reference to an identity(principal) to be used when reconciling this cluster
        // +optional
        IdentityRef *corev1.ObjectReference `json:"identityRef,omitempty"`

        // NetworkSpec encapsulates all things related to OCI network.
        // +optional
        NetworkSpec NetworkSpec `json:"networkSpec,omitempty"`

        // Free-form tags for this resource.
        // +optional
        FreeformTags map[string]string `json:"freeformTags,omitempty"`

        // Defined tags for this resource. Each key is predefined and scoped to a
        // namespace. For more information, see Resource Tags (https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        // Example: `{"Operations": {"CostCenter": "42"}}`
        // +optional
        DefinedTags map[string]map[string]string `json:"definedTags,omitempty"`

        // Compartment to create the cluster network.
        // +optional
        CompartmentId string `json:"compartmentId"`

        // Region the cluster operates in. It must be one of available regions in Region Identifier format.
        // See https://docs.oracle.com/en-us/iaas/Content/General/Concepts/regions.htm
        Region string `json:"region,omitempty"`

        // ControlPlaneEndpoint represents the endpoint used to communicate with the control plane.
        // +optional
        ControlPlaneEndpoint clusterv1.APIEndpoint `json:"controlPlaneEndpoint"`
}

// OCIClusterStatus defines the observed state of OCICluster
type OCIClusterStatus struct {
        // +optional
        FailureDomains clusterv1.FailureDomains `json:"failureDomains,omitempty"`

        // AvailabilityDomains encapsulates the clusters Availability Domain (AD) information in a map
        // where the map key is the AD name and the struct is details about the AD.
        // +optional
        AvailabilityDomains map[string]OCIAvailabilityDomain `json:"availabilityDomains,omitempty"`

        // +optional
        Ready bool `json:"ready"`
        // NetworkSpec encapsulates all things related to OCI network.
        // +optional
        Conditions clusterv1.Conditions `json:"conditions,omitempty"`
}

//+kubebuilder:object:root=true
//+kubebuilder:subresource:status

// OCICluster is the Schema for the ociclusters API.
type OCICluster struct {
        metav1.TypeMeta   `json:",inline"`
        metav1.ObjectMeta `json:"metadata,omitempty"`

        Spec   OCIClusterSpec   `json:"spec,omitempty"`
        Status OCIClusterStatus `json:"status,omitempty"`
}

//+kubebuilder:object:root=true

// OCIClusterList contains a list of OCICluster.
type OCIClusterList struct {
        metav1.TypeMeta `json:",inline"`
        metav1.ListMeta `json:"metadata,omitempty"`
        Items           []OCICluster `json:"items"`
}

// OCIAvailabilityDomain contains information about an Availability Domain (AD).
type OCIAvailabilityDomain struct {

        // Name is the AD's full name. Example: Uocm:PHX-AD-1
        Name string `json:"name,omitempty"`

        // FaultDomains a list of fault domain (FD) names. Example: ["FAULT-DOMAIN-1"]
        FaultDomains []string `json:"faultDomains,omitempty"`
}

// GetConditions returns the list of conditions for an OCICluster API object.
func (c *OCICluster) GetConditions() clusterv1.Conditions <span class="cov0" title="0">{
        return c.Status.Conditions
}</span>

// SetConditions will set the given conditions on an OCICluster object.
func (c *OCICluster) SetConditions(conditions clusterv1.Conditions) <span class="cov0" title="0">{
        c.Status.Conditions = conditions
}</span>

// GetOCIResourceIdentifier will return the OCI resource identifier.
func (c *OCICluster) GetOCIResourceIdentifier() string <span class="cov0" title="0">{
        return c.Spec.OCIResourceIdentifier
}</span>

func init() <span class="cov8" title="1">{
        SchemeBuilder.Register(&amp;OCICluster{}, &amp;OCIClusterList{})
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">/*
Copyright (c) 2022, Oracle and/or its affiliates.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1beta1

import (
        "github.com/oracle/cluster-api-provider-oci/api/v1beta2"
        utilconversion "sigs.k8s.io/cluster-api/util/conversion"
        "sigs.k8s.io/controller-runtime/pkg/conversion"
)

// ConvertTo converts the v1beta1 OCIClusterIdentity receiver to a v1beta2 OCIClusterIdentity.
func (src *OCIClusterIdentity) ConvertTo(dstRaw conversion.Hub) error <span class="cov8" title="1">{
        dst := dstRaw.(*v1beta2.OCIClusterIdentity)
        if err := Convert_v1beta1_OCIClusterIdentity_To_v1beta2_OCIClusterIdentity(src, dst, nil); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Manually restore data.
        <span class="cov8" title="1">restored := &amp;v1beta2.OCIClusterIdentity{}
        if ok, err := utilconversion.UnmarshalData(src, restored); err != nil || !ok </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// ConvertFrom converts the v1beta2 OCIClusterIdentity to a v1beta1 OCIClusterIdentity.
func (dst *OCIClusterIdentity) ConvertFrom(srcRaw conversion.Hub) error <span class="cov8" title="1">{
        src := srcRaw.(*v1beta2.OCIClusterIdentity)

        if err := Convert_v1beta2_OCIClusterIdentity_To_v1beta1_OCIClusterIdentity(src, dst, nil); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Preserve Hub data on down-conversion except for metadata.
        <span class="cov8" title="1">return utilconversion.MarshalData(src, dst)</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">/*
 Copyright (c) 2022, 2023 Oracle and/or its affiliates.

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

      https://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
*/

package v1beta1

import (
        corev1 "k8s.io/api/core/v1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        clusterv1 "sigs.k8s.io/cluster-api/api/core/v1beta1"
)

type PrincipalType string

const (
        // UserPrincipal represents a user principal.
        UserPrincipal PrincipalType = "UserPrincipal"
)

// OCIClusterIdentitySpec defines the parameters that are used to create an OCIClusterIdentity.
type OCIClusterIdentitySpec struct {
        // Type is the type of OCI Principal used.
        // UserPrincipal is the only supported value
        Type PrincipalType `json:"type"`

        // PrincipalSecret is a secret reference which contains the authentication credentials for the principal.
        // +optional
        PrincipalSecret corev1.SecretReference `json:"principalSecret,omitempty"`

        // AllowedNamespaces is used to identify the namespaces the clusters are allowed to use the identity from.
        // Namespaces can be selected either using an array of namespaces or with label selector.
        // An empty allowedNamespaces object indicates that OCIClusters can use this identity from any namespace.
        // If this object is nil, no namespaces will be allowed (default behaviour, if this field is not provided)
        // A namespace should be either in the NamespaceList or match with Selector to use the identity.
        //
        // +optional
        // +nullable
        AllowedNamespaces *AllowedNamespaces `json:"allowedNamespaces"`
}

// AllowedNamespaces defines the namespaces the clusters are allowed to use the identity from
type AllowedNamespaces struct {
        // A nil or empty list indicates that OCICluster cannot use the identity from any namespace.
        // NamespaceList takes precedence over the Selector.
        // +optional
        // +nullable
        NamespaceList []string `json:"list"`

        // Selector is a selector of namespaces that OCICluster can
        // use this Identity from. This is a standard Kubernetes LabelSelector,
        // a label query over a set of resources. The result of matchLabels and
        // matchExpressions are ANDed.
        //
        // A nil or empty selector indicates that OCICluster cannot use this
        // OCIClusterIdentity from any namespace.
        // +optional
        Selector *metav1.LabelSelector `json:"selector"`
}

// OCIClusterIdentityStatus defines the observed state of OCIClusterIdentity.
type OCIClusterIdentityStatus struct {
        // Conditions defines current service state of the OCIClusterIdentity.
        // +optional
        Conditions clusterv1.Conditions `json:"conditions,omitempty"`
}

//+kubebuilder:object:root=true
//+kubebuilder:subresource:status

// OCIClusterIdentity is the Schema for the OCI Cluster Identity API
type OCIClusterIdentity struct {
        metav1.TypeMeta   `json:",inline"`
        metav1.ObjectMeta `json:"metadata,omitempty"`
        Spec              OCIClusterIdentitySpec   `json:"spec,omitempty"`
        Status            OCIClusterIdentityStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// OCIClusterIdentityList contains a list of OCIClusterIdentity.
type OCIClusterIdentityList struct {
        metav1.TypeMeta `json:",inline"`
        metav1.ListMeta `json:"metadata,omitempty"`
        Items           []OCIClusterIdentity `json:"items"`
}

func init() <span class="cov8" title="1">{
        SchemeBuilder.Register(&amp;OCIClusterIdentity{}, &amp;OCIClusterIdentityList{})
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">/*
Copyright (c) 2022, Oracle and/or its affiliates.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1beta1

import (
        "github.com/oracle/cluster-api-provider-oci/api/v1beta2"
        utilconversion "sigs.k8s.io/cluster-api/util/conversion"
        "sigs.k8s.io/controller-runtime/pkg/conversion"
)

// ConvertTo converts the v1beta1 OCIClusterTemplate receiver to a v1beta2 OCIClusterTemplate.
func (src *OCIClusterTemplate) ConvertTo(dstRaw conversion.Hub) error <span class="cov8" title="1">{
        dst := dstRaw.(*v1beta2.OCIClusterTemplate)
        if err := Convert_v1beta1_OCIClusterTemplate_To_v1beta2_OCIClusterTemplate(src, dst, nil); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Manually restore data.
        <span class="cov8" title="1">restored := &amp;v1beta2.OCIClusterTemplate{}
        if ok, err := utilconversion.UnmarshalData(src, restored); err != nil || !ok </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">dst.Spec.Template.Spec.NetworkSpec.Vcn.NetworkSecurityGroup.Skip = restored.Spec.Template.Spec.NetworkSpec.Vcn.NetworkSecurityGroup.Skip
        dst.Spec.Template.Spec.NetworkSpec.Vcn.NATGateway.Skip = restored.Spec.Template.Spec.NetworkSpec.Vcn.NATGateway.Skip
        dst.Spec.Template.Spec.NetworkSpec.Vcn.ServiceGateway.Skip = restored.Spec.Template.Spec.NetworkSpec.Vcn.ServiceGateway.Skip
        dst.Spec.Template.Spec.NetworkSpec.Vcn.InternetGateway.Skip = restored.Spec.Template.Spec.NetworkSpec.Vcn.InternetGateway.Skip
        dst.Spec.Template.Spec.NetworkSpec.Vcn.RouteTable.Skip = restored.Spec.Template.Spec.NetworkSpec.Vcn.RouteTable.Skip
        dst.Spec.Template.Spec.AvailabilityDomains = restored.Spec.Template.Spec.AvailabilityDomains
        dst.Spec.Template.Spec.NetworkSpec.APIServerLB.LoadBalancerType = restored.Spec.Template.Spec.NetworkSpec.APIServerLB.LoadBalancerType
        dst.Spec.Template.Spec.ClientOverrides = restored.Spec.Template.Spec.ClientOverrides
        return nil</span>
}

// ConvertFrom converts the v1beta2 OCIClusterTemplate to a v1beta1 OCIClusterTemplate.
func (dst *OCIClusterTemplate) ConvertFrom(srcRaw conversion.Hub) error <span class="cov8" title="1">{
        src := srcRaw.(*v1beta2.OCIClusterTemplate)

        if err := Convert_v1beta2_OCIClusterTemplate_To_v1beta1_OCIClusterTemplate(src, dst, nil); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Preserve Hub data on down-conversion except for metadata.
        <span class="cov8" title="1">return utilconversion.MarshalData(src, dst)</span>
}

// ConvertTo converts the v1beta1 OCIMachineTemplateList receiver to a v1beta2 OCIMachineTemplateList.
func (src *OCIClusterTemplateList) ConvertTo(dstRaw conversion.Hub) error <span class="cov0" title="0">{
        dst := dstRaw.(*v1beta2.OCIClusterTemplateList)
        return Convert_v1beta1_OCIClusterTemplateList_To_v1beta2_OCIClusterTemplateList(src, dst, nil)
}</span>

// ConvertFrom converts the v1beta2 OCIMachineTemplateList to a v1beta1 OCIMachineTemplateList.
func (dst *OCIClusterTemplateList) ConvertFrom(srcRaw conversion.Hub) error <span class="cov0" title="0">{
        src := srcRaw.(*v1beta2.OCIClusterTemplateList)

        return Convert_v1beta2_OCIClusterTemplateList_To_v1beta1_OCIClusterTemplateList(src, dst, nil)
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">/*
Copyright (c) 2022, Oracle and/or its affiliates.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1beta1

import (
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

// OCIClusterTemplateSpec defines the desired state of OCIClusterTemplate.
type OCIClusterTemplateSpec struct {
        Template OCIClusterTemplateResource `json:"template"`
}

// +kubebuilder:object:root=true
// +kubebuilder:resource:path=ociclustertemplates,scope=Namespaced,categories=cluster-api

// OCIClusterTemplate is the Schema for the ociclustertemplates API.
type OCIClusterTemplate struct {
        metav1.TypeMeta   `json:",inline"`
        metav1.ObjectMeta `json:"metadata,omitempty"`

        Spec OCIClusterTemplateSpec `json:"spec,omitempty"`
}

// +kubebuilder:object:root=true

// OCIClusterTemplateList contains a list of OCIClusterTemplate.
type OCIClusterTemplateList struct {
        metav1.TypeMeta `json:",inline"`
        metav1.ListMeta `json:"metadata,omitempty"`

        Items []OCIClusterTemplate `json:"items"`
}

func init() <span class="cov8" title="1">{
        SchemeBuilder.Register(&amp;OCIClusterTemplate{}, &amp;OCIClusterTemplateList{})
}</span>

// OCIClusterTemplateResource describes the data needed to create an OCICluster from a template.
type OCIClusterTemplateResource struct {
        Spec OCIClusterSpec `json:"spec"`
}
</pre>
		
		<pre class="file" id="file7" style="display: none">/*
Copyright (c) 2022, Oracle and/or its affiliates.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1beta1

import (
        "github.com/oracle/cluster-api-provider-oci/api/v1beta2"
        utilconversion "sigs.k8s.io/cluster-api/util/conversion"
        "sigs.k8s.io/controller-runtime/pkg/conversion"
)

// ConvertTo converts the v1beta1 OCIMachine receiver to a v1beta2 OCIMachine.
func (src *OCIMachine) ConvertTo(dstRaw conversion.Hub) error <span class="cov8" title="1">{
        dst := dstRaw.(*v1beta2.OCIMachine)
        if err := Convert_v1beta1_OCIMachine_To_v1beta2_OCIMachine(src, dst, nil); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Manually restore data.
        <span class="cov8" title="1">restored := &amp;v1beta2.OCIMachine{}
        if ok, err := utilconversion.UnmarshalData(src, restored); err != nil || !ok </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// ConvertFrom converts the v1beta2 OCIMachine to a v1beta1 OCIMachine.
func (dst *OCIMachine) ConvertFrom(srcRaw conversion.Hub) error <span class="cov8" title="1">{
        src := srcRaw.(*v1beta2.OCIMachine)
        if err := Convert_v1beta2_OCIMachine_To_v1beta1_OCIMachine(src, dst, nil); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        // Preserve Hub data on down-conversion except for metadata.
        <span class="cov8" title="1">return utilconversion.MarshalData(src, dst)</span>
}

// ConvertTo converts the v1beta1 OCIMachineList receiver to a v1beta2 OCIMachineList.
func (src *OCIMachineList) ConvertTo(dstRaw conversion.Hub) error <span class="cov0" title="0">{
        dst := dstRaw.(*v1beta2.OCIMachineList)
        return Convert_v1beta1_OCIMachineList_To_v1beta2_OCIMachineList(src, dst, nil)
}</span>

// ConvertFrom converts the v1beta2 OCIMachineList to a v1beta1 OCIMachineList.
func (dst *OCIMachineList) ConvertFrom(srcRaw conversion.Hub) error <span class="cov0" title="0">{
        src := srcRaw.(*v1beta2.OCIMachineList)

        return Convert_v1beta2_OCIMachineList_To_v1beta1_OCIMachineList(src, dst, nil)
}</span>

// ConvertTo converts the v1beta1 OCIMachineTemplate receiver to a v1beta2 OCIMachineTemplate.
func (r *OCIMachineTemplate) ConvertTo(dstRaw conversion.Hub) error <span class="cov8" title="1">{
        dst := dstRaw.(*v1beta2.OCIMachineTemplate)

        if err := Convert_v1beta1_OCIMachineTemplate_To_v1beta2_OCIMachineTemplate(r, dst, nil); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Manually restore data.
        <span class="cov8" title="1">restored := &amp;v1beta2.OCIMachineTemplate{}
        if ok, err := utilconversion.UnmarshalData(r, restored); err != nil || !ok </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// ConvertFrom converts the v1beta2 OCIMachineTemplate receiver to a v1beta1 OCIMachineTemplate.
func (r *OCIMachineTemplate) ConvertFrom(srcRaw conversion.Hub) error <span class="cov8" title="1">{
        src := srcRaw.(*v1beta2.OCIMachineTemplate)

        if err := Convert_v1beta2_OCIMachineTemplate_To_v1beta1_OCIMachineTemplate(src, r, nil); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Preserve Hub data on down-conversion.
        <span class="cov8" title="1">if err := utilconversion.MarshalData(src, r); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// ConvertTo converts the v1beta1 OCIMachineTemplateList receiver to a v1beta2 OCIMachineTemplateList.
func (src *OCIMachineTemplateList) ConvertTo(dstRaw conversion.Hub) error <span class="cov0" title="0">{
        dst := dstRaw.(*v1beta2.OCIMachineTemplateList)
        return Convert_v1beta1_OCIMachineTemplateList_To_v1beta2_OCIMachineTemplateList(src, dst, nil)
}</span>

// ConvertFrom converts the v1beta2 OCIMachineTemplateList to a v1beta1 OCIMachineTemplateList.
func (dst *OCIMachineTemplateList) ConvertFrom(srcRaw conversion.Hub) error <span class="cov0" title="0">{
        src := srcRaw.(*v1beta2.OCIMachineTemplateList)

        return Convert_v1beta2_OCIMachineTemplateList_To_v1beta1_OCIMachineTemplateList(src, dst, nil)
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">/*
Copyright (c) 2021, 2022 Oracle and/or its affiliates.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1beta1

import (
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        clusterv1 "sigs.k8s.io/cluster-api/api/core/v1beta1"
)

// NOTE: json tags are required.  Any new fields you add must have json tags for the fields to be serialized.
// Important: Run "make" to regenerate code after modifying this file

const (
        // MachineFinalizer allows ReconcileMachine to clean up OCI resources associated with OCIMachine before
        // removing it from the apiserver.
        MachineFinalizer = "ocimachine.infrastructure.cluster.x-k8s.io"
)

// OCIMachineSpec defines the desired state of OCIMachine
// Please read the API https://docs.oracle.com/en-us/iaas/api/#/en/iaas/20160918/Instance/LaunchInstance
// for more information about the parameters below
type OCIMachineSpec struct {
        // OCID of launched compute instance.
        // +optional
        InstanceId *string `json:"instanceId,omitempty"`

        // OCID of the image to be used to launch the instance.
        ImageId string `json:"imageId,omitempty"`

        // Compartment to launch the instance in.
        CompartmentId string `json:"compartmentId,omitempty"`

        // Shape of the instance.
        Shape string `json:"shape,omitempty"`

        // ComputeClusterId refers to OCID of the compute cluster that the instance will be created in.
        // Please refer https://docs.oracle.com/en-us/iaas/Content/Compute/Tasks/compute-clusters.htm for more details
        ComputeClusterId *string `json:"computeClusterId,omitempty"`

        // IpxeScript is the  custom iPXE script that will run when the instance boots.
        IpxeScript *string `json:"ipxeScript,omitempty"`

        // CapacityReservationId defines the OCID of the compute capacity reservation this instance is launched under.
        // You can opt out of all default reservations by specifying an empty string as input for this field.
        // For more information, see Capacity Reservations (https://docs.cloud.oracle.com/iaas/Content/Compute/Tasks/reserve-capacity.htm#default).
        CapacityReservationId *string `json:"capacityReservationId,omitempty"`

        // The shape configuration of rhe instance, applicable for flex instances.
        ShapeConfig ShapeConfig `json:"shapeConfig,omitempty"`

        // NetworkDetails defines the configuration options for the network
        NetworkDetails NetworkDetails `json:"networkDetails,omitempty"`

        // VnicAttachments defines the configuration options for the vnic(s) attached to the machine
        // The network bandwidth and number of VNICs scale proportionately with the number of OCPUs.
        VnicAttachments []VnicAttachment `json:"vnicAttachments,omitempty"`

        // LaunchOptions defines the options for tuning the compatibility and performance of VM shapes
        LaunchOptions *LaunchOptions `json:"launchOptions,omitempty"`

        // InstanceOptions defines the instance options
        InstanceOptions *InstanceOptions `json:"instanceOptions,omitempty"`

        // LaunchInstanceAvailabilityConfig defines the options for VM migration during infrastructure maintenance events and for defining
        // the availability of a VM instance after a maintenance event that impacts the underlying hardware.
        AvailabilityConfig *LaunchInstanceAvailabilityConfig `json:"availabilityConfig,omitempty"`

        // PreemptibleInstanceConfig Configuration options for preemptible instances.
        PreemptibleInstanceConfig *PreemptibleInstanceConfig `json:"preemptibleInstanceConfig,omitempty"`

        // AgentConfig defines the options for the Oracle Cloud Agent software running on the instance.
        AgentConfig *LaunchInstanceAgentConfig `json:"agentConfig,omitempty"`

        // InstanceSourceViaImageConfig defines the options for booting up instances via images
        InstanceSourceViaImageDetails *InstanceSourceViaImageConfig `json:"instanceSourceViaImageConfig,omitempty"`

        // PlatformConfig defines the platform config parameters
        PlatformConfig *PlatformConfig `json:"platformConfig,omitempty"`

        // DedicatedVmHostId defines the OCID of the dedicated VM host.
        DedicatedVmHostId *string `json:"dedicatedVmHostId,omitempty"`

        // Volume attachments to create as part of the launch instance operation.
        LaunchVolumeAttachment []LaunchVolumeAttachment `json:"launchVolumeAttachments,omitempty"`

        // Provider ID of the instance, this will be set by Cluster API provider itself,
        // users should not set this parameter.
        // +optional
        ProviderID *string `json:"providerID,omitempty"`

        // Is in transit encryption of volumes required.
        // +optional
        IsPvEncryptionInTransitEnabled bool `json:"isPvEncryptionInTransitEnabled,omitempty"`

        // The size of boot volume. Please see https://docs.oracle.com/en-us/iaas/Content/Block/Tasks/extendingbootpartition.htm
        // to extend the boot volume size.
        BootVolumeSizeInGBs string `json:"bootVolumeSizeInGBs,omitempty"`

        // Custom metadata key/value pairs that you provide, such as the SSH public key
        // required to connect to the instance.
        Metadata map[string]string `json:"metadata,omitempty"`

        // Free-form tags for this resource.
        // +optional
        FreeformTags map[string]string `json:"freeformTags,omitempty"`

        // Defined tags for this resource. Each key is predefined and scoped to a
        // namespace. For more information, see Resource Tags (https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        // Example: `{"Operations": {"CostCenter": "42"}}`
        // +optional
        DefinedTags map[string]map[string]string `json:"definedTags,omitempty"`

        // The name of the subnet to use. The name here refers to the subnets
        // defined in the OCICluster Spec. Optional, only if multiple subnets of a type
        // is defined, else the first element is used.
        // +optional
        SubnetName string `json:"subnetName,omitempty"`

        // The name of NSG to use. The name here refers to the NSGs
        // defined in the OCICluster Spec. Optional, only if multiple NSGs of a type
        // is defined, else the first element is used.
        // +optional
        // Deprecated, please use NetworkDetails.NSGNames
        NSGName string `json:"nsgName,omitempty"`

        // Specifies whether to delete or preserve the boot volume when terminating an instance.
        // When set to true, the boot volume is preserved. The default value is false.
        PreserveBootVolume bool `json:"preserveBootVolume,omitempty"`

        // Specifies whether to delete or preserve the data volumes created during launch when
        //terminating an instance. When set to true, the data volumes are preserved. The default value is true.
        PreserveDataVolumesCreatedAtLaunch bool `json:"preserveDataVolumesCreatedAtLaunch,omitempty"`
}

// OCIMachineStatus defines the observed state of OCIMachine.
type OCIMachineStatus struct {
        // INSERT ADDITIONAL STATUS FIELD - define observed state of machine

        // Flag set to true when machine is ready.
        // +optional
        Ready bool `json:"ready,omitempty"`

        // Addresses contains the addresses of the associated OCI instance.
        Addresses []clusterv1.MachineAddress `json:"addresses,omitempty"`

        // Error status on the machine.
        // +optional
        FailureReason *string `json:"failureReason,omitempty"`

        // The error message corresponding to the error on the machine.
        // +optional
        FailureMessage *string `json:"failureMessage,omitempty"`

        // Launch instance work request ID.
        // +optional
        LaunchInstanceWorkRequestId string `json:"launchInstanceWorkRequestId,omitempty"`

        // Create Backend OPC work request ID for the machine backend.
        // +optional
        CreateBackendWorkRequestId string `json:"createBackendWorkRequestId,omitempty"`

        // Delete Backend OPC work request ID for the machine backend.
        // +optional
        DeleteBackendWorkRequestId string `json:"deleteBackendWorkRequestId,omitempty"`

        // Conditions defines current service state of the OCIMachine.
        // +optional
        Conditions clusterv1.Conditions `json:"conditions,omitempty"`
}

//+kubebuilder:object:root=true
//+kubebuilder:subresource:status

// OCIMachine is the Schema for the ocimachines API.
type OCIMachine struct {
        metav1.TypeMeta   `json:",inline"`
        metav1.ObjectMeta `json:"metadata,omitempty"`

        Spec   OCIMachineSpec   `json:"spec,omitempty"`
        Status OCIMachineStatus `json:"status,omitempty"`
}

//+kubebuilder:object:root=true

// OCIMachineList contains a list of OCIMachine.
type OCIMachineList struct {
        metav1.TypeMeta `json:",inline"`
        metav1.ListMeta `json:"metadata,omitempty"`
        Items           []OCIMachine `json:"items"`
}

// GetConditions returns the list of conditions for an OCIMachine API object.
func (m *OCIMachine) GetConditions() clusterv1.Conditions <span class="cov0" title="0">{
        return m.Status.Conditions
}</span>

// SetConditions will set the given conditions on an OCIMachine object.
func (m *OCIMachine) SetConditions(conditions clusterv1.Conditions) <span class="cov0" title="0">{
        m.Status.Conditions = conditions
}</span>

func init() <span class="cov8" title="1">{
        SchemeBuilder.Register(&amp;OCIMachine{}, &amp;OCIMachineList{})
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">/*
 Copyright (c) 2021, 2022 Oracle and/or its affiliates.

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

      https://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
*/

package v1beta1

import (
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

// OCIMachineTemplateSpec defines the desired state of OCIMachineTemplate.
type OCIMachineTemplateSpec struct {
        Template OCIMachineTemplateResource `json:"template"`
}

// OCIMachineTemplateResource describes the data needed to create an OCIMachine from a template.
type OCIMachineTemplateResource struct {
        // Spec is the specification of the desired behavior of the machine.
        Spec OCIMachineSpec `json:"spec"`
}

// +kubebuilder:object:root=true
// +kubebuilder:resource:path=ocimachinetemplates,scope=Namespaced,categories=cluster-api

// OCIMachineTemplate is the schema for the OCI compute instance machine template.
type OCIMachineTemplate struct {
        metav1.TypeMeta   `json:",inline"`
        metav1.ObjectMeta `json:"metadata,omitempty"`

        Spec OCIMachineTemplateSpec `json:"spec,omitempty"`
}

// +kubebuilder:object:root=true

// OCIMachineTemplateList contains a list of OCIMachineTemplate.
type OCIMachineTemplateList struct {
        metav1.TypeMeta `json:",inline"`
        metav1.ListMeta `json:"metadata,omitempty"`
        Items           []OCIMachineTemplate `json:"items"`
}

func init() <span class="cov8" title="1">{
        SchemeBuilder.Register(&amp;OCIMachineTemplate{}, &amp;OCIMachineTemplateList{})
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">/*
Copyright (c) 2021, 2022 Oracle and/or its affiliates.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1beta1

import (
        "github.com/oracle/cluster-api-provider-oci/api/v1beta2"
        utilconversion "sigs.k8s.io/cluster-api/util/conversion"
        "sigs.k8s.io/controller-runtime/pkg/conversion"
)

// ConvertTo converts the v1beta1 OCIManagedCluster receiver to a v1beta2 OCIManagedCluster.
func (src *OCIManagedCluster) ConvertTo(dstRaw conversion.Hub) error <span class="cov8" title="1">{
        dst := dstRaw.(*v1beta2.OCIManagedCluster)

        if err := Convert_v1beta1_OCIManagedCluster_To_v1beta2_OCIManagedCluster(src, dst, nil); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">ad, err := Convertv1beta1AdMapTov1beta2AdMap(src.Status.AvailabilityDomains)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">dst.Spec.AvailabilityDomains = ad

        // Manually restore data.
        restored := &amp;v1beta2.OCIManagedCluster{}
        if ok, err := utilconversion.UnmarshalData(src, restored); err != nil || !ok </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">dst.Spec.NetworkSpec.Vcn.NetworkSecurityGroup.Skip = restored.Spec.NetworkSpec.Vcn.NetworkSecurityGroup.Skip
        dst.Spec.NetworkSpec.Vcn.NATGateway.Skip = restored.Spec.NetworkSpec.Vcn.NATGateway.Skip
        dst.Spec.NetworkSpec.Vcn.ServiceGateway.Skip = restored.Spec.NetworkSpec.Vcn.ServiceGateway.Skip
        dst.Spec.NetworkSpec.Vcn.InternetGateway.Skip = restored.Spec.NetworkSpec.Vcn.InternetGateway.Skip
        dst.Spec.NetworkSpec.Vcn.RouteTable.Skip = restored.Spec.NetworkSpec.Vcn.RouteTable.Skip
        dst.Spec.NetworkSpec.APIServerLB.LoadBalancerType = restored.Spec.NetworkSpec.APIServerLB.LoadBalancerType
        dst.Spec.ClientOverrides = restored.Spec.ClientOverrides
        return nil</span>
}

// ConvertFrom converts receiver to a v1beta2 OCICluster.
func (r *OCIManagedCluster) ConvertFrom(srcRaw conversion.Hub) error <span class="cov8" title="1">{
        src := srcRaw.(*v1beta2.OCIManagedCluster)

        if err := Convert_v1beta2_OCIManagedCluster_To_v1beta1_OCIManagedCluster(src, r, nil); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">ad, err := Convertv1beta2AdMapTov1beta1AdMap(src.Spec.AvailabilityDomains)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">r.Status.AvailabilityDomains = ad

        // Preserve Hub data on down-conversion.
        if err := utilconversion.MarshalData(src, r); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">/*
Copyright (c) 2021, 2022 Oracle and/or its affiliates.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1beta1

import (
        corev1 "k8s.io/api/core/v1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        clusterv1 "sigs.k8s.io/cluster-api/api/core/v1beta1"
)

const (
        // ManagedClusterFinalizer allows OCIManagedClusterReconciler to clean up OCI resources associated with OCIManagedCluster.
        ManagedClusterFinalizer = "ocimanagedcluster.infrastructure.cluster.x-k8s.io"
)

// OCIManagedClusterSpec defines the desired state of OCI OKE Cluster
type OCIManagedClusterSpec struct {

        // The unique ID which will be used to tag all the resources created by this Cluster.
        // The tag will be used to identify resources belonging to this cluster.
        // this will be auto-generated and should not be set by the user.
        // +optional
        OCIResourceIdentifier string `json:"ociResourceIdentifier,omitempty"`

        // IdentityRef is a reference to an identity(principal) to be used when reconciling this cluster
        // +optional
        IdentityRef *corev1.ObjectReference `json:"identityRef,omitempty"`

        // NetworkSpec encapsulates all things related to OCI network.
        // +optional
        NetworkSpec NetworkSpec `json:"networkSpec,omitempty"`

        // Free-form tags for this resource.
        // +optional
        FreeformTags map[string]string `json:"freeformTags,omitempty"`

        // Defined tags for this resource. Each key is predefined and scoped to a
        // namespace. For more information, see Resource Tags (https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        // Example: `{"Operations": {"CostCenter": "42"}}`
        // +optional
        DefinedTags map[string]map[string]string `json:"definedTags,omitempty"`

        // Compartment to create the cluster network.
        // +optional
        CompartmentId string `json:"compartmentId"`

        // Region the cluster operates in. It must be one of available regions in Region Identifier format.
        // See https://docs.oracle.com/en-us/iaas/Content/General/Concepts/regions.htm
        Region string `json:"region,omitempty"`

        // ControlPlaneEndpoint represents the endpoint used to communicate with the control plane. This will not be set by the user, this will be updated by the Cluster Reconciler after OKe cluster has been created and the cluster has an endpoint address
        // +optional
        ControlPlaneEndpoint clusterv1.APIEndpoint `json:"controlPlaneEndpoint"`
}

// OCIManagedClusterStatus defines the observed state of OCICluster
type OCIManagedClusterStatus struct {
        // +optional
        FailureDomains clusterv1.FailureDomains `json:"failureDomains,omitempty"`

        // AvailabilityDomains encapsulates the clusters Availability Domain (AD) information in a map
        // where the map key is the AD name and the struct is details about the AD.
        // +optional
        AvailabilityDomains map[string]OCIAvailabilityDomain `json:"availabilityDomains,omitempty"`

        // +optional
        Ready bool `json:"ready"`
        // NetworkSpec encapsulates all things related to OCI network.
        // +optional
        Conditions clusterv1.Conditions `json:"conditions,omitempty"`
}

//+kubebuilder:object:root=true
//+kubebuilder:subresource:status

// OCIManagedCluster is the Schema for the ocimanagedclusters API.
type OCIManagedCluster struct {
        metav1.TypeMeta   `json:",inline"`
        metav1.ObjectMeta `json:"metadata,omitempty"`

        Spec   OCIManagedClusterSpec   `json:"spec,omitempty"`
        Status OCIManagedClusterStatus `json:"status,omitempty"`
}

//+kubebuilder:object:root=true

// OCIManagedClusterList contains a list of OCIManagedCluster.
type OCIManagedClusterList struct {
        metav1.TypeMeta `json:",inline"`
        metav1.ListMeta `json:"metadata,omitempty"`
        Items           []OCIManagedCluster `json:"items"`
}

// GetConditions returns the list of conditions for an OCICluster API object.
func (c *OCIManagedCluster) GetConditions() clusterv1.Conditions <span class="cov0" title="0">{
        return c.Status.Conditions
}</span>

// SetConditions will set the given conditions on an OCICluster object.
func (c *OCIManagedCluster) SetConditions(conditions clusterv1.Conditions) <span class="cov0" title="0">{
        c.Status.Conditions = conditions
}</span>

func init() <span class="cov8" title="1">{
        SchemeBuilder.Register(&amp;OCIManagedCluster{}, &amp;OCIManagedClusterList{})
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">/*
Copyright (c) 2022, Oracle and/or its affiliates.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1beta1

import (
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

// OCIManagedClusterTemplateSpec defines the desired state of OCIManagedClusterTemplate.
type OCIManagedClusterTemplateSpec struct {
        Template OCIManagedClusterTemplateResource `json:"template"`
}

// +kubebuilder:object:root=true
// +kubebuilder:resource:path=ocimanagedclustertemplates,scope=Namespaced,categories=cluster-api

// OCIManagedClusterTemplate is the Schema for the ocimanagedclustertemplates API.
type OCIManagedClusterTemplate struct {
        metav1.TypeMeta   `json:",inline"`
        metav1.ObjectMeta `json:"metadata,omitempty"`

        Spec OCIManagedClusterTemplateSpec `json:"spec,omitempty"`
}

// +kubebuilder:object:root=true

// OCIManagedClusterTemplateList contains a list of OCIManagedClusterTemplate.
type OCIManagedClusterTemplateList struct {
        metav1.TypeMeta `json:",inline"`
        metav1.ListMeta `json:"metadata,omitempty"`

        Items []OCIManagedClusterTemplate `json:"items"`
}

func init() <span class="cov8" title="1">{
        SchemeBuilder.Register(&amp;OCIManagedClusterTemplate{}, &amp;OCIManagedClusterTemplateList{})
}</span>

// OCIManagedClusterSpec describes the data needed to create an OCIManagedCluster from a template.
type OCIManagedClusterTemplateResource struct {
        Spec OCIManagedClusterSpec `json:"spec"`
}
</pre>
		
		<pre class="file" id="file13" style="display: none">/*
Copyright (c) 2021, 2022 Oracle and/or its affiliates.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1beta1

import (
        "github.com/oracle/cluster-api-provider-oci/api/v1beta2"
        utilconversion "sigs.k8s.io/cluster-api/util/conversion"
        "sigs.k8s.io/controller-runtime/pkg/conversion"
)

// ConvertTo converts the v1beta1 OCIManagedCluster receiver to a v1beta2 OCIManagedCluster.
func (src *OCIManagedControlPlane) ConvertTo(dstRaw conversion.Hub) error <span class="cov8" title="1">{
        dst := dstRaw.(*v1beta2.OCIManagedControlPlane)
        if err := Convert_v1beta1_OCIManagedControlPlane_To_v1beta2_OCIManagedControlPlane(src, dst, nil); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">restored := &amp;v1beta2.OCIManagedControlPlane{}
        if ok, err := utilconversion.UnmarshalData(src, restored); err != nil || !ok </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">dst.Spec.ClusterType = restored.Spec.ClusterType
        dst.Spec.Addons = restored.Spec.Addons
        dst.Status.AddonStatus = restored.Status.AddonStatus

        // Handle ClusterOption conversion
        // Copy OpenIdConnectDiscovery if present
        if restored.Spec.ClusterOption.OpenIdConnectDiscovery != nil </span><span class="cov8" title="1">{
                if dst.Spec.ClusterOption.OpenIdConnectDiscovery == nil </span><span class="cov8" title="1">{
                        dst.Spec.ClusterOption.OpenIdConnectDiscovery = &amp;v1beta2.OpenIDConnectDiscovery{}
                }</span>
                <span class="cov8" title="1">dst.Spec.ClusterOption.OpenIdConnectDiscovery.IsOpenIdConnectDiscoveryEnabled =
                        restored.Spec.ClusterOption.OpenIdConnectDiscovery.IsOpenIdConnectDiscoveryEnabled</span>
        }

        // Copy OpenIdConnectTokenAuthenticationConfig if present
        <span class="cov8" title="1">if restored.Spec.ClusterOption.OpenIdConnectTokenAuthenticationConfig != nil </span><span class="cov8" title="1">{
                if dst.Spec.ClusterOption.OpenIdConnectTokenAuthenticationConfig == nil </span><span class="cov8" title="1">{
                        dst.Spec.ClusterOption.OpenIdConnectTokenAuthenticationConfig = &amp;v1beta2.OpenIDConnectTokenAuthenticationConfig{}
                }</span>
                <span class="cov8" title="1">*dst.Spec.ClusterOption.OpenIdConnectTokenAuthenticationConfig =
                        *restored.Spec.ClusterOption.OpenIdConnectTokenAuthenticationConfig</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// ConvertFrom converts receiver to a v1beta2 OCIManagedControlPlane.
func (r *OCIManagedControlPlane) ConvertFrom(srcRaw conversion.Hub) error <span class="cov8" title="1">{
        src := srcRaw.(*v1beta2.OCIManagedControlPlane)

        if err := Convert_v1beta2_OCIManagedControlPlane_To_v1beta1_OCIManagedControlPlane(src, r, nil); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Preserve Hub data on down-conversion.
        <span class="cov8" title="1">if err := utilconversion.MarshalData(src, r); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">/*
Copyright (c) 2021, 2022 Oracle and/or its affiliates.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1beta1

import (
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        clusterv1 "sigs.k8s.io/cluster-api/api/core/v1beta1"
)

const (
        // ControlPlaneFinalizer allows OCIManagedControlPlaneFinalizer to clean up OCI resources associated with control plane
        // of OCIManagedControlPlane
        ControlPlaneFinalizer = "ocimanagedcontrolplane.infrastructure.cluster.x-k8s.io"
)

// OCIManagedControlPlaneSpec defines the desired state of OCIManagedControlPlane.
// The properties are generated from https://docs.oracle.com/en-us/iaas/api/#/en/containerengine/20180222/datatypes/CreateClusterDetails
type OCIManagedControlPlaneSpec struct {
        // ID of the OKEcluster.
        // +optional
        ID *string `json:"id,omitempty"`

        // ClusterPodNetworkOptions defines the available CNIs and network options for existing and new node pools of the cluster
        // +optional
        ClusterPodNetworkOptions []ClusterPodNetworkOptions `json:"clusterPodNetworkOptions,omitempty"`

        // ImagePolicyConfig defines the properties that define a image verification policy.
        // +optional
        ImagePolicyConfig *ImagePolicyConfig `json:"imagePolicyConfig,omitempty"`

        // ClusterOptions defines Optional attributes for the cluster.
        // +optional
        ClusterOption ClusterOptions `json:"clusterOptions,omitempty"`

        // KmsKeyId defines the OCID of the KMS key to be used as the master encryption key for Kubernetes secret encryption. When used,
        // +optional
        KmsKeyId *string `json:"kmsKeyId,omitempty"`

        // ControlPlaneEndpoint represents the endpoint used to communicate with the control plane.
        // +optional
        ControlPlaneEndpoint clusterv1.APIEndpoint `json:"controlPlaneEndpoint"`

        // Version represents the version of the Kubernetes Cluster Control Plane.
        Version *string `json:"version,omitempty"`
}

// ClusterPodNetworkOptions defines the available CNIs and network options for existing and new node pools of the cluster
type ClusterPodNetworkOptions struct {

        // The CNI to be used are OCI_VCN_IP_NATIVE and FLANNEL_OVERLAY
        CniType CNIOptionEnum `json:"cniType,omitempty"`
}

// EndpointConfig defines the network configuration for access to the Cluster control plane.
type EndpointConfig struct {
        // Flag to enable public endpoint address for the OKE cluster.
        // If not set, will calculate this using endpoint subnet type.
        // +optional
        IsPublicIpEnabled bool `json:"isPublicIpEnabled,omitempty"`
}

// ImagePolicyConfig defines the properties that define a image verification policy.
type ImagePolicyConfig struct {

        // IsPolicyEnabled defines Whether the image verification policy is enabled.
        // +optional
        IsPolicyEnabled *bool `json:"isPolicyEnabled,omitempty"`

        // KeyDetails defines a list of KMS key details.
        // +optional
        KeyDetails []KeyDetails `json:"keyDetails,omitempty"`
}

// KeyDetails defines the properties that define the kms keys used by OKE for Image Signature verification.
type KeyDetails struct {

        // KmsKeyId defines the OCID of the KMS key that will be used to verify whether the images are signed by an approved source.
        // +optional
        KmsKeyId *string `json:"keyDetails,omitempty"`
}

// ClusterOptions defines Optional attributes for the cluster.
type ClusterOptions struct {

        // AddOnOptions defines the properties that define options for supported add-ons.
        // +optional
        AddOnOptions *AddOnOptions `json:"addOnOptions,omitempty"`

        // AdmissionControllerOptions defines the properties that define supported admission controllers.
        // +optional
        AdmissionControllerOptions *AdmissionControllerOptions `json:"admissionControllerOptions,omitempty"`
}

// AddOnOptions defines the properties that define options for supported add-ons.
type AddOnOptions struct {
        // IsKubernetesDashboardEnabled defines whether or not to enable the Kubernetes Dashboard add-on.
        // +optional
        IsKubernetesDashboardEnabled *bool `json:"isKubernetesDashboardEnabled,omitempty"`

        // IsKubernetesDashboardEnabled defines whether or not to enable the Tiller add-on.
        // +optional
        IsTillerEnabled *bool `json:"isTillerEnabled,omitempty"`
}

// AdmissionControllerOptions defines the properties that define supported admission controllers.
type AdmissionControllerOptions struct {

        // IsPodSecurityPolicyEnabled defines whether or not to enable the Pod Security Policy admission controller.
        // +optional
        IsPodSecurityPolicyEnabled *bool `json:"isPodSecurityPolicyEnabled,omitempty"`
}

// KubernetesNetworkConfig defines the properties that define the network configuration for Kubernetes.
type KubernetesNetworkConfig struct {

        // PodsCidr defines the CIDR block for Kubernetes pods. Optional, defaults to 10.244.0.0/16.
        // +optional
        PodsCidr string `json:"isPodSecurityPolicyEnabled,omitempty"`

        // PodsCidr defines the CIDR block for Kubernetes services. Optional, defaults to 10.96.0.0/16.
        // +optional
        ServicesCidr string `json:"servicesCidr,omitempty"`
}

// OCIManagedControlPlaneStatus defines the observed state of OCIManagedControlPlane
type OCIManagedControlPlaneStatus struct {
        // +optional
        Ready bool `json:"ready"`
        // NetworkSpec encapsulates all things related to OCI network.
        // +optional
        Conditions clusterv1.Conditions `json:"conditions,omitempty"`

        // Version represents the current Kubernetes version for the control plane.
        // +optional
        Version *string `json:"version,omitempty"`

        // Initialized denotes whether or not the control plane has the
        // uploaded kubernetes config-map.
        // +optional
        Initialized bool `json:"initialized"`
}

//+kubebuilder:object:root=true
//+kubebuilder:subresource:status

// OCIManagedControlPlane is the Schema for the ocimanagedcontrolplane API.
type OCIManagedControlPlane struct {
        metav1.TypeMeta   `json:",inline"`
        metav1.ObjectMeta `json:"metadata,omitempty"`

        Spec   OCIManagedControlPlaneSpec   `json:"spec,omitempty"`
        Status OCIManagedControlPlaneStatus `json:"status,omitempty"`
}

//+kubebuilder:object:root=true

// OCIManagedControlPlaneList contains a list of OCIManagedControlPlane.
type OCIManagedControlPlaneList struct {
        metav1.TypeMeta `json:",inline"`
        metav1.ListMeta `json:"metadata,omitempty"`
        Items           []OCIManagedControlPlane `json:"items"`
}

// GetConditions returns the list of conditions for an OCICluster API object.
func (c *OCIManagedControlPlane) GetConditions() clusterv1.Conditions <span class="cov0" title="0">{
        return c.Status.Conditions
}</span>

// SetConditions will set the given conditions on an OCICluster object.
func (c *OCIManagedControlPlane) SetConditions(conditions clusterv1.Conditions) <span class="cov0" title="0">{
        c.Status.Conditions = conditions
}</span>

func init() <span class="cov8" title="1">{
        SchemeBuilder.Register(&amp;OCIManagedControlPlane{}, &amp;OCIManagedControlPlaneList{})
}</span>
</pre>
		
		<pre class="file" id="file15" style="display: none">/*
Copyright (c) 2022, Oracle and/or its affiliates.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1beta1

import (
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

// OCIManagedControlPlaneTemplateSpec defines the desired state of OCIManagedControlPlaneTemplate.
type OCIManagedControlPlaneTemplateSpec struct {
        Template OCIManagedControlPlaneTemplateResource `json:"template"`
}

// +kubebuilder:object:root=true
// +kubebuilder:resource:path=ocimanagedcontrolplanetemplates,scope=Namespaced,categories=cluster-api

// OCIManagedControlPlaneTemplate is the Schema for the OCIManagedControlPlaneTemplates API.
type OCIManagedControlPlaneTemplate struct {
        metav1.TypeMeta   `json:",inline"`
        metav1.ObjectMeta `json:"metadata,omitempty"`

        Spec OCIManagedControlPlaneTemplateSpec `json:"spec,omitempty"`
}

// +kubebuilder:object:root=true

// OCIManagedControlPlaneTemplateList contains a list of OCIManagedControlPlaneTemplate.
type OCIManagedControlPlaneTemplateList struct {
        metav1.TypeMeta `json:",inline"`
        metav1.ListMeta `json:"metadata,omitempty"`

        Items []OCIManagedControlPlaneTemplate `json:"items"`
}

func init() <span class="cov8" title="1">{
        SchemeBuilder.Register(&amp;OCIManagedControlPlaneTemplate{}, &amp;OCIManagedControlPlaneTemplateList{})
}</span>

// OCIManagedControlPlaneSpec describes the data needed to create an OCIManagedControlPlane from a template.
type OCIManagedControlPlaneTemplateResource struct {
        Spec OCIManagedControlPlaneSpec `json:"spec"`
}
</pre>
		
		<pre class="file" id="file16" style="display: none">/*
 *
 * Copyright (c) 2022, Oracle and/or its affiliates.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * /
 *
 */

package v1beta1

import (
        "fmt"
        "net"
        "regexp"

        "github.com/oracle/cluster-api-provider-oci/cloud/ociutil"
        "k8s.io/apimachinery/pkg/util/validation/field"
)

const (
        // can't use: \/"'[]:|&lt;&gt;+=;,.?*@&amp;, Can't start with underscore. Can't end with period or hyphen.
        // not using . in the name to avoid issues when the name is part of DNS name.
        clusterNameRegex = `^[a-z0-9][a-z0-9-]{0,42}[a-z0-9]$`
)

// invalidNameRegex is a broad regex used to validate allows names in OCI
var invalidNameRegex = regexp.MustCompile("\\s")

// ValidOcid is a simple pre-flight
// we will let the serverside handle the more complex and compete validation
func ValidOcid(ocid string) bool <span class="cov0" title="0">{
        if len(ocid) &gt;= 4 &amp;&amp; ocid[:4] == "ocid" </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">return false</span>
}

// validShape is a simple pre-flight
// we will let the serverside handle the more complex and compete validation.
func validShape(shape string) bool <span class="cov0" title="0">{
        return len(shape) &gt; 0
}</span>

// ValidRegion test if the string can be a region.
func ValidRegion(stringRegion string) bool <span class="cov0" title="0">{

        // region can be blank since the regional information
        // can be derived from other sources
        if stringRegion == "" </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">if invalidNameRegex.MatchString(stringRegion) </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return true</span>
}

// ValidateNetworkSpec validates the NetworkSpec
func ValidateNetworkSpec(validRoles []Role, networkSpec NetworkSpec, old NetworkSpec, fldPath *field.Path) field.ErrorList <span class="cov0" title="0">{
        var allErrs field.ErrorList

        if len(networkSpec.Vcn.CIDR) &gt; 0 </span><span class="cov0" title="0">{
                allErrs = append(allErrs, validateVCNCIDR(networkSpec.Vcn.CIDR, fldPath.Child("cidr"))...)
        }</span>

        <span class="cov0" title="0">if networkSpec.Vcn.Subnets != nil </span><span class="cov0" title="0">{
                allErrs = append(allErrs, validateSubnets(validRoles, networkSpec.Vcn.Subnets, networkSpec.Vcn, fldPath.Child("subnets"))...)
        }</span>

        <span class="cov0" title="0">if networkSpec.Vcn.NetworkSecurityGroups != nil </span><span class="cov0" title="0">{
                allErrs = append(allErrs, validateNSGs(validRoles, networkSpec.Vcn.NetworkSecurityGroups, fldPath.Child("networkSecurityGroups"))...)
        }</span>

        <span class="cov0" title="0">if len(allErrs) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return allErrs</span>
}

// validateVCNCIDR validates the CIDR of a VNC.
func validateVCNCIDR(vncCIDR string, fldPath *field.Path) field.ErrorList <span class="cov0" title="0">{
        var allErrs field.ErrorList
        if _, _, err := net.ParseCIDR(vncCIDR); err != nil </span><span class="cov0" title="0">{
                allErrs = append(allErrs, field.Invalid(fldPath, vncCIDR, "invalid CIDR format"))
        }</span>
        <span class="cov0" title="0">return allErrs</span>
}

// ValidateClusterName validates the name of the cluster.
func ValidateClusterName(name string) field.ErrorList <span class="cov0" title="0">{
        var allErrs field.ErrorList

        if success, _ := regexp.MatchString(clusterNameRegex, name); !success </span><span class="cov0" title="0">{
                allErrs = append(allErrs, field.Invalid(field.NewPath("metadata").Child("Name"), name,
                        fmt.Sprintf("Cluster Name doesn't match regex %s, can contain only lowercase alphanumeric characters and '-', must start/end with an alphanumeric character",
                                clusterNameRegex)))
        }</span>
        <span class="cov0" title="0">if len(allErrs) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return allErrs</span>
}

// validateSubnetCIDR validates the CIDR blocks of a Subnet.
func validateSubnetCIDR(subnetCidr string, vcnCidr string, fldPath *field.Path) field.ErrorList <span class="cov0" title="0">{
        var allErrs field.ErrorList

        if len(subnetCidr) &gt; 0 </span><span class="cov0" title="0">{
                subnetCidrIP, _, err := net.ParseCIDR(subnetCidr)
                if err != nil </span><span class="cov0" title="0">{
                        allErrs = append(allErrs, field.Invalid(fldPath, subnetCidr, "invalid CIDR format"))
                }</span>

                // Check subnet is in vcnCidr if vcnCidr is set
                <span class="cov0" title="0">if len(vcnCidr) &gt; 0 </span><span class="cov0" title="0">{
                        var vcnNetwork *net.IPNet
                        if _, parseNetwork, err := net.ParseCIDR(vcnCidr); err == nil </span><span class="cov0" title="0">{
                                vcnNetwork = parseNetwork
                        }</span>

                        <span class="cov0" title="0">var found bool
                        if vcnNetwork != nil &amp;&amp; vcnNetwork.Contains(subnetCidrIP) </span><span class="cov0" title="0">{
                                found = true
                        }</span>

                        <span class="cov0" title="0">if !found </span><span class="cov0" title="0">{
                                allErrs = append(allErrs, field.Invalid(fldPath, subnetCidr, fmt.Sprintf("subnet CIDR not in VCN address space: %s", vcnCidr)))
                        }</span>
                }

        }
        <span class="cov0" title="0">return allErrs</span>
}

// validateNSGs validates a list of Subnets.
func validateNSGs(validRoles []Role, networkSecurityGroups []*NSG, fldPath *field.Path) field.ErrorList <span class="cov0" title="0">{
        var allErrs field.ErrorList

        for i, nsg := range networkSecurityGroups </span><span class="cov0" title="0">{
                if err := validateRole(validRoles, nsg.Role, fldPath.Index(i).Child("role"), "networkSecurityGroup role invalid"); err != nil </span><span class="cov0" title="0">{
                        allErrs = append(allErrs, err)
                }</span>
                <span class="cov0" title="0">allErrs = append(allErrs, validateEgressSecurityRuleForNSG(nsg.EgressRules, fldPath.Index(i).Child("egressRules"))...)
                allErrs = append(allErrs, validateIngressSecurityRuleForNSG(nsg.IngressRules, fldPath.Index(i).Child("ingressRules"))...)</span>
        }

        <span class="cov0" title="0">return allErrs</span>
}

// validateEgressSecurityRuleForNSG validates the Egress Security Rule of a Subnet.
func validateEgressSecurityRuleForNSG(egressRules []EgressSecurityRuleForNSG, fldPath *field.Path) field.ErrorList <span class="cov0" title="0">{
        var allErrs field.ErrorList

        for _, r := range egressRules </span><span class="cov0" title="0">{
                rule := r.EgressSecurityRule

                if rule.DestinationType == EgressSecurityRuleDestinationTypeCidrBlock &amp;&amp; rule.Destination != nil </span><span class="cov0" title="0">{
                        if _, _, err := net.ParseCIDR(ociutil.DerefString(rule.Destination)); err != nil </span><span class="cov0" title="0">{
                                allErrs = append(allErrs, field.Invalid(fldPath, rule.Destination, "invalid egressRules CIDR format"))
                        }</span>
                }
        }

        <span class="cov0" title="0">return allErrs</span>
}

// validateEgressSecurityRuleForNSG validates the Egress Security Rule of a Subnet.
func validateIngressSecurityRuleForNSG(egressRules []IngressSecurityRuleForNSG, fldPath *field.Path) field.ErrorList <span class="cov0" title="0">{
        var allErrs field.ErrorList

        for _, r := range egressRules </span><span class="cov0" title="0">{
                rule := r.IngressSecurityRule

                if rule.SourceType == IngressSecurityRuleSourceTypeCidrBlock &amp;&amp; rule.Source != nil </span><span class="cov0" title="0">{
                        if _, _, err := net.ParseCIDR(ociutil.DerefString(rule.Source)); err != nil </span><span class="cov0" title="0">{
                                allErrs = append(allErrs, field.Invalid(fldPath, rule.Source, "invalid ingressRule CIDR format"))
                        }</span>
                }
        }

        <span class="cov0" title="0">return allErrs</span>
}

// validateSubnets validates a list of Subnets.
func validateSubnets(validRoles []Role, subnets []*Subnet, vcn VCN, fldPath *field.Path) field.ErrorList <span class="cov0" title="0">{
        var allErrs field.ErrorList
        subnetNames := make(map[string]bool, len(subnets))

        for i, subnet := range subnets </span><span class="cov0" title="0">{
                if err := validateSubnetName(subnet.Name, fldPath.Index(i).Child("name")); err != nil </span><span class="cov0" title="0">{
                        allErrs = append(allErrs, err)
                }</span>
                <span class="cov0" title="0">if len(subnet.Name) &gt; 0 </span><span class="cov0" title="0">{
                        if _, ok := subnetNames[subnet.Name]; ok </span><span class="cov0" title="0">{
                                allErrs = append(allErrs, field.Duplicate(fldPath, subnet.Name))
                        }</span>
                        <span class="cov0" title="0">subnetNames[subnet.Name] = true</span>
                }

                <span class="cov0" title="0">if err := validateRole(validRoles, subnet.Role, fldPath.Index(i).Child("role"), "subnet role invalid"); err != nil </span><span class="cov0" title="0">{
                        allErrs = append(allErrs, err)
                }</span>

                <span class="cov0" title="0">allErrs = append(allErrs, validateSubnetCIDR(subnet.CIDR, vcn.CIDR, fldPath.Index(i).Child("cidr"))...)</span>
        }

        <span class="cov0" title="0">return allErrs</span>
}

// validateSubnetName validates the Name of a Subnet.
func validateSubnetName(name string, fldPath *field.Path) *field.Error <span class="cov0" title="0">{
        // subnet name can be empty
        if len(name) &gt; 0 </span><span class="cov0" title="0">{
                if invalidNameRegex.Match([]byte(name)) || name == "" </span><span class="cov0" title="0">{
                        return field.Invalid(fldPath, name,
                                fmt.Sprintf("subnet name invalid"))
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// validateRole validates that the subnet role is one of the allowed types
func validateRole(validRoles []Role, subnetRole Role, fldPath *field.Path, errorMsg string) *field.Error <span class="cov0" title="0">{
        for _, role := range validRoles </span><span class="cov0" title="0">{
                if subnetRole == role </span><span class="cov0" title="0">{
                        return nil
                }</span>
        }
        <span class="cov0" title="0">return field.Invalid(fldPath, subnetRole,
                fmt.Sprintf("%s", errorMsg))</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">/*
 Copyright (c) 2021, 2022 Oracle and/or its affiliates.

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

      https://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
*/

package v1beta2

// Hub marks OCICluster as a conversion hub.
func (*OCICluster) Hub() {<span class="cov0" title="0">}</span>

// Hub marks OCIClusterList as a conversion hub.
func (*OCIClusterList) Hub() {<span class="cov0" title="0">}</span>

// Hub marks OCIClusterTemplate as a conversion hub.
func (*OCIClusterTemplate) Hub() {<span class="cov0" title="0">}</span>

// Hub marks OCIClusterTemplateList as a conversion hub.
func (*OCIClusterTemplateList) Hub() {<span class="cov0" title="0">}</span>

// Hub marks OCICluster as a conversion hub.
func (*OCIMachine) Hub() {<span class="cov0" title="0">}</span>

// Hub marks OCIMachineList as a conversion hub.
func (*OCIMachineList) Hub() {<span class="cov0" title="0">}</span>

// Hub marks OCIMachineTemplate as a conversion hub.
func (*OCIMachineTemplate) Hub() {<span class="cov0" title="0">}</span>

// Hub marks OCIMachineTemplateList as a conversion hub.
func (*OCIMachineTemplateList) Hub() {<span class="cov0" title="0">}</span>

// Hub marks OCIClusterIdentity as a conversion hub.
func (*OCIClusterIdentity) Hub() {<span class="cov0" title="0">}</span>

// Hub marks OCIClusterIdentityList as a conversion hub.
func (*OCIClusterIdentityList) Hub() {<span class="cov0" title="0">}</span>

// Hub marks OCIManagedControlPlane as a conversion hub.
func (*OCIManagedControlPlane) Hub() {<span class="cov0" title="0">}</span>

// Hub marks OCIManagedCluster as a conversion hub.
func (*OCIManagedCluster) Hub() {<span class="cov0" title="0">}</span>

// Hub marks OCIManagedClusterTemplate as a conversion hub.
func (*OCIManagedClusterTemplate) Hub() {<span class="cov0" title="0">}</span>

// Hub marks OCIManagedClusterTemplateList as a conversion hub.
func (*OCIManagedClusterTemplateList) Hub() {<span class="cov0" title="0">}</span>

// Hub marks OCIManagedControlPlaneList as a conversion hub.
func (*OCIManagedControlPlaneList) Hub() {<span class="cov0" title="0">}</span>
</pre>
		
		<pre class="file" id="file18" style="display: none">/*
Copyright (c) 2021, 2022 Oracle and/or its affiliates.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1beta2

import (
        corev1 "k8s.io/api/core/v1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        clusterv1 "sigs.k8s.io/cluster-api/api/core/v1beta1"
)

// NOTE: json tags are required.  Any new fields you add must have json tags for the fields to be serialized.
// Important: Run "make" to regenerate code after modifying this file

const (
        // ClusterFinalizer allows OCIClusterReconciler to clean up OCI resources associated with OCICluster before
        // removing it from the apiserver.
        ClusterFinalizer = "ocicluster.infrastructure.cluster.x-k8s.io"
)

// OCIClusterSpec defines the desired state of OciCluster
type OCIClusterSpec struct {

        // The unique ID which will be used to tag all the resources created by this Cluster.
        // The tag will be used to identify resources belonging to this cluster.
        // this will be auto-generated and should not be set by the user.
        // +optional
        OCIResourceIdentifier string `json:"ociResourceIdentifier,omitempty"`

        // IdentityRef is a reference to an identity(principal) to be used when reconciling this cluster
        // +optional
        IdentityRef *corev1.ObjectReference `json:"identityRef,omitempty"`

        // NetworkSpec encapsulates all things related to OCI network.
        // +optional
        NetworkSpec NetworkSpec `json:"networkSpec,omitempty"`

        // Free-form tags for this resource.
        // +optional
        FreeformTags map[string]string `json:"freeformTags,omitempty"`

        // Defined tags for this resource. Each key is predefined and scoped to a
        // namespace. For more information, see Resource Tags (https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        // Example: `{"Operations": {"CostCenter": "42"}}`
        // +optional
        DefinedTags map[string]map[string]string `json:"definedTags,omitempty"`

        // Compartment to create the cluster network.
        // +optional
        CompartmentId string `json:"compartmentId"`

        // Region the cluster operates in. It must be one of available regions in Region Identifier format.
        // See https://docs.oracle.com/en-us/iaas/Content/General/Concepts/regions.htm
        Region string `json:"region,omitempty"`

        // ControlPlaneEndpoint represents the endpoint used to communicate with the control plane.
        // +optional
        ControlPlaneEndpoint clusterv1.APIEndpoint `json:"controlPlaneEndpoint"`

        // AvailabilityDomains encapsulates the clusters Availability Domain (AD) information in a map
        // where the map key is the AD name and the struct is details about the AD.
        // +optional
        AvailabilityDomains map[string]OCIAvailabilityDomain `json:"availabilityDomains,omitempty"`

        // ClientOverrides allows the default client SDK URLs to be changed.
        //
        // +optional
        // +nullable
        ClientOverrides *ClientOverrides `json:"clientOverrides,omitempty"`
}

// OCIClusterStatus defines the observed state of OCICluster
type OCIClusterStatus struct {
        // +optional
        FailureDomains clusterv1.FailureDomains `json:"failureDomains,omitempty"`

        // +optional
        Ready bool `json:"ready"`
        // NetworkSpec encapsulates all things related to OCI network.
        // +optional
        Conditions clusterv1.Conditions `json:"conditions,omitempty"`
}

//+kubebuilder:object:root=true
//+kubebuilder:subresource:status
// +kubebuilder:storageversion

// OCICluster is the Schema for the ociclusters API.
type OCICluster struct {
        metav1.TypeMeta   `json:",inline"`
        metav1.ObjectMeta `json:"metadata,omitempty"`

        Spec   OCIClusterSpec   `json:"spec,omitempty"`
        Status OCIClusterStatus `json:"status,omitempty"`
}

//+kubebuilder:object:root=true
// +kubebuilder:storageversion

// OCIClusterList contains a list of OCICluster.
type OCIClusterList struct {
        metav1.TypeMeta `json:",inline"`
        metav1.ListMeta `json:"metadata,omitempty"`
        Items           []OCICluster `json:"items"`
}

// OCIAvailabilityDomain contains information about an Availability Domain (AD).
type OCIAvailabilityDomain struct {

        // Name is the AD's full name. Example: Uocm:PHX-AD-1
        Name string `json:"name,omitempty"`

        // FaultDomains a list of fault domain (FD) names. Example: ["FAULT-DOMAIN-1"]
        FaultDomains []string `json:"faultDomains,omitempty"`
}

// ClientOverrides contains information about client host url overrides.
type ClientOverrides struct {

        // CertOverride is a secret that contains information about a cert override used by all the OCI SDK clients.
        // The secret must contain data with a `cert`property.
        //
        // +optional
        // +nullable
        CertOverride *corev1.SecretReference `json:"certOverride,omitempty"`

        // ComputeClientUrl allows the default compute SDK client URL to be changed.
        //
        // +optional
        // +nullable
        ComputeClientUrl *string `json:"computeClientUrl,omitempty"`

        // ComputeManagementClientUrl allows the default compute management SDK client URL to be changed.
        //
        // +optional
        // +nullable
        ComputeManagementClientUrl *string `json:"computeManagementClientUrl,omitempty"`

        // VCNClientUrl allows the default vcn SDK client URL to be changed.
        //
        // +optional
        // +nullable
        VCNClientUrl *string `json:"vCNClientUrl,omitempty"`

        // LoadBalancerClientUrl allows the default load balancer SDK client URL to be changed.
        //
        // +optional
        // +nullable
        LoadBalancerClientUrl *string `json:"loadBalancerClientUrl,omitempty"`

        // NetworkLoadBalancerClientUrl allows the default NLB SDK client URL to be changed.
        //
        // +optional
        // +nullable
        NetworkLoadBalancerClientUrl *string `json:"networkLoadBalancerClientUrl,omitempty"`

        // IdentityClientUrl allows the default identity SDK client URL to be changed.
        //
        // +optional
        // +nullable
        IdentityClientUrl *string `json:"identityClientUrl,omitempty"`

        // ContainerEngineClientUrl allows the default container engine SDK client URL to be changed.
        //
        // +optional
        // +nullable
        ContainerEngineClientUrl *string `json:"containerEngineClientUrl,omitempty"`

        // WorkrequestClientUrl allows the default work request SDK client URL to be changed.
        //
        // +optional
        // +nullable
        WorkrequestClientUrl *string `json:"workrequestClientUrl,omitempty"`
}

// GetConditions returns the list of conditions for an OCICluster API object.
func (c *OCICluster) GetConditions() clusterv1.Conditions <span class="cov8" title="1">{
        return c.Status.Conditions
}</span>

// SetConditions will set the given conditions on an OCICluster object.
func (c *OCICluster) SetConditions(conditions clusterv1.Conditions) <span class="cov8" title="1">{
        c.Status.Conditions = conditions
}</span>

// GetOCIResourceIdentifier will return the OCI resource identifier.
func (c *OCICluster) GetOCIResourceIdentifier() string <span class="cov8" title="1">{
        return c.Spec.OCIResourceIdentifier
}</span>

func init() <span class="cov8" title="1">{
        SchemeBuilder.Register(&amp;OCICluster{}, &amp;OCIClusterList{})
}</span>
</pre>
		
		<pre class="file" id="file19" style="display: none">/*
 *
 * Copyright (c) 2022, Oracle and/or its affiliates.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * /
 *
 */

package v1beta2

import (
        "context"
        "fmt"

        "github.com/oracle/oci-go-sdk/v65/common"
        apierrors "k8s.io/apimachinery/pkg/api/errors"
        "k8s.io/apimachinery/pkg/runtime"
        "k8s.io/apimachinery/pkg/util/uuid"
        "k8s.io/apimachinery/pkg/util/validation/field"
        ctrl "sigs.k8s.io/controller-runtime"
        "sigs.k8s.io/controller-runtime/pkg/webhook"
        "sigs.k8s.io/controller-runtime/pkg/webhook/admission"
)

var clusterlogger = ctrl.Log.WithName("ocicluster-resource")

type OCIClusterWebhook struct{}

var (
        _ webhook.CustomDefaulter = &amp;OCIClusterWebhook{}
        _ webhook.CustomValidator = &amp;OCIClusterWebhook{}
)

// +kubebuilder:webhook:verbs=create;update,path=/validate-infrastructure-cluster-x-k8s-io-v1beta2-ocicluster,mutating=false,failurePolicy=fail,matchPolicy=Equivalent,groups=infrastructure.cluster.x-k8s.io,resources=ociclusters,versions=v1beta2,name=validation.ocicluster.infrastructure.cluster.x-k8s.io,sideEffects=None,admissionReviewVersions=v1beta1
// +kubebuilder:webhook:verbs=create;update,path=/mutate-infrastructure-cluster-x-k8s-io-v1beta2-ocicluster,mutating=true,failurePolicy=fail,matchPolicy=Equivalent,groups=infrastructure.cluster.x-k8s.io,resources=ociclusters,versions=v1beta2,name=default.ocicluster.infrastructure.cluster.x-k8s.io,sideEffects=None,admissionReviewVersions=v1beta1

func (*OCIClusterWebhook) Default(_ context.Context, obj runtime.Object) error <span class="cov8" title="1">{
        c, ok := obj.(*OCICluster)
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("expected an OCICluster object but got %T", c)
        }</span>

        <span class="cov8" title="1">if c.Spec.OCIResourceIdentifier == "" </span><span class="cov8" title="1">{
                c.Spec.OCIResourceIdentifier = string(uuid.NewUUID())
        }</span>
        <span class="cov8" title="1">if !c.Spec.NetworkSpec.SkipNetworkManagement </span><span class="cov8" title="1">{
                c.Spec.NetworkSpec.Vcn.Subnets = c.SubnetSpec()
                c.Spec.NetworkSpec.Vcn.NetworkSecurityGroup.List = c.NSGSpec()
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (c *OCICluster) SetupWebhookWithManager(mgr ctrl.Manager) error <span class="cov0" title="0">{
        w := new(OCIClusterWebhook)
        return ctrl.NewWebhookManagedBy(mgr).
                For(c).
                WithDefaulter(w).
                WithValidator(w).
                Complete()
}</span>

// ValidateCreate implements webhook.Validator so a webhook will be registered for the type.
func (*OCIClusterWebhook) ValidateCreate(_ context.Context, obj runtime.Object) (admission.Warnings, error) <span class="cov8" title="1">{
        c, ok := obj.(*OCICluster)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("expected an OCICluster object but got %T", c)
        }</span>

        <span class="cov8" title="1">clusterlogger.Info("validate update cluster", "name", c.Name)

        var allErrs field.ErrorList
        var ipv6hextets []*string
        var hextatassigned bool

        if c.GetControlPlaneEndpointSubnet() != nil &amp;&amp; c.GetControlPlaneMachineSubnet() != nil &amp;&amp; c.GetServiceLoadBalancerSubnet() != nil </span><span class="cov0" title="0">{
                ipv6hextets = append(ipv6hextets,
                        c.GetControlPlaneEndpointSubnet().Ipv6CidrBlockHextet,
                        c.GetControlPlaneMachineSubnet().Ipv6CidrBlockHextet,
                        c.GetServiceLoadBalancerSubnet().Ipv6CidrBlockHextet)

                nodeSubnets := c.GetNodeSubnet()
                if len(nodeSubnets) &gt; 0 </span><span class="cov0" title="0">{
                        ipv6hextets = append(ipv6hextets, nodeSubnets[0].Ipv6CidrBlockHextet)
                }</span>
        }

        <span class="cov8" title="1">for _, hextet := range ipv6hextets </span><span class="cov0" title="0">{
                if hextet != nil </span><span class="cov0" title="0">{
                        hextatassigned = true
                        break</span>
                }
        }

        <span class="cov8" title="1">if hextatassigned </span><span class="cov0" title="0">{
                if c.Spec.NetworkSpec.Vcn.IsIpv6Enabled == nil </span><span class="cov0" title="0">{
                        allErrs = append(allErrs, field.Invalid(field.NewPath("spec", "NetworkSpec.Vcn.IsIpv6Enabled"), c.Spec.NetworkSpec.Vcn.IsIpv6Enabled, "field needs to be true and not nil"))
                }</span>
                <span class="cov0" title="0">if c.Spec.NetworkSpec.Vcn.IsIpv6Enabled == common.Bool(false) </span><span class="cov0" title="0">{
                        allErrs = append(allErrs, field.Invalid(field.NewPath("spec", "NetworkSpec.Vcn.IsIpv6Enabled"), c.Spec.NetworkSpec.Vcn.IsIpv6Enabled, "field needs to be true"))
                }</span>
        }

        // If Skip field is true, ID field of VCN should be specified
        <span class="cov8" title="1">if c.Spec.NetworkSpec.Vcn.Skip == *common.Bool(true) </span><span class="cov0" title="0">{
                if c.Spec.NetworkSpec.Vcn.ID == common.String("") || c.Spec.NetworkSpec.Vcn.ID == nil </span><span class="cov0" title="0">{
                        allErrs = append(allErrs, field.Invalid(field.NewPath("spec", "NetworkSpec.Vcn.ID"), c.Spec.NetworkSpec.Vcn.ID, "field is required"))
                }</span>

                // If Skip field is True, Skip field of InternetGateway should be true
                <span class="cov0" title="0">if c.Spec.NetworkSpec.Vcn.InternetGateway.Skip != *common.Bool(true) </span><span class="cov0" title="0">{
                        allErrs = append(allErrs, field.Invalid(field.NewPath("spec", "NetworkSpec.Vcn.InternetGateway.Skip"), c.Spec.NetworkSpec.Vcn.InternetGateway.Skip, "field requires to be true when VCN is skipped"))
                }</span>

                // If Skip field is True, Skip field of ServiceGateway should be true
                <span class="cov0" title="0">if c.Spec.NetworkSpec.Vcn.ServiceGateway.Skip != *common.Bool(true) </span><span class="cov0" title="0">{
                        allErrs = append(allErrs, field.Invalid(field.NewPath("spec", "NetworkSpec.Vcn.ServiceGateway.Skip"), c.Spec.NetworkSpec.Vcn.ServiceGateway.Skip, "field requires to be true when VCN is skipped"))
                }</span>

                // If Skip field is True, Skip field of NATGateway should be true
                <span class="cov0" title="0">if c.Spec.NetworkSpec.Vcn.NATGateway.Skip != *common.Bool(true) </span><span class="cov0" title="0">{
                        allErrs = append(allErrs, field.Invalid(field.NewPath("spec", "NetworkSpec.Vcn.NATGateway.Skip"), c.Spec.NetworkSpec.Vcn.NATGateway.Skip, "field requires to be true when VCN is skipped"))
                }</span>

                // If Skip field is True, Skip field of RouteTable should be true
                <span class="cov0" title="0">if c.Spec.NetworkSpec.Vcn.RouteTable.Skip != *common.Bool(true) </span><span class="cov0" title="0">{
                        allErrs = append(allErrs, field.Invalid(field.NewPath("spec", "NetworkSpec.Vcn.RouteTable.Skip"), c.Spec.NetworkSpec.Vcn.RouteTable.Skip, "field requires to be true when VCN is skipped"))
                }</span>

                // For each subnet
                <span class="cov0" title="0">for _, subnet := range c.Spec.NetworkSpec.Vcn.Subnets </span><span class="cov0" title="0">{

                        // if Skip field is true, ID field of Subnet should also be specified
                        if subnet.Skip == *common.Bool(true) </span><span class="cov0" title="0">{
                                if subnet.ID == common.String("") || subnet.ID == nil </span><span class="cov0" title="0">{
                                        allErrs = append(allErrs, field.Invalid(field.NewPath("spec", "subnet.ID"), subnet.ID, "field is required"))
                                }</span>
                        }
                        // if ID field is specified, Skip field of Subnet should also be true
                        <span class="cov0" title="0">if subnet.ID != common.String("") </span><span class="cov0" title="0">{
                                if subnet.Skip != *common.Bool(true) </span><span class="cov0" title="0">{
                                        allErrs = append(allErrs, field.Invalid(field.NewPath("spec", "subnet.Skip"), subnet.Skip, "field requires to be true if Subnet ID is specified"))
                                }</span>
                        }
                }
        } else<span class="cov8" title="1"> {
                // If Skip field of VCN is false, for each subnet in that VCN the Skip field of Subnet cannot be true
                for _, subnet := range c.Spec.NetworkSpec.Vcn.Subnets </span><span class="cov8" title="1">{
                        if subnet.Skip == *common.Bool(true) </span><span class="cov0" title="0">{
                                allErrs = append(allErrs, field.Invalid(field.NewPath("spec", "subnet.Skip"), subnet.Skip, "field cannot be true when VCN is not skipped"))
                        }</span>
                }
        }

        <span class="cov8" title="1">allErrs = append(allErrs, c.validate(nil)...)

        if len(allErrs) == 0 </span><span class="cov8" title="1">{
                return nil, nil
        }</span>

        <span class="cov8" title="1">return nil, apierrors.NewInvalid(c.GroupVersionKind().GroupKind(), c.Name, allErrs)</span>
}

// ValidateDelete implements webhook.Validator so a webhook will be registered for the type.
func (*OCIClusterWebhook) ValidateDelete(_ context.Context, obj runtime.Object) (admission.Warnings, error) <span class="cov8" title="1">{
        c, ok := obj.(*OCICluster)
        if !ok </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("expected an OCICluster object but got %T", c)
        }</span>
        <span class="cov8" title="1">clusterlogger.Info("validate delete cluster", "name", c.Name)

        return nil, nil</span>
}

// ValidateUpdate implements webhook.Validator so a webhook will be registered for the type.
func (*OCIClusterWebhook) ValidateUpdate(_ context.Context, oldRaw, newObj runtime.Object) (admission.Warnings, error) <span class="cov8" title="1">{
        c, ok := newObj.(*OCICluster)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("expected an OCICluster object but got %T", c)
        }</span>

        <span class="cov8" title="1">clusterlogger.Info("validate update cluster", "name", c.Name)

        var allErrs field.ErrorList

        oldCluster, ok := oldRaw.(*OCICluster)
        if !ok </span><span class="cov0" title="0">{
                return nil, apierrors.NewBadRequest(fmt.Sprintf("expected an OCICluster but got a %T", oldRaw))
        }</span>

        <span class="cov8" title="1">if c.Spec.Region != oldCluster.Spec.Region </span><span class="cov8" title="1">{
                allErrs = append(allErrs, field.Invalid(field.NewPath("spec", "region"), c.Spec.Region, "field is immutable"))
        }</span>

        <span class="cov8" title="1">if c.Spec.OCIResourceIdentifier != oldCluster.Spec.OCIResourceIdentifier </span><span class="cov8" title="1">{
                allErrs = append(allErrs, field.Invalid(field.NewPath("spec", "ociResourceIdentifier"), c.Spec.OCIResourceIdentifier, "field is immutable"))
        }</span>

        <span class="cov8" title="1">if c.Spec.CompartmentId != oldCluster.Spec.CompartmentId </span><span class="cov8" title="1">{
                allErrs = append(allErrs, field.Invalid(field.NewPath("spec", "compartmentId"), c.Spec.CompartmentId, "field is immutable"))
        }</span>

        // If Skip field is true, ID field of VCN should be specified
        <span class="cov8" title="1">if c.Spec.NetworkSpec.Vcn.Skip == *common.Bool(true) </span><span class="cov0" title="0">{
                if c.Spec.NetworkSpec.Vcn.ID == common.String("") || c.Spec.NetworkSpec.Vcn.ID == nil </span><span class="cov0" title="0">{
                        allErrs = append(allErrs, field.Invalid(field.NewPath("spec", "NetworkSpec.Vcn.ID"), c.Spec.NetworkSpec.Vcn.ID, "field is required"))
                }</span>

                // If Skip field is True, Skip field of InternetGateway should be true
                <span class="cov0" title="0">if c.Spec.NetworkSpec.Vcn.InternetGateway.Skip != *common.Bool(true) </span><span class="cov0" title="0">{
                        allErrs = append(allErrs, field.Invalid(field.NewPath("spec", "NetworkSpec.Vcn.InternetGateway.Skip"), c.Spec.NetworkSpec.Vcn.InternetGateway.Skip, "field requires to be true when VCN is skipped"))
                }</span>

                // If Skip field is True, Skip field of ServiceGateway should be true
                <span class="cov0" title="0">if c.Spec.NetworkSpec.Vcn.ServiceGateway.Skip != *common.Bool(true) </span><span class="cov0" title="0">{
                        allErrs = append(allErrs, field.Invalid(field.NewPath("spec", "NetworkSpec.Vcn.ServiceGateway.Skip"), c.Spec.NetworkSpec.Vcn.ServiceGateway.Skip, "field requires to be true when VCN is skipped"))
                }</span>

                // If Skip field is True, Skip field of NATGateway should be true
                <span class="cov0" title="0">if c.Spec.NetworkSpec.Vcn.NATGateway.Skip != *common.Bool(true) </span><span class="cov0" title="0">{
                        allErrs = append(allErrs, field.Invalid(field.NewPath("spec", "NetworkSpec.Vcn.NATGateway.Skip"), c.Spec.NetworkSpec.Vcn.NATGateway.Skip, "field requires to be true when VCN is skipped"))
                }</span>

                // If Skip field is True, Skip field of RouteTable should be true
                <span class="cov0" title="0">if c.Spec.NetworkSpec.Vcn.RouteTable.Skip != *common.Bool(true) </span><span class="cov0" title="0">{
                        allErrs = append(allErrs, field.Invalid(field.NewPath("spec", "NetworkSpec.Vcn.RouteTable.Skip"), c.Spec.NetworkSpec.Vcn.RouteTable.Skip, "field requires to be true when VCN is skipped"))
                }</span>

                // For each subnet
                <span class="cov0" title="0">for _, subnet := range c.Spec.NetworkSpec.Vcn.Subnets </span><span class="cov0" title="0">{

                        // if Skip field is true, ID field of Subnet should also be specified
                        if subnet.Skip == *common.Bool(true) </span><span class="cov0" title="0">{
                                if subnet.ID == common.String("") || subnet.ID == nil </span><span class="cov0" title="0">{
                                        allErrs = append(allErrs, field.Invalid(field.NewPath("spec", "subnet.ID"), subnet.ID, "field is required"))
                                }</span>
                        }
                        // if ID field is specified, Skip field of Subnet should also be true
                        <span class="cov0" title="0">if subnet.ID != common.String("") </span><span class="cov0" title="0">{
                                if subnet.Skip != *common.Bool(true) </span><span class="cov0" title="0">{
                                        allErrs = append(allErrs, field.Invalid(field.NewPath("spec", "subnet.Skip"), subnet.Skip, "field requires to be true if Subnet ID is specified"))
                                }</span>
                        }
                }
        } else<span class="cov8" title="1"> {
                // If Skip field of VCN is false, for each subnet in that VCN the Skip field of Subnet cannot be true
                for _, subnet := range c.Spec.NetworkSpec.Vcn.Subnets </span><span class="cov8" title="1">{
                        if subnet.Skip == *common.Bool(true) </span><span class="cov0" title="0">{
                                allErrs = append(allErrs, field.Invalid(field.NewPath("spec", "subnet.Skip"), subnet.Skip, "field cannot be true when VCN is not skipped"))
                        }</span>
                }
        }

        <span class="cov8" title="1">allErrs = append(allErrs, c.validate(oldCluster)...)

        if len(allErrs) == 0 </span><span class="cov8" title="1">{
                return nil, nil
        }</span>

        <span class="cov8" title="1">return nil, apierrors.NewInvalid(c.GroupVersionKind().GroupKind(), c.Name, allErrs)</span>
}

func (c *OCICluster) validate(old *OCICluster) field.ErrorList <span class="cov8" title="1">{
        var allErrs field.ErrorList

        var oldNetworkSpec NetworkSpec
        if old != nil </span><span class="cov8" title="1">{
                oldNetworkSpec = old.Spec.NetworkSpec
        }</span>

        <span class="cov8" title="1">allErrs = append(allErrs, ValidateNetworkSpec(OCIClusterSubnetRoles, c.Spec.NetworkSpec, oldNetworkSpec, field.NewPath("spec").Child("networkSpec"))...)
        allErrs = append(allErrs, ValidateClusterName(c.Name)...)

        if len(c.Spec.CompartmentId) &lt;= 0 </span><span class="cov8" title="1">{
                allErrs = append(
                        allErrs,
                        field.Invalid(field.NewPath("spec", "compartmentId"), c.Spec.CompartmentId, "field is required"))
        }</span>

        // Handle case where CompartmentId exists, but isn't valid
        // the separate "blank" check above is a more clear error for the user
        <span class="cov8" title="1">if len(c.Spec.CompartmentId) &gt; 0 &amp;&amp; !ValidOcid(c.Spec.CompartmentId) </span><span class="cov8" title="1">{
                allErrs = append(
                        allErrs,
                        field.Invalid(field.NewPath("spec", "compartmentId"), c.Spec.CompartmentId, "field is invalid"))
        }</span>

        <span class="cov8" title="1">if len(c.Spec.OCIResourceIdentifier) &lt;= 0 </span><span class="cov8" title="1">{
                allErrs = append(
                        allErrs,
                        field.Invalid(field.NewPath("spec", "ociResourceIdentifier"), c.Spec.OCIResourceIdentifier, "field is required"))
        }</span>

        <span class="cov8" title="1">if !ValidRegion(c.Spec.Region) </span><span class="cov8" title="1">{
                allErrs = append(
                        allErrs,
                        field.Invalid(field.NewPath("spec", "region"), c.Spec.Region, "field is invalid. See https://docs.oracle.com/en-us/iaas/Content/General/Concepts/regions.htm"))
        }</span>

        <span class="cov8" title="1">if len(allErrs) == 0 </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">return allErrs</span>
}

func (c *OCICluster) SubnetSpec() []*Subnet <span class="cov8" title="1">{
        subnets := c.Spec.NetworkSpec.Vcn.Subnets

        cpEndpointSubnet := c.GetControlPlaneEndpointSubnet()
        if cpEndpointSubnet == nil </span><span class="cov8" title="1">{
                subnets = append(subnets, &amp;Subnet{
                        Role: ControlPlaneEndpointRole,
                        Name: ControlPlaneEndpointDefaultName,
                        CIDR: ControlPlaneEndpointSubnetDefaultCIDR,
                        Type: Public,
                })
        }</span> else<span class="cov8" title="1"> {
                if cpEndpointSubnet.CIDR == "" </span><span class="cov8" title="1">{
                        cpEndpointSubnet.CIDR = ControlPlaneEndpointSubnetDefaultCIDR
                }</span>
        }
        <span class="cov8" title="1">cpSubnet := c.GetControlPlaneMachineSubnet()
        if cpSubnet == nil </span><span class="cov8" title="1">{
                subnets = append(subnets, &amp;Subnet{
                        Role: ControlPlaneRole,
                        Name: ControlPlaneDefaultName,
                        CIDR: ControlPlaneMachineSubnetDefaultCIDR,
                        Type: Private,
                })
        }</span> else<span class="cov8" title="1"> {
                if cpSubnet.CIDR == "" </span><span class="cov0" title="0">{
                        cpSubnet.CIDR = ControlPlaneMachineSubnetDefaultCIDR
                }</span>
        }
        <span class="cov8" title="1">lbServiceSubnet := c.GetServiceLoadBalancerSubnet()
        if lbServiceSubnet == nil </span><span class="cov8" title="1">{
                subnets = append(subnets, &amp;Subnet{
                        Role: ServiceLoadBalancerRole,
                        Name: ServiceLBDefaultName,
                        CIDR: ServiceLoadBalancerDefaultCIDR,
                        Type: Public,
                })
        }</span> else<span class="cov8" title="1"> {
                if lbServiceSubnet.CIDR == "" </span><span class="cov0" title="0">{
                        lbServiceSubnet.CIDR = ServiceLoadBalancerDefaultCIDR
                }</span>
        }
        <span class="cov8" title="1">nodeSubnet := c.GetNodeSubnet()
        if nodeSubnet == nil </span><span class="cov8" title="1">{
                subnets = append(subnets, &amp;Subnet{
                        Role: WorkerRole,
                        Name: WorkerDefaultName,
                        CIDR: WorkerSubnetDefaultCIDR,
                        Type: Private,
                })
        }</span> else<span class="cov8" title="1"> {
                for _, subnet := range nodeSubnet </span><span class="cov8" title="1">{
                        if subnet.CIDR == "" </span><span class="cov8" title="1">{
                                subnet.CIDR = WorkerSubnetDefaultCIDR
                        }</span>
                }
        }
        <span class="cov8" title="1">return subnets</span>
}

func (c *OCICluster) NSGSpec() []*NSG <span class="cov8" title="1">{
        nsgs := c.Spec.NetworkSpec.Vcn.NetworkSecurityGroup.List
        if c.Spec.NetworkSpec.Vcn.NetworkSecurityGroup.Skip </span><span class="cov8" title="1">{
                return nsgs
        }</span>
        <span class="cov8" title="1">if !c.IsNSGExitsByRole(ControlPlaneEndpointRole) &amp;&amp; !c.IsSecurityListExitsByRole(ControlPlaneEndpointRole) </span><span class="cov8" title="1">{
                nsgs = append(nsgs, &amp;NSG{
                        Role:         ControlPlaneEndpointRole,
                        Name:         ControlPlaneEndpointDefaultName,
                        IngressRules: c.GetControlPlaneEndpointDefaultIngressRules(),
                        EgressRules:  c.GetControlPlaneEndpointDefaultEgressRules(),
                })
        }</span>
        <span class="cov8" title="1">if !c.IsNSGExitsByRole(ControlPlaneRole) &amp;&amp; !c.IsSecurityListExitsByRole(ControlPlaneRole) </span><span class="cov8" title="1">{
                nsgs = append(nsgs, &amp;NSG{
                        Role:         ControlPlaneRole,
                        Name:         ControlPlaneDefaultName,
                        IngressRules: c.GetControlPlaneMachineDefaultIngressRules(),
                        EgressRules:  c.GetControlPlaneMachineDefaultEgressRules(),
                })
        }</span>
        <span class="cov8" title="1">if !c.IsNSGExitsByRole(WorkerRole) &amp;&amp; !c.IsSecurityListExitsByRole(WorkerRole) </span><span class="cov8" title="1">{
                nsgs = append(nsgs, &amp;NSG{
                        Role:         WorkerRole,
                        Name:         WorkerDefaultName,
                        IngressRules: c.GetNodeDefaultIngressRules(),
                        EgressRules:  c.GetNodeDefaultEgressRules(),
                })
        }</span>
        <span class="cov8" title="1">if !c.IsNSGExitsByRole(ServiceLoadBalancerRole) &amp;&amp; !c.IsSecurityListExitsByRole(ServiceLoadBalancerRole) </span><span class="cov8" title="1">{
                nsgs = append(nsgs, &amp;NSG{
                        Role:         ServiceLoadBalancerRole,
                        Name:         ServiceLBDefaultName,
                        IngressRules: c.GetServiceLoadBalancerDefaultIngressRules(),
                        EgressRules:  c.GetServiceLoadBalancerDefaultEgressRules(),
                })
        }</span>
        <span class="cov8" title="1">return nsgs</span>
}

func (c *OCICluster) GetControlPlaneMachineDefaultIngressRules() []IngressSecurityRuleForNSG <span class="cov8" title="1">{
        return []IngressSecurityRuleForNSG{
                {
                        IngressSecurityRule: IngressSecurityRule{
                                Description: common.String("Kubernetes API endpoint to Control Plane(apiserver port) communication"),
                                Protocol:    common.String("6"),
                                TcpOptions: &amp;TcpOptions{
                                        DestinationPortRange: &amp;PortRange{
                                                Max: common.Int(6443),
                                                Min: common.Int(6443),
                                        },
                                },
                                SourceType: IngressSecurityRuleSourceTypeCidrBlock,
                                Source:     common.String(ControlPlaneEndpointSubnetDefaultCIDR),
                        },
                },
                {
                        IngressSecurityRule: IngressSecurityRule{
                                Description: common.String("Control plane node to Control Plane(apiserver port) communication"),
                                Protocol:    common.String("6"),
                                TcpOptions: &amp;TcpOptions{
                                        DestinationPortRange: &amp;PortRange{
                                                Max: common.Int(6443),
                                                Min: common.Int(6443),
                                        },
                                },
                                SourceType: IngressSecurityRuleSourceTypeCidrBlock,
                                Source:     common.String(ControlPlaneMachineSubnetDefaultCIDR),
                        },
                },
                {
                        IngressSecurityRule: IngressSecurityRule{
                                Description: common.String("Worker Node to Control Plane(apiserver port) communication"),
                                Protocol:    common.String("6"),
                                TcpOptions: &amp;TcpOptions{
                                        DestinationPortRange: &amp;PortRange{
                                                Max: common.Int(6443),
                                                Min: common.Int(6443),
                                        },
                                },
                                SourceType: IngressSecurityRuleSourceTypeCidrBlock,
                                Source:     common.String(WorkerSubnetDefaultCIDR),
                        },
                },
                {
                        IngressSecurityRule: IngressSecurityRule{
                                Description: common.String("etcd client communication"),
                                Protocol:    common.String("6"),
                                TcpOptions: &amp;TcpOptions{
                                        DestinationPortRange: &amp;PortRange{
                                                Max: common.Int(2379),
                                                Min: common.Int(2379),
                                        },
                                },
                                SourceType: IngressSecurityRuleSourceTypeCidrBlock,
                                Source:     common.String(ControlPlaneMachineSubnetDefaultCIDR),
                        },
                },
                {
                        IngressSecurityRule: IngressSecurityRule{
                                Description: common.String("etcd peer"),
                                Protocol:    common.String("6"),
                                TcpOptions: &amp;TcpOptions{
                                        DestinationPortRange: &amp;PortRange{
                                                Max: common.Int(2380),
                                                Min: common.Int(2380),
                                        },
                                },
                                SourceType: IngressSecurityRuleSourceTypeCidrBlock,
                                Source:     common.String(ControlPlaneMachineSubnetDefaultCIDR),
                        },
                },
                {
                        IngressSecurityRule: IngressSecurityRule{
                                Description: common.String("Calico networking (BGP)"),
                                Protocol:    common.String("6"),
                                TcpOptions: &amp;TcpOptions{
                                        DestinationPortRange: &amp;PortRange{
                                                Max: common.Int(179),
                                                Min: common.Int(179),
                                        },
                                },
                                SourceType: IngressSecurityRuleSourceTypeCidrBlock,
                                Source:     common.String(ControlPlaneMachineSubnetDefaultCIDR),
                        },
                },
                {
                        IngressSecurityRule: IngressSecurityRule{
                                Description: common.String("Calico networking (BGP)"),
                                Protocol:    common.String("6"),
                                TcpOptions: &amp;TcpOptions{
                                        DestinationPortRange: &amp;PortRange{
                                                Max: common.Int(179),
                                                Min: common.Int(179),
                                        },
                                },
                                SourceType: IngressSecurityRuleSourceTypeCidrBlock,
                                Source:     common.String(WorkerSubnetDefaultCIDR),
                        },
                },
                {
                        IngressSecurityRule: IngressSecurityRule{
                                Description: common.String("Calico networking with IP-in-IP enabled"),
                                Protocol:    common.String("4"),
                                SourceType:  IngressSecurityRuleSourceTypeCidrBlock,
                                Source:      common.String(ControlPlaneMachineSubnetDefaultCIDR),
                        },
                },
                {
                        IngressSecurityRule: IngressSecurityRule{
                                Description: common.String("Calico networking with IP-in-IP enabled"),
                                Protocol:    common.String("4"),
                                SourceType:  IngressSecurityRuleSourceTypeCidrBlock,
                                Source:      common.String(WorkerSubnetDefaultCIDR),
                        },
                },
                {
                        IngressSecurityRule: IngressSecurityRule{
                                Description: common.String("Path discovery"),
                                Protocol:    common.String("1"),
                                IcmpOptions: &amp;IcmpOptions{
                                        Type: common.Int(3),
                                        Code: common.Int(4),
                                },
                                SourceType: IngressSecurityRuleSourceTypeCidrBlock,
                                Source:     common.String(VcnDefaultCidr),
                        },
                },
                {
                        IngressSecurityRule: IngressSecurityRule{
                                Description: common.String("Inbound SSH traffic to Control Plane"),
                                Protocol:    common.String("6"),
                                SourceType:  IngressSecurityRuleSourceTypeCidrBlock,
                                Source:      common.String("0.0.0.0/0"),
                                TcpOptions: &amp;TcpOptions{
                                        DestinationPortRange: &amp;PortRange{
                                                Max: common.Int(22),
                                                Min: common.Int(22),
                                        },
                                },
                        },
                },
                {
                        IngressSecurityRule: IngressSecurityRule{
                                Description: common.String("Control Plane to Control Plane Kubelet Communication"),
                                Protocol:    common.String("6"),
                                TcpOptions: &amp;TcpOptions{
                                        DestinationPortRange: &amp;PortRange{
                                                Max: common.Int(10250),
                                                Min: common.Int(10250),
                                        },
                                },
                                SourceType: IngressSecurityRuleSourceTypeCidrBlock,
                                Source:     common.String(ControlPlaneMachineSubnetDefaultCIDR),
                        },
                },
        }
}</span>

func (c *OCICluster) GetControlPlaneMachineDefaultEgressRules() []EgressSecurityRuleForNSG <span class="cov8" title="1">{
        return []EgressSecurityRuleForNSG{
                {
                        EgressSecurityRule: EgressSecurityRule{
                                Description:     common.String("Control Plane access to Internet"),
                                Protocol:        common.String("all"),
                                DestinationType: EgressSecurityRuleDestinationTypeCidrBlock,
                                Destination:     common.String("0.0.0.0/0"),
                        },
                },
        }
}</span>

func (c *OCICluster) GetNodeDefaultIngressRules() []IngressSecurityRuleForNSG <span class="cov8" title="1">{
        return []IngressSecurityRuleForNSG{
                {
                        IngressSecurityRule: IngressSecurityRule{
                                Description: common.String("Inbound SSH traffic to worker node"),
                                Protocol:    common.String("6"),
                                SourceType:  IngressSecurityRuleSourceTypeCidrBlock,
                                Source:      common.String("0.0.0.0/0"),
                                TcpOptions: &amp;TcpOptions{
                                        DestinationPortRange: &amp;PortRange{
                                                Max: common.Int(22),
                                                Min: common.Int(22),
                                        },
                                },
                        },
                },
                {
                        IngressSecurityRule: IngressSecurityRule{
                                Description: common.String("Path discovery"),
                                Protocol:    common.String("1"),
                                IcmpOptions: &amp;IcmpOptions{
                                        Type: common.Int(3),
                                        Code: common.Int(4),
                                },
                                SourceType: IngressSecurityRuleSourceTypeCidrBlock,
                                Source:     common.String(VcnDefaultCidr),
                        },
                },
                {
                        IngressSecurityRule: IngressSecurityRule{
                                Description: common.String("Control Plane to worker node Kubelet Communication"),
                                Protocol:    common.String("6"),
                                TcpOptions: &amp;TcpOptions{
                                        DestinationPortRange: &amp;PortRange{
                                                Max: common.Int(10250),
                                                Min: common.Int(10250),
                                        },
                                },
                                SourceType: IngressSecurityRuleSourceTypeCidrBlock,
                                Source:     common.String(ControlPlaneMachineSubnetDefaultCIDR),
                        },
                },
                {
                        IngressSecurityRule: IngressSecurityRule{
                                Description: common.String("Worker node to worker node Kubelet Communication"),
                                Protocol:    common.String("6"),
                                TcpOptions: &amp;TcpOptions{
                                        DestinationPortRange: &amp;PortRange{
                                                Max: common.Int(10250),
                                                Min: common.Int(10250),
                                        },
                                },
                                SourceType: IngressSecurityRuleSourceTypeCidrBlock,
                                Source:     common.String(WorkerSubnetDefaultCIDR),
                        },
                },
                {
                        IngressSecurityRule: IngressSecurityRule{
                                Description: common.String("Calico networking (BGP)"),
                                Protocol:    common.String("6"),
                                TcpOptions: &amp;TcpOptions{
                                        DestinationPortRange: &amp;PortRange{
                                                Max: common.Int(179),
                                                Min: common.Int(179),
                                        },
                                },
                                SourceType: IngressSecurityRuleSourceTypeCidrBlock,
                                Source:     common.String(ControlPlaneMachineSubnetDefaultCIDR),
                        },
                },
                {
                        IngressSecurityRule: IngressSecurityRule{
                                Description: common.String("Calico networking (BGP)"),
                                Protocol:    common.String("6"),
                                TcpOptions: &amp;TcpOptions{
                                        DestinationPortRange: &amp;PortRange{
                                                Max: common.Int(179),
                                                Min: common.Int(179),
                                        },
                                },
                                SourceType: IngressSecurityRuleSourceTypeCidrBlock,
                                Source:     common.String(WorkerSubnetDefaultCIDR),
                        },
                },
                {
                        IngressSecurityRule: IngressSecurityRule{
                                Description: common.String("Calico networking with IP-in-IP enabled"),
                                Protocol:    common.String("4"),
                                SourceType:  IngressSecurityRuleSourceTypeCidrBlock,
                                Source:      common.String(ControlPlaneMachineSubnetDefaultCIDR),
                        },
                },
                {
                        IngressSecurityRule: IngressSecurityRule{
                                Description: common.String("Calico networking with IP-in-IP enabled"),
                                Protocol:    common.String("4"),
                                SourceType:  IngressSecurityRuleSourceTypeCidrBlock,
                                Source:      common.String(WorkerSubnetDefaultCIDR),
                        },
                },
                {
                        IngressSecurityRule: IngressSecurityRule{
                                Description: common.String("Worker node to default NodePort ingress communication"),
                                Protocol:    common.String("6"),
                                TcpOptions: &amp;TcpOptions{
                                        DestinationPortRange: &amp;PortRange{
                                                Max: common.Int(32767),
                                                Min: common.Int(30000),
                                        },
                                },
                                SourceType: IngressSecurityRuleSourceTypeCidrBlock,
                                Source:     common.String(WorkerSubnetDefaultCIDR),
                        },
                },
        }
}</span>

func (c *OCICluster) GetNodeDefaultEgressRules() []EgressSecurityRuleForNSG <span class="cov8" title="1">{
        return []EgressSecurityRuleForNSG{
                {
                        EgressSecurityRule: EgressSecurityRule{
                                Description:     common.String("Worker node access to Internet"),
                                Protocol:        common.String("all"),
                                DestinationType: EgressSecurityRuleDestinationTypeCidrBlock,
                                Destination:     common.String("0.0.0.0/0"),
                        },
                },
        }
}</span>

func (c *OCICluster) GetServiceLoadBalancerDefaultIngressRules() []IngressSecurityRuleForNSG <span class="cov8" title="1">{
        return []IngressSecurityRuleForNSG{
                {
                        IngressSecurityRule: IngressSecurityRule{
                                Description: common.String("Path discovery"),
                                Protocol:    common.String("1"),
                                IcmpOptions: &amp;IcmpOptions{
                                        Type: common.Int(3),
                                        Code: common.Int(4),
                                },
                                SourceType: IngressSecurityRuleSourceTypeCidrBlock,
                                Source:     common.String(VcnDefaultCidr),
                        },
                },
                {
                        IngressSecurityRule: IngressSecurityRule{
                                Description: common.String("Accept http traffic on port 80"),
                                Protocol:    common.String("6"),
                                TcpOptions: &amp;TcpOptions{
                                        DestinationPortRange: &amp;PortRange{
                                                Max: common.Int(80),
                                                Min: common.Int(80),
                                        },
                                },
                                SourceType: IngressSecurityRuleSourceTypeCidrBlock,
                                Source:     common.String("0.0.0.0/0"),
                        },
                },
                {
                        IngressSecurityRule: IngressSecurityRule{
                                Description: common.String("Accept https traffic on port 443"),
                                Protocol:    common.String("6"),
                                TcpOptions: &amp;TcpOptions{
                                        DestinationPortRange: &amp;PortRange{
                                                Max: common.Int(443),
                                                Min: common.Int(443),
                                        },
                                },
                                SourceType: IngressSecurityRuleSourceTypeCidrBlock,
                                Source:     common.String("0.0.0.0/0"),
                        },
                },
        }
}</span>

func (c *OCICluster) GetServiceLoadBalancerDefaultEgressRules() []EgressSecurityRuleForNSG <span class="cov8" title="1">{
        return []EgressSecurityRuleForNSG{
                {
                        EgressSecurityRule: EgressSecurityRule{
                                Destination:     common.String(WorkerSubnetDefaultCIDR),
                                Protocol:        common.String("6"),
                                DestinationType: EgressSecurityRuleDestinationTypeCidrBlock,
                                TcpOptions: &amp;TcpOptions{
                                        DestinationPortRange: &amp;PortRange{
                                                Max: common.Int(32767),
                                                Min: common.Int(30000),
                                        },
                                },
                                Description: common.String("Service LoadBalancer to default NodePort egress communication"),
                        },
                },
        }
}</span>

func (c *OCICluster) GetControlPlaneEndpointDefaultIngressRules() []IngressSecurityRuleForNSG <span class="cov8" title="1">{
        return []IngressSecurityRuleForNSG{
                {
                        IngressSecurityRule: IngressSecurityRule{
                                Description: common.String("External access to Kubernetes API endpoint"),
                                Protocol:    common.String("6"),
                                TcpOptions: &amp;TcpOptions{
                                        DestinationPortRange: &amp;PortRange{
                                                Max: common.Int(6443),
                                                Min: common.Int(6443),
                                        },
                                },
                                SourceType: IngressSecurityRuleSourceTypeCidrBlock,
                                Source:     common.String("0.0.0.0/0"),
                        },
                },
                {
                        IngressSecurityRule: IngressSecurityRule{
                                Description: common.String("Path discovery"),
                                Protocol:    common.String("1"),
                                IcmpOptions: &amp;IcmpOptions{
                                        Type: common.Int(3),
                                        Code: common.Int(4),
                                },
                                SourceType: IngressSecurityRuleSourceTypeCidrBlock,
                                Source:     common.String(VcnDefaultCidr),
                        },
                },
        }
}</span>

func (c *OCICluster) GetControlPlaneEndpointDefaultEgressRules() []EgressSecurityRuleForNSG <span class="cov8" title="1">{
        return []EgressSecurityRuleForNSG{
                {
                        EgressSecurityRule: EgressSecurityRule{
                                Description: common.String("Kubernetes API traffic to Control Plane"),
                                Protocol:    common.String("6"),
                                TcpOptions: &amp;TcpOptions{
                                        DestinationPortRange: &amp;PortRange{
                                                Max: common.Int(6443),
                                                Min: common.Int(6443),
                                        },
                                },
                                DestinationType: EgressSecurityRuleDestinationTypeCidrBlock,
                                Destination:     common.String(ControlPlaneMachineSubnetDefaultCIDR),
                        },
                },
        }
}</span>

func (c *OCICluster) GetControlPlaneEndpointSubnet() *Subnet <span class="cov8" title="1">{
        for _, subnet := range c.Spec.NetworkSpec.Vcn.Subnets </span><span class="cov8" title="1">{
                if subnet != nil &amp;&amp; subnet.Role == ControlPlaneEndpointRole </span><span class="cov8" title="1">{
                        return subnet
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (c *OCICluster) GetControlPlaneMachineSubnet() *Subnet <span class="cov8" title="1">{
        for _, subnet := range c.Spec.NetworkSpec.Vcn.Subnets </span><span class="cov8" title="1">{
                if subnet != nil &amp;&amp; subnet.Role == ControlPlaneRole </span><span class="cov8" title="1">{
                        return subnet
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (c *OCICluster) GetServiceLoadBalancerSubnet() *Subnet <span class="cov8" title="1">{
        for _, subnet := range c.Spec.NetworkSpec.Vcn.Subnets </span><span class="cov8" title="1">{
                if subnet != nil &amp;&amp; subnet.Role == ServiceLoadBalancerRole </span><span class="cov8" title="1">{
                        return subnet
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (c *OCICluster) GetNodeSubnet() []*Subnet <span class="cov8" title="1">{
        var nodeSubnets []*Subnet
        for _, subnet := range c.Spec.NetworkSpec.Vcn.Subnets </span><span class="cov8" title="1">{
                if subnet != nil &amp;&amp; subnet.Role == WorkerRole </span><span class="cov8" title="1">{
                        nodeSubnets = append(nodeSubnets, subnet)
                }</span>
        }
        <span class="cov8" title="1">return nodeSubnets</span>
}

func (c *OCICluster) IsNSGExitsByRole(role Role) bool <span class="cov8" title="1">{
        for _, nsg := range c.Spec.NetworkSpec.Vcn.NetworkSecurityGroup.List </span><span class="cov8" title="1">{
                if nsg != nil &amp;&amp; role == nsg.Role </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

func (c *OCICluster) IsSecurityListExitsByRole(role Role) bool <span class="cov8" title="1">{
        for _, subnet := range c.Spec.NetworkSpec.Vcn.Subnets </span><span class="cov8" title="1">{
                if subnet != nil &amp;&amp; role == subnet.Role </span><span class="cov8" title="1">{
                        if subnet.SecurityList != nil </span><span class="cov0" title="0">{
                                return true
                        }</span>
                }
        }
        <span class="cov8" title="1">return false</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">/*
 Copyright (c) 2022, 2023 Oracle and/or its affiliates.

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

      https://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
*/

package v1beta2

import (
        corev1 "k8s.io/api/core/v1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        clusterv1 "sigs.k8s.io/cluster-api/api/core/v1beta1"
)

type PrincipalType string

const (
        // UserPrincipal represents a user principal.
        UserPrincipal PrincipalType = "UserPrincipal"
        // InstancePrincipal represents a instance principal.
        InstancePrincipal PrincipalType = "InstancePrincipal"
        // WorkloadPrincipal represents a workload principal.
        WorkloadPrincipal PrincipalType = "Workload"
)

// OCIClusterIdentitySpec defines the parameters that are used to create an OCIClusterIdentity.
type OCIClusterIdentitySpec struct {
        // Type is the type of OCI Principal used.
        // UserPrincipal is the only supported value
        Type PrincipalType `json:"type"`

        // PrincipalSecret is a secret reference which contains the authentication credentials for the principal.
        // +optional
        PrincipalSecret corev1.SecretReference `json:"principalSecret,omitempty"`

        // AllowedNamespaces is used to identify the namespaces the clusters are allowed to use the identity from.
        // Namespaces can be selected either using an array of namespaces or with label selector.
        // An empty allowedNamespaces object indicates that OCIClusters can use this identity from any namespace.
        // If this object is nil, no namespaces will be allowed (default behaviour, if this field is not provided)
        // A namespace should be either in the NamespaceList or match with Selector to use the identity.
        //
        // +optional
        // +nullable
        AllowedNamespaces *AllowedNamespaces `json:"allowedNamespaces"`
}

// AllowedNamespaces defines the namespaces the clusters are allowed to use the identity from
type AllowedNamespaces struct {
        // A nil or empty list indicates that OCICluster cannot use the identity from any namespace.
        // NamespaceList takes precedence over the Selector.
        // +optional
        // +nullable
        NamespaceList []string `json:"list"`

        // Selector is a selector of namespaces that OCICluster can
        // use this Identity from. This is a standard Kubernetes LabelSelector,
        // a label query over a set of resources. The result of matchLabels and
        // matchExpressions are ANDed.
        //
        // A nil or empty selector indicates that OCICluster cannot use this
        // OCIClusterIdentity from any namespace.
        // +optional
        Selector *metav1.LabelSelector `json:"selector"`
}

// OCIClusterIdentityStatus defines the observed state of OCIClusterIdentity.
type OCIClusterIdentityStatus struct {
        // Conditions defines current service state of the OCIClusterIdentity.
        // +optional
        Conditions clusterv1.Conditions `json:"conditions,omitempty"`
}

//+kubebuilder:object:root=true
//+kubebuilder:subresource:status
// +kubebuilder:storageversion

// OCIClusterIdentity is the Schema for the OCI Cluster Identity API
type OCIClusterIdentity struct {
        metav1.TypeMeta   `json:",inline"`
        metav1.ObjectMeta `json:"metadata,omitempty"`
        Spec              OCIClusterIdentitySpec   `json:"spec,omitempty"`
        Status            OCIClusterIdentityStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// OCIClusterIdentityList contains a list of OCIClusterIdentity.
type OCIClusterIdentityList struct {
        metav1.TypeMeta `json:",inline"`
        metav1.ListMeta `json:"metadata,omitempty"`
        Items           []OCIClusterIdentity `json:"items"`
}

func init() <span class="cov8" title="1">{
        SchemeBuilder.Register(&amp;OCIClusterIdentity{}, &amp;OCIClusterIdentityList{})
}</span>
</pre>
		
		<pre class="file" id="file21" style="display: none">/*
Copyright (c) 2022, Oracle and/or its affiliates.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1beta2

import (
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

// OCIClusterTemplateSpec defines the desired state of OCIClusterTemplate.
type OCIClusterTemplateSpec struct {
        Template OCIClusterTemplateResource `json:"template"`
}

// +kubebuilder:object:root=true
// +kubebuilder:resource:path=ociclustertemplates,scope=Namespaced,categories=cluster-api
// +kubebuilder:storageversion

// OCIClusterTemplate is the Schema for the ociclustertemplates API.
type OCIClusterTemplate struct {
        metav1.TypeMeta   `json:",inline"`
        metav1.ObjectMeta `json:"metadata,omitempty"`

        Spec OCIClusterTemplateSpec `json:"spec,omitempty"`
}

// +kubebuilder:object:root=true

// OCIClusterTemplateList contains a list of OCIClusterTemplate.
type OCIClusterTemplateList struct {
        metav1.TypeMeta `json:",inline"`
        metav1.ListMeta `json:"metadata,omitempty"`

        Items []OCIClusterTemplate `json:"items"`
}

func init() <span class="cov8" title="1">{
        SchemeBuilder.Register(&amp;OCIClusterTemplate{}, &amp;OCIClusterTemplateList{})
}</span>

// OCIClusterTemplateResource describes the data needed to create an OCICluster from a template.
type OCIClusterTemplateResource struct {
        Spec OCIClusterSpec `json:"spec"`
}
</pre>
		
		<pre class="file" id="file22" style="display: none">/*
Copyright (c) 2021, 2022 Oracle and/or its affiliates.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1beta2

import (
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        clusterv1 "sigs.k8s.io/cluster-api/api/core/v1beta1"
)

// NOTE: json tags are required.  Any new fields you add must have json tags for the fields to be serialized.
// Important: Run "make" to regenerate code after modifying this file

const (
        // MachineFinalizer allows ReconcileMachine to clean up OCI resources associated with OCIMachine before
        // removing it from the apiserver.
        MachineFinalizer                   = "ocimachine.infrastructure.cluster.x-k8s.io"
        DeleteMachineOnInstanceTermination = "ociclusters.x-k8s.io/delete-machine-on-instance-termination"
)

// OCIMachineSpec defines the desired state of OCIMachine
// Please read the API https://docs.oracle.com/en-us/iaas/api/#/en/iaas/20160918/Instance/LaunchInstance
// for more information about the parameters below
type OCIMachineSpec struct {
        // OCID of launched compute instance.
        // +optional
        InstanceId *string `json:"instanceId,omitempty"`

        // OCID of the image to be used to launch the instance.
        ImageId string `json:"imageId,omitempty"`

        // Compartment to launch the instance in.
        CompartmentId string `json:"compartmentId,omitempty"`

        // Shape of the instance.
        Shape string `json:"shape,omitempty"`

        // ComputeClusterId refers to OCID of the compute cluster that the instance will be created in.
        // Please refer https://docs.oracle.com/en-us/iaas/Content/Compute/Tasks/compute-clusters.htm for more details
        ComputeClusterId *string `json:"computeClusterId,omitempty"`

        // IpxeScript is the  custom iPXE script that will run when the instance boots.
        IpxeScript *string `json:"ipxeScript,omitempty"`

        // CapacityReservationId defines the OCID of the compute capacity reservation this instance is launched under.
        // You can opt out of all default reservations by specifying an empty string as input for this field.
        // For more information, see Capacity Reservations (https://docs.cloud.oracle.com/iaas/Content/Compute/Tasks/reserve-capacity.htm#default).
        CapacityReservationId *string `json:"capacityReservationId,omitempty"`

        // The shape configuration of rhe instance, applicable for flex instances.
        ShapeConfig ShapeConfig `json:"shapeConfig,omitempty"`

        // NetworkDetails defines the configuration options for the network
        NetworkDetails NetworkDetails `json:"networkDetails,omitempty"`

        // VnicAttachments defines the configuration options for the vnic(s) attached to the machine
        // The network bandwidth and number of VNICs scale proportionately with the number of OCPUs.
        VnicAttachments []VnicAttachment `json:"vnicAttachments,omitempty"`

        // LaunchOptions defines the options for tuning the compatibility and performance of VM shapes
        LaunchOptions *LaunchOptions `json:"launchOptions,omitempty"`

        // InstanceOptions defines the instance options
        InstanceOptions *InstanceOptions `json:"instanceOptions,omitempty"`

        // LaunchInstanceAvailabilityConfig defines the options for VM migration during infrastructure maintenance events and for defining
        // the availability of a VM instance after a maintenance event that impacts the underlying hardware.
        AvailabilityConfig *LaunchInstanceAvailabilityConfig `json:"availabilityConfig,omitempty"`

        // PreemptibleInstanceConfig Configuration options for preemptible instances.
        PreemptibleInstanceConfig *PreemptibleInstanceConfig `json:"preemptibleInstanceConfig,omitempty"`

        // AgentConfig defines the options for the Oracle Cloud Agent software running on the instance.
        AgentConfig *LaunchInstanceAgentConfig `json:"agentConfig,omitempty"`

        // InstanceSourceViaImageConfig defines the options for booting up instances via images
        InstanceSourceViaImageDetails *InstanceSourceViaImageConfig `json:"instanceSourceViaImageConfig,omitempty"`

        // PlatformConfig defines the platform config parameters
        PlatformConfig *PlatformConfig `json:"platformConfig,omitempty"`

        // DedicatedVmHostId defines the OCID of the dedicated VM host.
        DedicatedVmHostId *string `json:"dedicatedVmHostId,omitempty"`

        // Provider ID of the instance, this will be set by Cluster API provider itself,
        // users should not set this parameter.
        // +optional
        ProviderID *string `json:"providerID,omitempty"`

        // Is in transit encryption of volumes required.
        // +optional
        IsPvEncryptionInTransitEnabled bool `json:"isPvEncryptionInTransitEnabled,omitempty"`

        // The size of boot volume. Please see https://docs.oracle.com/en-us/iaas/Content/Block/Tasks/extendingbootpartition.htm
        // to extend the boot volume size.
        BootVolumeSizeInGBs string `json:"bootVolumeSizeInGBs,omitempty"`

        // Custom metadata key/value pairs that you provide, such as the SSH public key
        // required to connect to the instance.
        Metadata map[string]string `json:"metadata,omitempty"`

        // Free-form tags for this resource.
        // +optional
        FreeformTags map[string]string `json:"freeformTags,omitempty"`

        // Defined tags for this resource. Each key is predefined and scoped to a
        // namespace. For more information, see Resource Tags (https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        // Example: `{"Operations": {"CostCenter": "42"}}`
        // +optional
        DefinedTags map[string]map[string]string `json:"definedTags,omitempty"`

        // Volume attachments to create as part of the launch instance operation.
        LaunchVolumeAttachment []LaunchVolumeAttachment `json:"launchVolumeAttachments,omitempty"`

        // The name of the subnet to use. The name here refers to the subnets
        // defined in the OCICluster Spec. Optional, only if multiple subnets of a type
        // is defined, else the first element is used.
        // +optional
        SubnetName string `json:"subnetName,omitempty"`

        // Specifies whether to delete or preserve the boot volume when terminating an instance.
        // When set to true, the boot volume is preserved. The default value is false.
        PreserveBootVolume bool `json:"preserveBootVolume,omitempty"`

        // Specifies whether to delete or preserve the data volumes created during launch when
        //terminating an instance. When set to true, the data volumes are preserved. The default value is true.
        PreserveDataVolumesCreatedAtLaunch bool `json:"preserveDataVolumesCreatedAtLaunch,omitempty"`
}

// OCIMachineStatus defines the observed state of OCIMachine.
type OCIMachineStatus struct {
        // INSERT ADDITIONAL STATUS FIELD - define observed state of machine

        // Flag set to true when machine is ready.
        // +optional
        Ready bool `json:"ready,omitempty"`

        // Addresses contains the addresses of the associated OCI instance.
        Addresses []clusterv1.MachineAddress `json:"addresses,omitempty"`

        // Error status on the machine.
        // +optional
        FailureReason *string `json:"failureReason,omitempty"`

        // The error message corresponding to the error on the machine.
        // +optional
        FailureMessage *string `json:"failureMessage,omitempty"`

        // Launch instance work request ID.
        // +optional
        LaunchInstanceWorkRequestId string `json:"launchInstanceWorkRequestId,omitempty"`

        // Create Backend OPC work request ID for the machine backend.
        // +optional
        CreateBackendWorkRequestId string `json:"createBackendWorkRequestId,omitempty"`

        // Delete Backend OPC work request ID for the machine backend.
        // +optional
        DeleteBackendWorkRequestId string `json:"deleteBackendWorkRequestId,omitempty"`

        // Conditions defines current service state of the OCIMachine.
        // +optional
        Conditions clusterv1.Conditions `json:"conditions,omitempty"`
}

//+kubebuilder:object:root=true
//+kubebuilder:subresource:status
// +kubebuilder:storageversion

// OCIMachine is the Schema for the ocimachines API.
type OCIMachine struct {
        metav1.TypeMeta   `json:",inline"`
        metav1.ObjectMeta `json:"metadata,omitempty"`

        Spec   OCIMachineSpec   `json:"spec,omitempty"`
        Status OCIMachineStatus `json:"status,omitempty"`
}

//+kubebuilder:object:root=true
// +kubebuilder:storageversion

// OCIMachineList contains a list of OCIMachine.
type OCIMachineList struct {
        metav1.TypeMeta `json:",inline"`
        metav1.ListMeta `json:"metadata,omitempty"`
        Items           []OCIMachine `json:"items"`
}

// GetConditions returns the list of conditions for an OCIMachine API object.
func (m *OCIMachine) GetConditions() clusterv1.Conditions <span class="cov8" title="1">{
        return m.Status.Conditions
}</span>

// SetConditions will set the given conditions on an OCIMachine object.
func (m *OCIMachine) SetConditions(conditions clusterv1.Conditions) <span class="cov8" title="1">{
        m.Status.Conditions = conditions
}</span>

func init() <span class="cov8" title="1">{
        SchemeBuilder.Register(&amp;OCIMachine{}, &amp;OCIMachineList{})
}</span>
</pre>
		
		<pre class="file" id="file23" style="display: none">/*
 Copyright (c) 2021, 2022 Oracle and/or its affiliates.

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

      https://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
*/

package v1beta2

import (
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

// OCIMachineTemplateSpec defines the desired state of OCIMachineTemplate.
type OCIMachineTemplateSpec struct {
        Template OCIMachineTemplateResource `json:"template"`
}

// OCIMachineTemplateResource describes the data needed to create an OCIMachine from a template.
type OCIMachineTemplateResource struct {
        // Spec is the specification of the desired behavior of the machine.
        Spec OCIMachineSpec `json:"spec"`
}

// +kubebuilder:object:root=true
// +kubebuilder:resource:path=ocimachinetemplates,scope=Namespaced,categories=cluster-api
// +kubebuilder:storageversion

// OCIMachineTemplate is the schema for the OCI compute instance machine template.
type OCIMachineTemplate struct {
        metav1.TypeMeta   `json:",inline"`
        metav1.ObjectMeta `json:"metadata,omitempty"`

        Spec OCIMachineTemplateSpec `json:"spec,omitempty"`
}

// +kubebuilder:object:root=true
// +kubebuilder:storageversion

// OCIMachineTemplateList contains a list of OCIMachineTemplate.
type OCIMachineTemplateList struct {
        metav1.TypeMeta `json:",inline"`
        metav1.ListMeta `json:"metadata,omitempty"`
        Items           []OCIMachineTemplate `json:"items"`
}

func init() <span class="cov8" title="1">{
        SchemeBuilder.Register(&amp;OCIMachineTemplate{}, &amp;OCIMachineTemplateList{})
}</span>
</pre>
		
		<pre class="file" id="file24" style="display: none">/*
Copyright (c) 2021, 2022 Oracle and/or its affiliates.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1beta2

import (
        "context"
        "fmt"

        apierrors "k8s.io/apimachinery/pkg/api/errors"
        "k8s.io/apimachinery/pkg/runtime"
        "k8s.io/apimachinery/pkg/util/validation/field"
        ctrl "sigs.k8s.io/controller-runtime"
        "sigs.k8s.io/controller-runtime/pkg/webhook"
        "sigs.k8s.io/controller-runtime/pkg/webhook/admission"
)

type OCIMachineTemplateWebhook struct{}

var (
        _ webhook.CustomValidator = &amp;OCIMachineTemplateWebhook{}
)

// +kubebuilder:webhook:verbs=create;update,path=/validate-infrastructure-cluster-x-k8s-io-v1beta2-ocimachinetemplate,mutating=false,failurePolicy=fail,matchPolicy=Equivalent,groups=infrastructure.cluster.x-k8s.io,resources=ocimachinetemplates,versions=v1beta2,name=validation.ocimachinetemplate.infrastructure.cluster.x-k8s.io,sideEffects=None,admissionReviewVersions=v1beta1

func (m *OCIMachineTemplate) SetupWebhookWithManager(mgr ctrl.Manager) error <span class="cov0" title="0">{
        w := new(OCIMachineTemplateWebhook)
        return ctrl.NewWebhookManagedBy(mgr).
                For(m).
                WithValidator(w).
                Complete()
}</span>

// ValidateCreate implements webhook.Validator so a webhook will be registered for the type.
func (*OCIMachineTemplateWebhook) ValidateCreate(_ context.Context, raw runtime.Object) (admission.Warnings, error) <span class="cov8" title="1">{
        m, ok := raw.(*OCIMachineTemplate)
        if !ok </span><span class="cov0" title="0">{
                return nil, apierrors.NewBadRequest(fmt.Sprintf("expected a OCIMachineTemplate but got a %T", raw))
        }</span>

        <span class="cov8" title="1">clusterlogger.Info("validate create machinetemplate", "name", m.Name)

        var allErrs field.ErrorList

        allErrs = append(allErrs, m.validate()...)

        if len(allErrs) == 0 </span><span class="cov8" title="1">{
                return nil, nil
        }</span>

        <span class="cov8" title="1">return nil, apierrors.NewInvalid(m.GroupVersionKind().GroupKind(), m.Name, allErrs)</span>
}

// ValidateDelete implements webhook.Validator so a webhook will be registered for the type.
func (*OCIMachineTemplateWebhook) ValidateDelete(_ context.Context, raw runtime.Object) (admission.Warnings, error) <span class="cov8" title="1">{
        m, ok := raw.(*OCIMachineTemplate)
        if !ok </span><span class="cov8" title="1">{
                return nil, apierrors.NewBadRequest(fmt.Sprintf("expected a OCIMachineTemplate but got a %T", raw))
        }</span>
        <span class="cov8" title="1">clusterlogger.Info("validate delete machinetemplate", "name", m.Name)

        return nil, nil</span>
}

// ValidateUpdate implements webhook.Validator so a webhook will be registered for the type.
func (*OCIMachineTemplateWebhook) ValidateUpdate(ctx context.Context, oldRaw runtime.Object, newRaw runtime.Object) (admission.Warnings, error) <span class="cov8" title="1">{
        m, ok := newRaw.(*OCIMachineTemplate)
        if !ok </span><span class="cov0" title="0">{
                return nil, apierrors.NewBadRequest(fmt.Sprintf("expected a OCIMachineTemplate but got a %T", newRaw))
        }</span>
        <span class="cov8" title="1">clusterlogger.Info("validate update machinetemplate", "name", m.Name)

        var allErrs field.ErrorList

        allErrs = append(allErrs, m.validate()...)

        if len(allErrs) == 0 </span><span class="cov8" title="1">{
                return nil, nil
        }</span>

        <span class="cov8" title="1">return nil, apierrors.NewInvalid(m.GroupVersionKind().GroupKind(), m.Name, allErrs)</span>
}

func (m *OCIMachineTemplate) validate() field.ErrorList <span class="cov8" title="1">{
        var allErrs field.ErrorList

        if len(m.Spec.Template.Spec.ImageId) &gt; 0 &amp;&amp; !ValidOcid(m.Spec.Template.Spec.ImageId) </span><span class="cov8" title="1">{
                allErrs = append(
                        allErrs,
                        field.Invalid(
                                field.NewPath("spec", "template", "spec", "imageId"),
                                m.Spec.Template.Spec.ImageId,
                                "field is invalid"),
                )
        }</span>

        // simple validity test for compartment
        <span class="cov8" title="1">if len(m.Spec.Template.Spec.CompartmentId) &gt; 0 &amp;&amp; !ValidOcid(m.Spec.Template.Spec.CompartmentId) </span><span class="cov8" title="1">{
                allErrs = append(
                        allErrs,
                        field.Invalid(
                                field.NewPath("spec", "template", "spec", "compartmentId"),
                                m.Spec.Template.Spec.CompartmentId,
                                "field is invalid"),
                )
        }</span>

        <span class="cov8" title="1">if !validShape(m.Spec.Template.Spec.Shape) </span><span class="cov8" title="1">{
                allErrs = append(
                        allErrs,
                        field.Invalid(
                                field.NewPath("spec", "template", "spec", "shape"),
                                m.Spec.Template.Spec.Shape,
                                fmt.Sprintf("shape is invalid - %s", m.Spec.Template.Spec.Shape)),
                )
        }</span>

        <span class="cov8" title="1">if len(allErrs) == 0 </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">return allErrs</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">/*
Copyright (c) 2021, 2022 Oracle and/or its affiliates.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1beta2

import (
        corev1 "k8s.io/api/core/v1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        clusterv1 "sigs.k8s.io/cluster-api/api/core/v1beta1"
)

const (
        // ManagedClusterFinalizer allows OCIManagedClusterReconciler to clean up OCI resources associated with OCIManagedCluster.
        ManagedClusterFinalizer = "ocimanagedcluster.infrastructure.cluster.x-k8s.io"
)

// OCIManagedClusterSpec defines the desired state of OCI OKE Cluster
type OCIManagedClusterSpec struct {

        // The unique ID which will be used to tag all the resources created by this Cluster.
        // The tag will be used to identify resources belonging to this cluster.
        // this will be auto-generated and should not be set by the user.
        // +optional
        OCIResourceIdentifier string `json:"ociResourceIdentifier,omitempty"`

        // IdentityRef is a reference to an identity(principal) to be used when reconciling this cluster
        // +optional
        IdentityRef *corev1.ObjectReference `json:"identityRef,omitempty"`

        // NetworkSpec encapsulates all things related to OCI network.
        // +optional
        NetworkSpec NetworkSpec `json:"networkSpec,omitempty"`

        // Free-form tags for this resource.
        // +optional
        FreeformTags map[string]string `json:"freeformTags,omitempty"`

        // Defined tags for this resource. Each key is predefined and scoped to a
        // namespace. For more information, see Resource Tags (https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        // Example: `{"Operations": {"CostCenter": "42"}}`
        // +optional
        DefinedTags map[string]map[string]string `json:"definedTags,omitempty"`

        // Compartment to create the cluster network.
        // +optional
        CompartmentId string `json:"compartmentId"`

        // Region the cluster operates in. It must be one of available regions in Region Identifier format.
        // See https://docs.oracle.com/en-us/iaas/Content/General/Concepts/regions.htm
        Region string `json:"region,omitempty"`

        // ControlPlaneEndpoint represents the endpoint used to communicate with the control plane. This will not be set by the user, this will be updated by the Cluster Reconciler after OKe cluster has been created and the cluster has an endpoint address
        // +optional
        ControlPlaneEndpoint clusterv1.APIEndpoint `json:"controlPlaneEndpoint"`

        // AvailabilityDomains encapsulates the clusters Availability Domain (AD) information in a map
        // where the map key is the AD name and the struct is details about the AD.
        // +optional
        AvailabilityDomains map[string]OCIAvailabilityDomain `json:"availabilityDomains,omitempty"`

        // ClientOverrides allows the default client SDK URLs to be changed.
        //
        // +optional
        // +nullable
        ClientOverrides *ClientOverrides `json:"hostUrl,omitempty"`
}

// OCIManagedClusterStatus defines the observed state of OCICluster
type OCIManagedClusterStatus struct {
        // +optional
        FailureDomains clusterv1.FailureDomains `json:"failureDomains,omitempty"`

        // +optional
        Ready bool `json:"ready"`
        // NetworkSpec encapsulates all things related to OCI network.
        // +optional
        Conditions clusterv1.Conditions `json:"conditions,omitempty"`
}

//+kubebuilder:object:root=true
//+kubebuilder:subresource:status
// +kubebuilder:storageversion

// OCIManagedCluster is the Schema for the ocimanagedclusters API.
type OCIManagedCluster struct {
        metav1.TypeMeta   `json:",inline"`
        metav1.ObjectMeta `json:"metadata,omitempty"`

        Spec   OCIManagedClusterSpec   `json:"spec,omitempty"`
        Status OCIManagedClusterStatus `json:"status,omitempty"`
}

//+kubebuilder:object:root=true
// +kubebuilder:storageversion

// OCIManagedClusterList contains a list of OCIManagedCluster.
type OCIManagedClusterList struct {
        metav1.TypeMeta `json:",inline"`
        metav1.ListMeta `json:"metadata,omitempty"`
        Items           []OCIManagedCluster `json:"items"`
}

// GetConditions returns the list of conditions for an OCICluster API object.
func (c *OCIManagedCluster) GetConditions() clusterv1.Conditions <span class="cov8" title="1">{
        return c.Status.Conditions
}</span>

// SetConditions will set the given conditions on an OCICluster object.
func (c *OCIManagedCluster) SetConditions(conditions clusterv1.Conditions) <span class="cov8" title="1">{
        c.Status.Conditions = conditions
}</span>

func init() <span class="cov8" title="1">{
        SchemeBuilder.Register(&amp;OCIManagedCluster{}, &amp;OCIManagedClusterList{})
}</span>
</pre>
		
		<pre class="file" id="file26" style="display: none">/*
Copyright (c) 2021, 2022 Oracle and/or its affiliates.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1beta2

import (
        "context"
        "fmt"
        "reflect"

        "github.com/oracle/oci-go-sdk/v65/common"
        apierrors "k8s.io/apimachinery/pkg/api/errors"
        "k8s.io/apimachinery/pkg/runtime"
        "k8s.io/apimachinery/pkg/util/uuid"
        "k8s.io/apimachinery/pkg/util/validation/field"
        ctrl "sigs.k8s.io/controller-runtime"
        "sigs.k8s.io/controller-runtime/pkg/webhook"
        "sigs.k8s.io/controller-runtime/pkg/webhook/admission"
)

var managedclusterlogger = ctrl.Log.WithName("ocimanagedcluster-resource")

type OCIManagedClusterWebhook struct{}

var (
        _ webhook.CustomDefaulter = &amp;OCIManagedClusterWebhook{}
        _ webhook.CustomValidator = &amp;OCIManagedClusterWebhook{}
)

// +kubebuilder:webhook:verbs=create;update,path=/validate-infrastructure-cluster-x-k8s-io-v1beta2-ocimanagedcluster,mutating=false,failurePolicy=fail,matchPolicy=Equivalent,groups=infrastructure.cluster.x-k8s.io,resources=ocimanagedclusters,versions=v1beta2,name=validation.ocimanagedcluster.infrastructure.cluster.x-k8s.io,sideEffects=None,admissionReviewVersions=v1beta1
// +kubebuilder:webhook:verbs=create;update,path=/mutate-infrastructure-cluster-x-k8s-io-v1beta2-ocimanagedcluster,mutating=true,failurePolicy=fail,matchPolicy=Equivalent,groups=infrastructure.cluster.x-k8s.io,resources=ocimanagedclusters,versions=v1beta2,name=default.ocimanagedcluster.infrastructure.cluster.x-k8s.io,sideEffects=None,admissionReviewVersions=v1beta1

func (*OCIManagedClusterWebhook) Default(_ context.Context, obj runtime.Object) error <span class="cov8" title="1">{
        c, ok := obj.(*OCIManagedCluster)
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("expected an OCIManagedCluster object but got %T", c)
        }</span>

        <span class="cov8" title="1">if c.Spec.OCIResourceIdentifier == "" </span><span class="cov8" title="1">{
                c.Spec.OCIResourceIdentifier = string(uuid.NewUUID())
        }</span>
        <span class="cov8" title="1">if !c.Spec.NetworkSpec.SkipNetworkManagement </span><span class="cov8" title="1">{
                if len(c.Spec.NetworkSpec.Vcn.Subnets) == 0 </span><span class="cov8" title="1">{
                        subnets := make([]*Subnet, 4)
                        subnets[0] = &amp;Subnet{
                                Role: ControlPlaneEndpointRole,
                                Name: ControlPlaneEndpointDefaultName,
                                CIDR: ControlPlaneEndpointSubnetDefaultCIDR,
                                Type: Public,
                        }

                        subnets[1] = &amp;Subnet{
                                Role: ServiceLoadBalancerRole,
                                Name: ServiceLBDefaultName,
                                CIDR: ServiceLoadBalancerDefaultCIDR,
                                Type: Public,
                        }
                        subnets[2] = &amp;Subnet{
                                Role: WorkerRole,
                                Name: WorkerDefaultName,
                                CIDR: WorkerSubnetDefaultCIDR,
                                Type: Private,
                        }
                        subnets[3] = &amp;Subnet{
                                Role: PodRole,
                                Name: PodDefaultName,
                                CIDR: PodDefaultCIDR,
                                Type: Private,
                        }
                        c.Spec.NetworkSpec.Vcn.Subnets = subnets
                }</span>
                <span class="cov8" title="1">if len(c.Spec.NetworkSpec.Vcn.NetworkSecurityGroup.List) == 0 &amp;&amp; !c.Spec.NetworkSpec.Vcn.NetworkSecurityGroup.Skip </span><span class="cov8" title="1">{
                        nsgs := make([]*NSG, 4)
                        nsgs[0] = &amp;NSG{
                                Role:         ControlPlaneEndpointRole,
                                Name:         ControlPlaneEndpointDefaultName,
                                IngressRules: c.GetControlPlaneEndpointDefaultIngressRules(),
                                EgressRules:  c.GetControlPlaneEndpointDefaultEgressRules(),
                        }
                        nsgs[1] = &amp;NSG{
                                Role:         WorkerRole,
                                Name:         WorkerDefaultName,
                                IngressRules: c.GetWorkerDefaultIngressRules(),
                                EgressRules:  c.GetWorkerDefaultEgressRules(),
                        }
                        nsgs[2] = &amp;NSG{
                                Role:         ServiceLoadBalancerRole,
                                Name:         ServiceLBDefaultName,
                                IngressRules: c.GetLBServiceDefaultIngressRules(),
                                EgressRules:  c.GetLBServiceDefaultEgressRules(),
                        }
                        nsgs[3] = &amp;NSG{
                                Role:         PodRole,
                                Name:         PodDefaultName,
                                IngressRules: c.GetPodDefaultIngressRules(),
                                EgressRules:  c.GetPodDefaultEgressRules(),
                        }
                        c.Spec.NetworkSpec.Vcn.NetworkSecurityGroup.List = nsgs
                }</span>
                <span class="cov8" title="1">if c.Spec.NetworkSpec.Vcn.CIDR == "" </span><span class="cov8" title="1">{
                        c.Spec.NetworkSpec.Vcn.CIDR = VcnDefaultCidr
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func (c *OCIManagedCluster) SetupWebhookWithManager(mgr ctrl.Manager) error <span class="cov0" title="0">{
        w := new(OCIManagedClusterWebhook)
        return ctrl.NewWebhookManagedBy(mgr).
                For(c).
                WithDefaulter(w).
                WithValidator(w).
                Complete()
}</span>

// ValidateCreate implements webhook.Validator so a webhook will be registered for the type.
func (*OCIManagedClusterWebhook) ValidateCreate(_ context.Context, obj runtime.Object) (admission.Warnings, error) <span class="cov8" title="1">{
        c, ok := obj.(*OCIManagedCluster)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("expected an OCIManagedCluster object but got %T", c)
        }</span>
        <span class="cov8" title="1">managedclusterlogger.Info("validate create cluster", "name", c.Name)

        var allErrs field.ErrorList

        allErrs = append(allErrs, c.validate(nil)...)

        if len(allErrs) == 0 </span><span class="cov8" title="1">{
                return nil, nil
        }</span>

        <span class="cov8" title="1">return nil, apierrors.NewInvalid(c.GroupVersionKind().GroupKind(), c.Name, allErrs)</span>
}

// ValidateDelete implements webhook.Validator so a webhook will be registered for the type.
func (*OCIManagedClusterWebhook) ValidateDelete(_ context.Context, obj runtime.Object) (admission.Warnings, error) <span class="cov8" title="1">{
        c, ok := obj.(*OCIManagedCluster)
        if !ok </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("expected an OCIManagedCluster object but got %T", c)
        }</span>

        <span class="cov8" title="1">managedclusterlogger.Info("validate delete cluster", "name", c.Name)

        return nil, nil</span>
}

// ValidateUpdate implements webhook.Validator so a webhook will be registered for the type.
func (*OCIManagedClusterWebhook) ValidateUpdate(_ context.Context, oldRaw, newObj runtime.Object) (admission.Warnings, error) <span class="cov8" title="1">{
        c, ok := newObj.(*OCIManagedCluster)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("expected an OCIManagedCluster object but got %T", c)
        }</span>

        <span class="cov8" title="1">managedclusterlogger.Info("validate update cluster", "name", c.Name)

        var allErrs field.ErrorList

        oldCluster, ok := oldRaw.(*OCIManagedCluster)
        if !ok </span><span class="cov0" title="0">{
                return nil, apierrors.NewBadRequest(fmt.Sprintf("expected an OCIManagedCluster but got a %T", oldRaw))
        }</span>

        <span class="cov8" title="1">if c.Spec.Region != oldCluster.Spec.Region </span><span class="cov8" title="1">{
                allErrs = append(allErrs, field.Invalid(field.NewPath("spec", "region"), c.Spec.Region, "field is immutable"))
        }</span>

        <span class="cov8" title="1">if c.Spec.OCIResourceIdentifier != oldCluster.Spec.OCIResourceIdentifier </span><span class="cov8" title="1">{
                allErrs = append(allErrs, field.Invalid(field.NewPath("spec", "ociResourceIdentifier"), c.Spec.OCIResourceIdentifier, "field is immutable"))
        }</span>

        <span class="cov8" title="1">if c.Spec.CompartmentId != oldCluster.Spec.CompartmentId </span><span class="cov8" title="1">{
                allErrs = append(allErrs, field.Invalid(field.NewPath("spec", "compartmentId"), c.Spec.CompartmentId, "field is immutable"))
        }</span>

        <span class="cov8" title="1">allErrs = append(allErrs, c.validate(oldCluster)...)

        if len(allErrs) == 0 </span><span class="cov8" title="1">{
                return nil, nil
        }</span>

        <span class="cov8" title="1">return nil, apierrors.NewInvalid(c.GroupVersionKind().GroupKind(), c.Name, allErrs)</span>
}

func (c *OCIManagedCluster) validate(old *OCIManagedCluster) field.ErrorList <span class="cov8" title="1">{
        var allErrs field.ErrorList

        var oldNetworkSpec NetworkSpec
        if old != nil </span><span class="cov8" title="1">{
                oldNetworkSpec = old.Spec.NetworkSpec
        }</span>

        <span class="cov8" title="1">allErrs = append(allErrs, ValidateNetworkSpec(OCIManagedClusterSubnetRoles, c.Spec.NetworkSpec, oldNetworkSpec, field.NewPath("spec").Child("networkSpec"))...)
        allErrs = append(allErrs, ValidateClusterName(c.Name)...)

        if len(c.Spec.CompartmentId) &lt;= 0 </span><span class="cov8" title="1">{
                allErrs = append(
                        allErrs,
                        field.Invalid(field.NewPath("spec", "compartmentId"), c.Spec.CompartmentId, "field is required"))
        }</span>

        // Handle case where CompartmentId exists, but isn't valid
        // the separate "blank" check above is a more clear error for the user
        <span class="cov8" title="1">if len(c.Spec.CompartmentId) &gt; 0 &amp;&amp; !ValidOcid(c.Spec.CompartmentId) </span><span class="cov8" title="1">{
                allErrs = append(
                        allErrs,
                        field.Invalid(field.NewPath("spec", "compartmentId"), c.Spec.CompartmentId, "field is invalid"))
        }</span>

        <span class="cov8" title="1">if len(c.Spec.OCIResourceIdentifier) &lt;= 0 </span><span class="cov8" title="1">{
                allErrs = append(
                        allErrs,
                        field.Invalid(field.NewPath("spec", "ociResourceIdentifier"), c.Spec.OCIResourceIdentifier, "field is required"))
        }</span>

        <span class="cov8" title="1">if !ValidRegion(c.Spec.Region) </span><span class="cov8" title="1">{
                allErrs = append(
                        allErrs,
                        field.Invalid(field.NewPath("spec", "region"), c.Spec.Region, "field is invalid. See https://docs.oracle.com/en-us/iaas/Content/General/Concepts/regions.htm"))
        }</span>

        <span class="cov8" title="1">if !reflect.DeepEqual(c.Spec.NetworkSpec.APIServerLB, LoadBalancer{}) </span><span class="cov8" title="1">{
                allErrs = append(
                        allErrs,
                        field.Invalid(field.NewPath("spec", "networkSpec", "apiServerLoadBalancer"), c.Spec.NetworkSpec.APIServerLB, "cannot set loadbalancer in managed cluster"))
        }</span>

        <span class="cov8" title="1">if len(allErrs) == 0 </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">return allErrs</span>
}

func (c *OCIManagedCluster) GetControlPlaneEndpointDefaultIngressRules() []IngressSecurityRuleForNSG <span class="cov8" title="1">{
        return []IngressSecurityRuleForNSG{
                {
                        IngressSecurityRule: IngressSecurityRule{
                                Description: common.String("Kubernetes worker to Kubernetes API endpoint communication."),
                                Protocol:    common.String("6"),
                                TcpOptions: &amp;TcpOptions{
                                        DestinationPortRange: &amp;PortRange{
                                                Max: common.Int(6443),
                                                Min: common.Int(6443),
                                        },
                                },
                                SourceType: IngressSecurityRuleSourceTypeCidrBlock,
                                Source:     common.String(WorkerSubnetDefaultCIDR),
                        },
                },
                {
                        IngressSecurityRule: IngressSecurityRule{
                                Description: common.String("Kubernetes worker to Kubernetes API endpoint communication."),
                                Protocol:    common.String("6"),
                                TcpOptions: &amp;TcpOptions{
                                        DestinationPortRange: &amp;PortRange{
                                                Max: common.Int(12250),
                                                Min: common.Int(12250),
                                        },
                                },
                                SourceType: IngressSecurityRuleSourceTypeCidrBlock,
                                Source:     common.String(WorkerSubnetDefaultCIDR),
                        },
                },
                {
                        IngressSecurityRule: IngressSecurityRule{
                                Description: common.String("Path Discovery."),
                                Protocol:    common.String("1"),
                                IcmpOptions: &amp;IcmpOptions{
                                        Type: common.Int(3),
                                        Code: common.Int(4),
                                },
                                SourceType: IngressSecurityRuleSourceTypeCidrBlock,
                                Source:     common.String(WorkerSubnetDefaultCIDR),
                        },
                },
                {
                        IngressSecurityRule: IngressSecurityRule{
                                Description: common.String("Pod to Kubernetes API endpoint communication (when using VCN-native pod networking)."),
                                Protocol:    common.String("6"),
                                TcpOptions: &amp;TcpOptions{
                                        DestinationPortRange: &amp;PortRange{
                                                Max: common.Int(6443),
                                                Min: common.Int(6443),
                                        },
                                },
                                SourceType: IngressSecurityRuleSourceTypeCidrBlock,
                                Source:     common.String(PodDefaultCIDR),
                        },
                },
                {
                        IngressSecurityRule: IngressSecurityRule{
                                Description: common.String("Pod to Kubernetes API endpoint communication (when using VCN-native pod networking)."),
                                Protocol:    common.String("6"),
                                TcpOptions: &amp;TcpOptions{
                                        DestinationPortRange: &amp;PortRange{
                                                Max: common.Int(12250),
                                                Min: common.Int(12250),
                                        },
                                },
                                SourceType: IngressSecurityRuleSourceTypeCidrBlock,
                                Source:     common.String(PodDefaultCIDR),
                        },
                },
                {
                        IngressSecurityRule: IngressSecurityRule{
                                Description: common.String("External access to Kubernetes API endpoint."),
                                Protocol:    common.String("6"),
                                TcpOptions: &amp;TcpOptions{
                                        DestinationPortRange: &amp;PortRange{
                                                Max: common.Int(6443),
                                                Min: common.Int(6443),
                                        },
                                },
                                SourceType: IngressSecurityRuleSourceTypeCidrBlock,
                                Source:     common.String("0.0.0.0/0"),
                        },
                },
        }
}</span>

func (c *OCIManagedCluster) GetControlPlaneEndpointDefaultEgressRules() []EgressSecurityRuleForNSG <span class="cov8" title="1">{
        return []EgressSecurityRuleForNSG{
                {
                        EgressSecurityRule: EgressSecurityRule{
                                Description:     common.String("Allow Kubernetes API endpoint to communicate with OKE."),
                                Protocol:        common.String("6"),
                                DestinationType: EgressSecurityRuleDestinationTypeServiceCidrBlock,
                        },
                },
                {
                        EgressSecurityRule: EgressSecurityRule{
                                Description: common.String("Path Discovery."),
                                Protocol:    common.String("1"),
                                IcmpOptions: &amp;IcmpOptions{
                                        Type: common.Int(3),
                                        Code: common.Int(4),
                                },
                                DestinationType: EgressSecurityRuleDestinationTypeServiceCidrBlock,
                        },
                },
                {
                        EgressSecurityRule: EgressSecurityRule{
                                Description: common.String("Allow Kubernetes API endpoint to communicate with worker nodes."),
                                Protocol:    common.String("6"),
                                TcpOptions: &amp;TcpOptions{
                                        DestinationPortRange: &amp;PortRange{
                                                Max: common.Int(10250),
                                                Min: common.Int(10250),
                                        },
                                },
                                DestinationType: EgressSecurityRuleDestinationTypeCidrBlock,
                                Destination:     common.String(WorkerSubnetDefaultCIDR),
                        },
                },
                {
                        EgressSecurityRule: EgressSecurityRule{
                                Description: common.String("Path Discovery."),
                                Protocol:    common.String("1"),
                                IcmpOptions: &amp;IcmpOptions{
                                        Type: common.Int(3),
                                        Code: common.Int(4),
                                },
                                DestinationType: EgressSecurityRuleDestinationTypeCidrBlock,
                                Destination:     common.String(WorkerSubnetDefaultCIDR),
                        },
                },
                {
                        EgressSecurityRule: EgressSecurityRule{
                                Description:     common.String("Allow Kubernetes API endpoint to communicate with pods (when using VCN-native pod networking)."),
                                Protocol:        common.String("all"),
                                DestinationType: EgressSecurityRuleDestinationTypeCidrBlock,
                                Destination:     common.String(PodDefaultCIDR),
                        },
                },
        }
}</span>

func (c *OCIManagedCluster) GetWorkerDefaultIngressRules() []IngressSecurityRuleForNSG <span class="cov8" title="1">{
        return []IngressSecurityRuleForNSG{
                {
                        IngressSecurityRule: IngressSecurityRule{
                                Description: common.String("Allow Kubernetes API endpoint to communicate with worker nodes."),
                                Protocol:    common.String("6"),
                                TcpOptions: &amp;TcpOptions{
                                        DestinationPortRange: &amp;PortRange{
                                                Max: common.Int(10250),
                                                Min: common.Int(10250),
                                        },
                                },
                                SourceType: IngressSecurityRuleSourceTypeCidrBlock,
                                Source:     common.String(ControlPlaneEndpointSubnetDefaultCIDR),
                        },
                },
                {
                        IngressSecurityRule: IngressSecurityRule{
                                Description: common.String("Path Discovery."),
                                Protocol:    common.String("1"),
                                IcmpOptions: &amp;IcmpOptions{
                                        Type: common.Int(3),
                                        Code: common.Int(4),
                                },
                                SourceType: IngressSecurityRuleSourceTypeCidrBlock,
                                Source:     common.String("0.0.0.0/0"),
                        },
                },
                {
                        IngressSecurityRule: IngressSecurityRule{
                                Description: common.String("Load Balancer to Worker nodes node ports."),
                                Protocol:    common.String("6"),
                                TcpOptions: &amp;TcpOptions{
                                        DestinationPortRange: &amp;PortRange{
                                                Max: common.Int(32767),
                                                Min: common.Int(30000),
                                        },
                                },
                                SourceType: IngressSecurityRuleSourceTypeCidrBlock,
                                Source:     common.String(ServiceLoadBalancerDefaultCIDR),
                        },
                },
        }
}</span>

func (c *OCIManagedCluster) GetWorkerDefaultEgressRules() []EgressSecurityRuleForNSG <span class="cov8" title="1">{
        return []EgressSecurityRuleForNSG{
                {
                        EgressSecurityRule: EgressSecurityRule{
                                Description:     common.String("Allow worker nodes to communicate with OKE."),
                                Protocol:        common.String("6"),
                                DestinationType: EgressSecurityRuleDestinationTypeServiceCidrBlock,
                        },
                },
                {
                        EgressSecurityRule: EgressSecurityRule{
                                Description:     common.String("Allow worker nodes to access pods."),
                                Protocol:        common.String("all"),
                                DestinationType: EgressSecurityRuleDestinationTypeCidrBlock,
                                Destination:     common.String(PodDefaultCIDR),
                        },
                },
                {
                        EgressSecurityRule: EgressSecurityRule{
                                Description: common.String("Path Discovery."),
                                Protocol:    common.String("1"),
                                IcmpOptions: &amp;IcmpOptions{
                                        Type: common.Int(3),
                                        Code: common.Int(4),
                                },
                                DestinationType: EgressSecurityRuleDestinationTypeCidrBlock,
                                Destination:     common.String("0.0.0.0/0"),
                        },
                },
                {
                        EgressSecurityRule: EgressSecurityRule{
                                Description: common.String("Kubernetes worker to Kubernetes API endpoint communication."),
                                Protocol:    common.String("6"),
                                TcpOptions: &amp;TcpOptions{
                                        DestinationPortRange: &amp;PortRange{
                                                Max: common.Int(6443),
                                                Min: common.Int(6443),
                                        },
                                },
                                DestinationType: EgressSecurityRuleDestinationTypeCidrBlock,
                                Destination:     common.String(ControlPlaneEndpointSubnetDefaultCIDR),
                        },
                },
                {
                        EgressSecurityRule: EgressSecurityRule{
                                Description: common.String("Kubernetes worker to Kubernetes API endpoint communication."),
                                Protocol:    common.String("6"),
                                TcpOptions: &amp;TcpOptions{
                                        DestinationPortRange: &amp;PortRange{
                                                Max: common.Int(12250),
                                                Min: common.Int(12250),
                                        },
                                },
                                DestinationType: EgressSecurityRuleDestinationTypeCidrBlock,
                                Destination:     common.String(ControlPlaneEndpointSubnetDefaultCIDR),
                        },
                },
        }
}</span>

func (c *OCIManagedCluster) GetPodDefaultIngressRules() []IngressSecurityRuleForNSG <span class="cov8" title="1">{
        return []IngressSecurityRuleForNSG{
                {
                        IngressSecurityRule: IngressSecurityRule{
                                Description: common.String("Allow worker nodes to access pods."),
                                Protocol:    common.String("all"),
                                SourceType:  IngressSecurityRuleSourceTypeCidrBlock,
                                Source:      common.String(WorkerSubnetDefaultCIDR),
                        },
                },
                {
                        IngressSecurityRule: IngressSecurityRule{
                                Description: common.String("Allow Kubernetes API endpoint to communicate with pods."),
                                Protocol:    common.String("all"),
                                SourceType:  IngressSecurityRuleSourceTypeCidrBlock,
                                Source:      common.String(ControlPlaneEndpointSubnetDefaultCIDR),
                        },
                },
                {
                        IngressSecurityRule: IngressSecurityRule{
                                Description: common.String("Allow pods to communicate with other pods."),
                                Protocol:    common.String("all"),
                                SourceType:  IngressSecurityRuleSourceTypeCidrBlock,
                                Source:      common.String(PodDefaultCIDR),
                        },
                },
        }
}</span>

func (c *OCIManagedCluster) GetPodDefaultEgressRules() []EgressSecurityRuleForNSG <span class="cov8" title="1">{
        return []EgressSecurityRuleForNSG{
                {
                        EgressSecurityRule: EgressSecurityRule{
                                Description:     common.String("Allow worker nodes to communicate with OCI Services."),
                                Protocol:        common.String("6"),
                                DestinationType: EgressSecurityRuleDestinationTypeServiceCidrBlock,
                        },
                },
                {
                        EgressSecurityRule: EgressSecurityRule{
                                Description: common.String("Path Discovery."),
                                Protocol:    common.String("1"),
                                IcmpOptions: &amp;IcmpOptions{
                                        Type: common.Int(3),
                                        Code: common.Int(4),
                                },
                                DestinationType: EgressSecurityRuleDestinationTypeServiceCidrBlock,
                        },
                },
                {
                        EgressSecurityRule: EgressSecurityRule{
                                Description:     common.String("Allow pods to communicate with other pods."),
                                Protocol:        common.String("all"),
                                DestinationType: EgressSecurityRuleDestinationTypeCidrBlock,
                                Destination:     common.String(PodDefaultCIDR),
                        },
                },
                {
                        EgressSecurityRule: EgressSecurityRule{
                                Description: common.String("Pod to Kubernetes API endpoint communication (when using VCN-native pod networking)."),
                                Protocol:    common.String("6"),
                                TcpOptions: &amp;TcpOptions{
                                        DestinationPortRange: &amp;PortRange{
                                                Max: common.Int(6443),
                                                Min: common.Int(6443),
                                        },
                                },
                                DestinationType: EgressSecurityRuleDestinationTypeCidrBlock,
                                Destination:     common.String(ControlPlaneEndpointSubnetDefaultCIDR),
                        },
                },
                {
                        EgressSecurityRule: EgressSecurityRule{
                                Description: common.String("Pod to Kubernetes API endpoint communication (when using VCN-native pod networking)."),
                                Protocol:    common.String("6"),
                                TcpOptions: &amp;TcpOptions{
                                        DestinationPortRange: &amp;PortRange{
                                                Max: common.Int(12250),
                                                Min: common.Int(12250),
                                        },
                                },
                                DestinationType: EgressSecurityRuleDestinationTypeCidrBlock,
                                Destination:     common.String(ControlPlaneEndpointSubnetDefaultCIDR),
                        },
                },
        }
}</span>

func (c *OCIManagedCluster) GetLBServiceDefaultIngressRules() []IngressSecurityRuleForNSG <span class="cov8" title="1">{
        return []IngressSecurityRuleForNSG{
                {
                        IngressSecurityRule: IngressSecurityRule{
                                Description: common.String("Accept http traffic on port 80"),
                                Protocol:    common.String("6"),
                                TcpOptions: &amp;TcpOptions{
                                        DestinationPortRange: &amp;PortRange{
                                                Max: common.Int(80),
                                                Min: common.Int(80),
                                        },
                                },
                                SourceType: IngressSecurityRuleSourceTypeCidrBlock,
                                Source:     common.String("0.0.0.0/0"),
                        },
                },
                {
                        IngressSecurityRule: IngressSecurityRule{
                                Description: common.String("Accept https traffic on port 443"),
                                Protocol:    common.String("6"),
                                TcpOptions: &amp;TcpOptions{
                                        DestinationPortRange: &amp;PortRange{
                                                Max: common.Int(443),
                                                Min: common.Int(443),
                                        },
                                },
                                SourceType: IngressSecurityRuleSourceTypeCidrBlock,
                                Source:     common.String("0.0.0.0/0"),
                        },
                },
        }
}</span>

func (c *OCIManagedCluster) GetLBServiceDefaultEgressRules() []EgressSecurityRuleForNSG <span class="cov8" title="1">{
        // TODO add service gateway rules
        return []EgressSecurityRuleForNSG{
                {
                        EgressSecurityRule: EgressSecurityRule{
                                Description: common.String("Load Balancer to Worker nodes node ports."),
                                Protocol:    common.String("6"),
                                TcpOptions: &amp;TcpOptions{
                                        DestinationPortRange: &amp;PortRange{
                                                Max: common.Int(32767),
                                                Min: common.Int(30000),
                                        },
                                },
                                DestinationType: EgressSecurityRuleDestinationTypeCidrBlock,
                                Destination:     common.String(WorkerSubnetDefaultCIDR),
                        },
                },
        }
}</span>
</pre>
		
		<pre class="file" id="file27" style="display: none">/*
Copyright (c) 2022, Oracle and/or its affiliates.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1beta2

import (
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

// OCIManagedClusterTemplateSpec defines the desired state of OCIManagedClusterTemplate.
type OCIManagedClusterTemplateSpec struct {
        Template OCIManagedClusterTemplateResource `json:"template"`
}

// +kubebuilder:object:root=true
// +kubebuilder:resource:path=ocimanagedclustertemplates,scope=Namespaced,categories=cluster-api
// +kubebuilder:storageversion

// OCIManagedClusterTemplate is the Schema for the ocimanagedclustertemplates API.
type OCIManagedClusterTemplate struct {
        metav1.TypeMeta   `json:",inline"`
        metav1.ObjectMeta `json:"metadata,omitempty"`

        Spec OCIManagedClusterTemplateSpec `json:"spec,omitempty"`
}

// +kubebuilder:object:root=true
// +kubebuilder:storageversion

// OCIManagedClusterTemplateList contains a list of OCIManagedClusterTemplate.
type OCIManagedClusterTemplateList struct {
        metav1.TypeMeta `json:",inline"`
        metav1.ListMeta `json:"metadata,omitempty"`

        Items []OCIManagedClusterTemplate `json:"items"`
}

func init() <span class="cov8" title="1">{
        SchemeBuilder.Register(&amp;OCIManagedClusterTemplate{}, &amp;OCIManagedClusterTemplateList{})
}</span>

// OCIManagedClusterSpec describes the data needed to create an OCIManagedCluster from a template.
type OCIManagedClusterTemplateResource struct {
        Spec OCIManagedClusterSpec `json:"spec"`
}
</pre>
		
		<pre class="file" id="file28" style="display: none">/*
Copyright (c) 2021, 2022 Oracle and/or its affiliates.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1beta2

import (
        "github.com/oracle/oci-go-sdk/v65/containerengine"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        clusterv1 "sigs.k8s.io/cluster-api/api/core/v1beta1"
)

const (
        // ControlPlaneFinalizer allows OCIManagedControlPlaneFinalizer to clean up OCI resources associated with control plane
        // of OCIManagedControlPlane
        ControlPlaneFinalizer = "ocimanagedcontrolplane.infrastructure.cluster.x-k8s.io"
)

const (
        BasicClusterType    ClusterTypeEnum = "BASIC_CLUSTER"
        EnhancedClusterType ClusterTypeEnum = "ENHANCED_CLUSTER"
)

type ClusterTypeEnum string

// OCIManagedControlPlaneSpec defines the desired state of OCIManagedControlPlane.
// The properties are generated from https://docs.oracle.com/en-us/iaas/api/#/en/containerengine/20180222/datatypes/CreateClusterDetails
type OCIManagedControlPlaneSpec struct {
        // ID of the OKEcluster.
        // +optional
        ID *string `json:"id,omitempty"`

        // ClusterPodNetworkOptions defines the available CNIs and network options for existing and new node pools of the cluster
        // +optional
        ClusterPodNetworkOptions []ClusterPodNetworkOptions `json:"clusterPodNetworkOptions,omitempty"`

        // ImagePolicyConfig defines the properties that define a image verification policy.
        // +optional
        ImagePolicyConfig *ImagePolicyConfig `json:"imagePolicyConfig,omitempty"`

        // ClusterOptions defines Optional attributes for the cluster.
        // +optional
        ClusterOption ClusterOptions `json:"clusterOptions,omitempty"`

        // ClusterTypeEnum defines the type of cluster. Supported types are
        // * `BASIC_CLUSTER`
        // * `ENHANCED_CLUSTER`
        // +optional
        ClusterType ClusterTypeEnum `json:"clusterType,omitempty"`

        // KmsKeyId defines the OCID of the KMS key to be used as the master encryption key for Kubernetes secret encryption. When used,
        // +optional
        KmsKeyId *string `json:"kmsKeyId,omitempty"`

        // ControlPlaneEndpoint represents the endpoint used to communicate with the control plane.
        // +optional
        ControlPlaneEndpoint clusterv1.APIEndpoint `json:"controlPlaneEndpoint"`

        // The list of addons to be applied to the OKE cluster.
        // +optional
        // +listType=map
        // +listMapKey=name
        Addons []Addon `json:"addons,omitempty"`

        // Version represents the version of the Kubernetes Cluster Control Plane.
        Version *string `json:"version,omitempty"`
}

// ClusterPodNetworkOptions defines the available CNIs and network options for existing and new node pools of the cluster
type ClusterPodNetworkOptions struct {

        // The CNI to be used are OCI_VCN_IP_NATIVE and FLANNEL_OVERLAY
        CniType CNIOptionEnum `json:"cniType,omitempty"`
}

// EndpointConfig defines the network configuration for access to the Cluster control plane.
type EndpointConfig struct {
        // Flag to enable public endpoint address for the OKE cluster.
        // If not set, will calculate this using endpoint subnet type.
        // +optional
        IsPublicIpEnabled bool `json:"isPublicIpEnabled,omitempty"`
}

// ImagePolicyConfig defines the properties that define a image verification policy.
type ImagePolicyConfig struct {

        // IsPolicyEnabled defines Whether the image verification policy is enabled.
        // +optional
        IsPolicyEnabled *bool `json:"isPolicyEnabled,omitempty"`

        // KeyDetails defines a list of KMS key details.
        // +optional
        KeyDetails []KeyDetails `json:"keyDetails,omitempty"`
}

// KeyDetails defines the properties that define the kms keys used by OKE for Image Signature verification.
type KeyDetails struct {

        // KmsKeyId defines the OCID of the KMS key that will be used to verify whether the images are signed by an approved source.
        // +optional
        KmsKeyId *string `json:"keyDetails,omitempty"`
}

// ClusterOptions defines Optional attributes for the cluster.
type ClusterOptions struct {

        // AddOnOptions defines the properties that define options for supported add-ons.
        // +optional
        AddOnOptions *AddOnOptions `json:"addOnOptions,omitempty"`

        // AdmissionControllerOptions defines the properties that define supported admission controllers.
        // +optional
        AdmissionControllerOptions *AdmissionControllerOptions `json:"admissionControllerOptions,omitempty"`

        // OpenIDConnectDiscovery specifies OIDC discovery settings
        // +optional
        OpenIdConnectDiscovery *OpenIDConnectDiscovery `json:"openIdConnectDiscovery,omitempty"`

        //OpenIDConnectTokenAuthenticationConfig
        // +optional
        OpenIdConnectTokenAuthenticationConfig *OpenIDConnectTokenAuthenticationConfig `json:"openIdConnectTokenAuthenticationConfig,omitempty"`
}

type OpenIDConnectDiscovery struct {
        // IsOpenIDConnectDiscoveryEnabled defines whether or not to enable the OIDC discovery.
        // +optional
        IsOpenIdConnectDiscoveryEnabled *bool `json:"isOpenIdConnectDiscoveryEnabled,omitempty"`
}

type OpenIDConnectTokenAuthenticationConfig struct {
        // A Base64 encoded public RSA or ECDSA certificates used to sign your identity provider's web certificate.
        // +optional
        CaCertificate *string `json:"caCertificate,omitempty"`

        // A client id that all tokens must be issued for.
        // +optional
        ClientId *string `json:"clientId,omitempty"`

        // JWT claim to use as the user's group. If the claim is present it must be an array of strings.
        // +optional
        GroupsClaim *string `json:"groupsClaim,omitempty"`

        // Prefix prepended to group claims to prevent clashes with existing names (such as system:groups).
        // +optional
        GroupsPrefix *string `json:"groupsPrefix,omitempty"`

        // IsOpenIdConnectAuthEnabled defines whether or not to enable the OIDC authentication.
        IsOpenIdConnectAuthEnabled bool `json:"isOpenIdConnectAuthEnabled"`

        // URL of the provider that allows the API server to discover public signing keys. Only URLs that use the https:// scheme are accepted. This is typically the provider's discovery URL, changed to have an empty path.
        // +optional
        IssuerUrl *string `json:"issuerUrl,omitempty"`

        // A key=value pair that describes a required claim in the ID Token. If set, the claim is verified to be present in the ID Token with a matching value. Repeat this flag to specify multiple claims.
        // +optional
        RequiredClaims []KeyValue `json:"requiredClaims,omitempty"`

        // The signing algorithms accepted. Default is ["RS256"].
        // +optional
        SigningAlgorithms []string `json:"signingAlgorithms,omitempty"`

        // JWT claim to use as the user name. By default sub, which is expected to be a unique identifier of the end user. Admins can choose other claims, such as email or name, depending on their provider. However, claims other than email will be prefixed with the issuer URL to prevent naming clashes with other plugins.
        // +optional
        UsernameClaim *string `json:"usernameClaim,omitempty"`

        // Prefix prepended to username claims to prevent clashes with existing names (such as system:users). For example, the value oidc: will create usernames like oidc:jane.doe. If this flag isn't provided and --oidc-username-claim is a value other than email the prefix defaults to ( Issuer URL )# where ( Issuer URL ) is the value of --oidc-issuer-url. The value - can be used to disable all prefixing.
        // +optional
        UsernamePrefix *string `json:"usernamePrefix,omitempty"`
}

// KeyValue defines the properties that define a key value pair. This is alias to containerengine.KeyValue, to support the sdk type
type KeyValue containerengine.KeyValue

// AddOnOptions defines the properties that define options for supported add-ons.
type AddOnOptions struct {
        // IsKubernetesDashboardEnabled defines whether or not to enable the Kubernetes Dashboard add-on.
        // +optional
        IsKubernetesDashboardEnabled *bool `json:"isKubernetesDashboardEnabled,omitempty"`

        // IsKubernetesDashboardEnabled defines whether or not to enable the Tiller add-on.
        // +optional
        IsTillerEnabled *bool `json:"isTillerEnabled,omitempty"`
}

// AdmissionControllerOptions defines the properties that define supported admission controllers.
type AdmissionControllerOptions struct {

        // IsPodSecurityPolicyEnabled defines whether or not to enable the Pod Security Policy admission controller.
        // +optional
        IsPodSecurityPolicyEnabled *bool `json:"isPodSecurityPolicyEnabled,omitempty"`
}

// KubernetesNetworkConfig defines the properties that define the network configuration for Kubernetes.
type KubernetesNetworkConfig struct {

        // PodsCidr defines the CIDR block for Kubernetes pods. Optional, defaults to 10.244.0.0/16.
        // +optional
        PodsCidr string `json:"isPodSecurityPolicyEnabled,omitempty"`

        // PodsCidr defines the CIDR block for Kubernetes services. Optional, defaults to 10.96.0.0/16.
        // +optional
        ServicesCidr string `json:"servicesCidr,omitempty"`
}

// OCIManagedControlPlaneStatus defines the observed state of OCIManagedControlPlane
type OCIManagedControlPlaneStatus struct {
        // +optional
        Ready bool `json:"ready"`
        // NetworkSpec encapsulates all things related to OCI network.
        // +optional
        Conditions clusterv1.Conditions `json:"conditions,omitempty"`

        // Version represents the current Kubernetes version for the control plane.
        // +optional
        Version *string `json:"version,omitempty"`

        // AddonStatus represents the status of the addon.
        // +optional
        AddonStatus map[string]AddonStatus `json:"addonStatus,omitempty"`

        // Initialized denotes whether or not the control plane has the
        // uploaded kubernetes config-map.
        // +optional
        Initialized bool `json:"initialized"`
}

// Addon defines the properties of an addon.
type Addon struct {
        // Name represents the name of the addon.
        Name *string `json:"name"`

        // Version represents the version of the addon.
        // +optional
        Version *string `json:"version,omitempty"`

        // Configurations defines a list of configurations of the addon.
        // +optional
        Configurations []AddonConfiguration `json:"configurations,omitempty"`
}

// AddonConfiguration defines a configuration of an addon.
type AddonConfiguration struct {
        // The key of the configuration.
        Key *string `json:"key,omitempty"`

        // The value of the configuration.
        Value *string `json:"value,omitempty"`
}

// AddonStatus defines the status of an Addon.
type AddonStatus struct {
        // Version represents the version of the addon.
        // +optional
        CurrentlyInstalledVersion *string `json:"currentlyInstalledVersion,omitempty"`

        // AddonError defines the error encountered by the Addon.
        // +optional
        AddonError *AddonError `json:"addonError,omitempty"`

        // LifecycleState defines the lifecycle state of the addon.
        // +optional
        LifecycleState *string `json:"lifecycleState,omitempty"`
}

type AddonError struct {
        // Code defines a  short error code that defines the upstream error, meant for programmatic parsing.
        // +optional
        Code *string `json:"code,omitempty"`

        // Message defines a human-readable error string of the upstream error.
        // +optional
        Message *string `json:"message,omitempty"`

        // Status defines the status of the HTTP response encountered in the upstream error.
        // +optional
        Status *string `json:"status,omitempty"`
}

//+kubebuilder:object:root=true
//+kubebuilder:subresource:status
// +kubebuilder:storageversion

// OCIManagedControlPlane is the Schema for the ocimanagedcontrolplane API.
type OCIManagedControlPlane struct {
        metav1.TypeMeta   `json:",inline"`
        metav1.ObjectMeta `json:"metadata,omitempty"`

        Spec   OCIManagedControlPlaneSpec   `json:"spec,omitempty"`
        Status OCIManagedControlPlaneStatus `json:"status,omitempty"`
}

//+kubebuilder:object:root=true
// +kubebuilder:storageversion

// OCIManagedControlPlaneList contains a list of OCIManagedControlPlane.
type OCIManagedControlPlaneList struct {
        metav1.TypeMeta `json:",inline"`
        metav1.ListMeta `json:"metadata,omitempty"`
        Items           []OCIManagedControlPlane `json:"items"`
}

// GetConditions returns the list of conditions for an OCICluster API object.
func (c *OCIManagedControlPlane) GetConditions() clusterv1.Conditions <span class="cov8" title="1">{
        return c.Status.Conditions
}</span>

// SetConditions will set the given conditions on an OCICluster object.
func (c *OCIManagedControlPlane) SetConditions(conditions clusterv1.Conditions) <span class="cov8" title="1">{
        c.Status.Conditions = conditions
}</span>

// SetAddonStatus sets the addon status in the OCIManagedControlPlane
func (c *OCIManagedControlPlane) SetAddonStatus(name string, status AddonStatus) <span class="cov8" title="1">{
        if c.Status.AddonStatus == nil </span><span class="cov8" title="1">{
                c.Status.AddonStatus = make(map[string]AddonStatus)
        }</span>
        <span class="cov8" title="1">c.Status.AddonStatus[name] = status</span>
}

// RemoveAddonStatus removes the addon status from OCIManagedControlPlane
func (c *OCIManagedControlPlane) RemoveAddonStatus(name string) <span class="cov0" title="0">{
        if c.Status.AddonStatus == nil </span><span class="cov0" title="0">{
                c.Status.AddonStatus = make(map[string]AddonStatus)
        }</span>
        <span class="cov0" title="0">delete(c.Status.AddonStatus, name)</span>
}

func init() <span class="cov8" title="1">{
        SchemeBuilder.Register(&amp;OCIManagedControlPlane{}, &amp;OCIManagedControlPlaneList{})
}</span>
</pre>
		
		<pre class="file" id="file29" style="display: none">/*
Copyright (c) 2021, 2022 Oracle and/or its affiliates.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1beta2

import (
        "context"
        "fmt"

        apierrors "k8s.io/apimachinery/pkg/api/errors"
        "k8s.io/apimachinery/pkg/runtime"
        "k8s.io/apimachinery/pkg/util/validation/field"
        ctrl "sigs.k8s.io/controller-runtime"
        "sigs.k8s.io/controller-runtime/pkg/webhook"
        "sigs.k8s.io/controller-runtime/pkg/webhook/admission"
)

var managedcplanelogger = ctrl.Log.WithName("ocimanagedcontrolplane-resource")

type OCIManagedControlPlaneWebhook struct{}

var (
        _ webhook.CustomDefaulter = &amp;OCIManagedControlPlaneWebhook{}
        _ webhook.CustomValidator = &amp;OCIManagedControlPlaneWebhook{}
)

// +kubebuilder:webhook:verbs=create;update,path=/validate-infrastructure-cluster-x-k8s-io-v1beta2-ocimanagedcontrolplane,mutating=false,failurePolicy=fail,matchPolicy=Equivalent,groups=infrastructure.cluster.x-k8s.io,resources=ocimanagedcontrolplanes,versions=v1beta2,name=validation.ocimanagedcontrolplane.infrastructure.cluster.x-k8s.io,sideEffects=None,admissionReviewVersions=v1beta1
// +kubebuilder:webhook:verbs=create;update,path=/mutate-infrastructure-cluster-x-k8s-io-v1beta2-ocimanagedcontrolplane,mutating=true,failurePolicy=fail,matchPolicy=Equivalent,groups=infrastructure.cluster.x-k8s.io,resources=ocimanagedcontrolplanes,versions=v1beta2,name=default.ocimanagedcontrolplane.infrastructure.cluster.x-k8s.io,sideEffects=None,admissionReviewVersions=v1beta1

func (*OCIManagedControlPlaneWebhook) Default(_ context.Context, obj runtime.Object) error <span class="cov8" title="1">{
        c, ok := obj.(*OCIManagedControlPlane)
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("expected an OCIManagedControlPlane object but got %T", c)
        }</span>

        <span class="cov8" title="1">if len(c.Spec.ClusterPodNetworkOptions) == 0 </span><span class="cov8" title="1">{
                c.Spec.ClusterPodNetworkOptions = []ClusterPodNetworkOptions{
                        {
                                CniType: VCNNativeCNI,
                        },
                }
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (c *OCIManagedControlPlane) SetupWebhookWithManager(mgr ctrl.Manager) error <span class="cov0" title="0">{
        w := new(OCIManagedControlPlaneWebhook)
        return ctrl.NewWebhookManagedBy(mgr).
                For(c).
                WithDefaulter(w).
                WithValidator(w).
                Complete()
}</span>

func (*OCIManagedControlPlaneWebhook) ValidateCreate(_ context.Context, obj runtime.Object) (admission.Warnings, error) <span class="cov8" title="1">{
        c, ok := obj.(*OCIManagedControlPlane)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("expected an OCIManagedControlPlane object but got %T", c)
        }</span>

        <span class="cov8" title="1">var allErrs field.ErrorList
        if len(c.Name) &gt; 31 </span><span class="cov8" title="1">{
                allErrs = append(allErrs, field.Invalid(field.NewPath("Name"), c.Name, "Name cannot be more than 31 characters"))
        }</span>

        <span class="cov8" title="1">if c.Spec.ClusterOption.OpenIdConnectTokenAuthenticationConfig != nil &amp;&amp; c.Spec.ClusterOption.OpenIdConnectTokenAuthenticationConfig.IsOpenIdConnectAuthEnabled </span><span class="cov8" title="1">{
                if c.Spec.ClusterType != EnhancedClusterType </span><span class="cov8" title="1">{
                        allErrs = append(allErrs, field.Invalid(field.NewPath("ClusterType"), c.Spec.ClusterType, "ClusterType needs to be set to ENHANCED_CLUSTER for OpenIdConnectTokenAuthenticationConfig to be enabled."))
                }</span>
                <span class="cov8" title="1">if c.Spec.ClusterOption.OpenIdConnectTokenAuthenticationConfig.ClientId == nil </span><span class="cov8" title="1">{
                        allErrs = append(allErrs, field.Invalid(field.NewPath("ClientId"), c.Spec.ClusterOption.OpenIdConnectTokenAuthenticationConfig.ClientId, "ClientId cannot be empty when OpenIdConnectAuth is enabled."))
                }</span>
                <span class="cov8" title="1">if c.Spec.ClusterOption.OpenIdConnectTokenAuthenticationConfig.IssuerUrl == nil </span><span class="cov8" title="1">{
                        allErrs = append(allErrs, field.Invalid(field.NewPath("IssuerUrl "), c.Spec.ClusterOption.OpenIdConnectTokenAuthenticationConfig.IssuerUrl, "IssuerUrl cannot be empty when OpenIdConnectAuth is enabled."))
                }</span>
        }
        <span class="cov8" title="1">if len(allErrs) == 0 </span><span class="cov8" title="1">{
                return nil, nil
        }</span>
        <span class="cov8" title="1">return nil, apierrors.NewInvalid(c.GroupVersionKind().GroupKind(), c.Name, allErrs)</span>
}

func (*OCIManagedControlPlaneWebhook) ValidateUpdate(_ context.Context, oldRaw, newObj runtime.Object) (admission.Warnings, error) <span class="cov0" title="0">{
        return nil, nil
}</span>

func (*OCIManagedControlPlaneWebhook) ValidateDelete(_ context.Context, obj runtime.Object) (admission.Warnings, error) <span class="cov8" title="1">{
        return nil, nil
}</span>
</pre>
		
		<pre class="file" id="file30" style="display: none">/*
Copyright (c) 2022, Oracle and/or its affiliates.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1beta2

import (
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

// OCIManagedControlPlaneTemplateSpec defines the desired state of OCIManagedControlPlaneTemplate.
type OCIManagedControlPlaneTemplateSpec struct {
        Template OCIManagedControlPlaneTemplateResource `json:"template"`
}

// +kubebuilder:object:root=true
// +kubebuilder:resource:path=ocimanagedcontrolplanetemplates,scope=Namespaced,categories=cluster-api
// +kubebuilder:storageversion

// OCIManagedControlPlaneTemplate is the Schema for the OCIManagedControlPlaneTemplates API.
type OCIManagedControlPlaneTemplate struct {
        metav1.TypeMeta   `json:",inline"`
        metav1.ObjectMeta `json:"metadata,omitempty"`

        Spec OCIManagedControlPlaneTemplateSpec `json:"spec,omitempty"`
}

// +kubebuilder:object:root=true
// +kubebuilder:storageversion

// OCIManagedControlPlaneTemplateList contains a list of OCIManagedControlPlaneTemplate.
type OCIManagedControlPlaneTemplateList struct {
        metav1.TypeMeta `json:",inline"`
        metav1.ListMeta `json:"metadata,omitempty"`

        Items []OCIManagedControlPlaneTemplate `json:"items"`
}

func init() <span class="cov8" title="1">{
        SchemeBuilder.Register(&amp;OCIManagedControlPlaneTemplate{}, &amp;OCIManagedControlPlaneTemplateList{})
}</span>

// OCIManagedControlPlaneSpec describes the data needed to create an OCIManagedControlPlane from a template.
type OCIManagedControlPlaneTemplateResource struct {
        Spec OCIManagedControlPlaneSpec `json:"spec"`
}
</pre>
		
		<pre class="file" id="file31" style="display: none">/*
 *
 * Copyright (c) 2022, Oracle and/or its affiliates.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * /
 *
 */

package v1beta2

import (
        "fmt"
        "net"
        "regexp"

        "github.com/oracle/cluster-api-provider-oci/cloud/ociutil"
        "k8s.io/apimachinery/pkg/util/validation/field"
)

const (
        // can't use: \/"'[]:|&lt;&gt;+=;,.?*@&amp;, Can't start with underscore. Can't end with period or hyphen.
        // not using . in the name to avoid issues when the name is part of DNS name.
        clusterNameRegex = `^[a-z0-9][a-z0-9-]{0,42}[a-z0-9]$`

        // Rule type constants for error messages
        egressRulesType  = "egressRules"
        ingressRulesType = "ingressRules"

        // Error message formats for NSG security rule validation
        udpDestinationPortRangeMaxRequiredFormat = "invalid %s: UdpOptions DestinationPortRange Max may not be empty"
        udpDestinationPortRangeMinRequiredFormat = "invalid %s: UdpOptions DestinationPortRange Min may not be empty"
        udpSourcePortRangeMaxRequiredFormat      = "invalid %s: UdpOptions SourcePortRange Max may not be empty"
        udpSourcePortRangeMinRequiredFormat      = "invalid %s: UdpOptions SourcePortRange Min may not be empty"
        tcpDestinationPortRangeMaxRequiredFormat = "invalid %s: TcpOptions DestinationPortRange Max may not be empty"
        tcpDestinationPortRangeMinRequiredFormat = "invalid %s: TcpOptions DestinationPortRange Min may not be empty"
        tcpSourcePortRangeMaxRequiredFormat      = "invalid %s: TcpOptions SourcePortRange Max may not be empty"
        tcpSourcePortRangeMinRequiredFormat      = "invalid %s: TcpOptions SourcePortRange Min may not be empty"
        icmpTypeRequiredFormat                   = "invalid %s: IcmpOptions Type may not be empty"
        destinationRequiredFormat                = "invalid %s: Destination may not be empty"
        sourceRequiredFormat                     = "invalid %s: Source may not be empty"
        protocolRequiredFormat                   = "invalid %s: Protocol may not be empty"
        invalidCIDRFormatFormat                  = "invalid %s: CIDR format"
)

// invalidNameRegex is a broad regex used to validate allows names in OCI
var invalidNameRegex = regexp.MustCompile("\\s")

// validatePortRange validates that both Min and Max are set for a port range
func validatePortRange(portRange *PortRange, fldPath *field.Path, maxMsg, minMsg string) field.ErrorList <span class="cov8" title="1">{
        var allErrs field.ErrorList
        if portRange.Max == nil </span><span class="cov8" title="1">{
                allErrs = append(allErrs, field.Invalid(fldPath, portRange.Max, maxMsg))
        }</span>
        <span class="cov8" title="1">if portRange.Min == nil </span><span class="cov8" title="1">{
                allErrs = append(allErrs, field.Invalid(fldPath, portRange.Min, minMsg))
        }</span>
        <span class="cov8" title="1">return allErrs</span>
}

// validateCIDR validates a CIDR string
func validateCIDR(cidr *string, fldPath *field.Path, errorMsg string) field.ErrorList <span class="cov8" title="1">{
        var allErrs field.ErrorList
        if _, _, err := net.ParseCIDR(ociutil.DerefString(cidr)); err != nil </span><span class="cov8" title="1">{
                allErrs = append(allErrs, field.Invalid(fldPath, cidr, errorMsg))
        }</span>
        <span class="cov8" title="1">return allErrs</span>
}

// ValidOcid is a simple pre-flight
// we will let the serverside handle the more complex and compete validation
func ValidOcid(ocid string) bool <span class="cov8" title="1">{
        if len(ocid) &gt;= 4 &amp;&amp; ocid[:4] == "ocid" </span><span class="cov8" title="1">{
                return true
        }</span>

        <span class="cov8" title="1">return false</span>
}

// validShape is a simple pre-flight
// we will let the serverside handle the more complex and compete validation.
func validShape(shape string) bool <span class="cov8" title="1">{
        return len(shape) &gt; 0
}</span>

// ValidRegion test if the string can be a region.
func ValidRegion(stringRegion string) bool <span class="cov8" title="1">{

        // region can be blank since the regional information
        // can be derived from other sources
        if stringRegion == "" </span><span class="cov8" title="1">{
                return true
        }</span>

        <span class="cov8" title="1">if invalidNameRegex.MatchString(stringRegion) </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">return true</span>
}

// ValidateNetworkSpec validates the NetworkSpec
func ValidateNetworkSpec(validRoles []Role, networkSpec NetworkSpec, old NetworkSpec, fldPath *field.Path) field.ErrorList <span class="cov8" title="1">{
        var allErrs field.ErrorList

        if len(networkSpec.Vcn.CIDR) &gt; 0 </span><span class="cov8" title="1">{
                vcnErrors := validateVCNCIDR(networkSpec.Vcn.CIDR, fldPath.Child("cidr"))
                allErrs = append(allErrs, vcnErrors...)
        }</span>

        <span class="cov8" title="1">if networkSpec.Vcn.Subnets != nil </span><span class="cov8" title="1">{
                subnetErrors := validateSubnets(validRoles, networkSpec.Vcn.Subnets, networkSpec.Vcn, fldPath.Child("subnets"))
                allErrs = append(allErrs, subnetErrors...)
        }</span>

        <span class="cov8" title="1">if networkSpec.Vcn.NetworkSecurityGroup.List != nil </span><span class="cov8" title="1">{
                nsgErrors := validateNSGs(validRoles, networkSpec.Vcn.NetworkSecurityGroup.List, fldPath.Child("networkSecurityGroups"))
                allErrs = append(allErrs, nsgErrors...)
        }</span>

        <span class="cov8" title="1">if len(allErrs) == 0 </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">return allErrs</span>
}

// validateVCNCIDR validates the CIDR of a VNC.
func validateVCNCIDR(vncCIDR string, fldPath *field.Path) field.ErrorList <span class="cov8" title="1">{
        var allErrs field.ErrorList
        if _, _, err := net.ParseCIDR(vncCIDR); err != nil </span><span class="cov8" title="1">{
                allErrs = append(allErrs, field.Invalid(fldPath, vncCIDR, "invalid CIDR format"))
        }</span>
        <span class="cov8" title="1">return allErrs</span>
}

// ValidateClusterName validates the name of the cluster.
func ValidateClusterName(name string) field.ErrorList <span class="cov8" title="1">{
        var allErrs field.ErrorList

        if success, _ := regexp.MatchString(clusterNameRegex, name); !success </span><span class="cov8" title="1">{
                allErrs = append(allErrs, field.Invalid(field.NewPath("metadata").Child("Name"), name,
                        fmt.Sprintf("Cluster Name doesn't match regex %s, can contain only lowercase alphanumeric characters and '-', must start/end with an alphanumeric character",
                                clusterNameRegex)))
        }</span>
        <span class="cov8" title="1">if len(allErrs) == 0 </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">return allErrs</span>
}

// validateSubnetCIDR validates the CIDR blocks of a Subnet.
func validateSubnetCIDR(subnetCidr string, vcnCidr string, fldPath *field.Path) field.ErrorList <span class="cov8" title="1">{
        var allErrs field.ErrorList

        if len(subnetCidr) &gt; 0 </span><span class="cov8" title="1">{
                subnetCidrIP, _, err := net.ParseCIDR(subnetCidr)
                if err != nil </span><span class="cov8" title="1">{
                        allErrs = append(allErrs, field.Invalid(fldPath, subnetCidr, "invalid CIDR format"))
                }</span>

                // Check subnet is in vcnCidr if vcnCidr is set
                <span class="cov8" title="1">if len(vcnCidr) &gt; 0 </span><span class="cov8" title="1">{
                        var vcnNetwork *net.IPNet
                        if _, parseNetwork, err := net.ParseCIDR(vcnCidr); err == nil </span><span class="cov8" title="1">{
                                vcnNetwork = parseNetwork
                        }</span>

                        <span class="cov8" title="1">var found bool
                        if vcnNetwork != nil &amp;&amp; vcnNetwork.Contains(subnetCidrIP) </span><span class="cov8" title="1">{
                                found = true
                        }</span>

                        <span class="cov8" title="1">if !found </span><span class="cov8" title="1">{
                                allErrs = append(allErrs, field.Invalid(fldPath, subnetCidr, fmt.Sprintf("subnet CIDR not in VCN address space: %s", vcnCidr)))
                        }</span>
                }

        }
        <span class="cov8" title="1">return allErrs</span>
}

// validateNSGs validates a list of Subnets.
func validateNSGs(validRoles []Role, networkSecurityGroups []*NSG, fldPath *field.Path) field.ErrorList <span class="cov8" title="1">{
        var allErrs field.ErrorList

        for i, nsg := range networkSecurityGroups </span><span class="cov8" title="1">{
                if err := validateRole(validRoles, nsg.Role, fldPath.Index(i).Child("role"), "networkSecurityGroup role invalid"); err != nil </span><span class="cov8" title="1">{
                        allErrs = append(allErrs, err)
                }</span>
                <span class="cov8" title="1">egressErrors := validateEgressSecurityRuleForNSG(nsg.EgressRules, fldPath.Index(i).Child("egressRules"))
                allErrs = append(allErrs, egressErrors...)
                ingressErrors := validateIngressSecurityRuleForNSG(nsg.IngressRules, fldPath.Index(i).Child("ingressRules"))
                allErrs = append(allErrs, ingressErrors...)</span>
        }

        <span class="cov8" title="1">return allErrs</span>
}

// validateEgressSecurityRuleForNSG validates the Egress Security Rules for NSG.
func validateEgressSecurityRuleForNSG(egressRules []EgressSecurityRuleForNSG, fldPath *field.Path) field.ErrorList <span class="cov8" title="1">{
        var allErrs field.ErrorList

        for i, r := range egressRules </span><span class="cov8" title="1">{
                rulePath := fldPath.Index(i)
                rule := r.EgressSecurityRule

                // Validate UDP options port ranges
                if udpOptions := rule.UdpOptions; udpOptions != nil </span><span class="cov8" title="1">{
                        if udpOptions.DestinationPortRange != nil </span><span class="cov8" title="1">{
                                portRangeErrors := validatePortRange(
                                        udpOptions.DestinationPortRange,
                                        rulePath.Child("udpOptions").Child("destinationPortRange"),
                                        fmt.Sprintf(udpDestinationPortRangeMaxRequiredFormat, egressRulesType),
                                        fmt.Sprintf(udpDestinationPortRangeMinRequiredFormat, egressRulesType),
                                )
                                allErrs = append(allErrs, portRangeErrors...)
                        }</span>

                        <span class="cov8" title="1">if udpOptions.SourcePortRange != nil </span><span class="cov8" title="1">{
                                portRangeErrors := validatePortRange(
                                        udpOptions.SourcePortRange,
                                        rulePath.Child("udpOptions").Child("sourcePortRange"),
                                        fmt.Sprintf(udpSourcePortRangeMaxRequiredFormat, egressRulesType),
                                        fmt.Sprintf(udpSourcePortRangeMinRequiredFormat, egressRulesType),
                                )
                                allErrs = append(allErrs, portRangeErrors...)
                        }</span>
                }

                // Validate TCP options port ranges
                <span class="cov8" title="1">if tcpOptions := rule.TcpOptions; tcpOptions != nil </span><span class="cov8" title="1">{
                        if tcpOptions.DestinationPortRange != nil </span><span class="cov8" title="1">{
                                portRangeErrors := validatePortRange(
                                        tcpOptions.DestinationPortRange,
                                        rulePath.Child("tcpOptions").Child("destinationPortRange"),
                                        fmt.Sprintf(tcpDestinationPortRangeMaxRequiredFormat, egressRulesType),
                                        fmt.Sprintf(tcpDestinationPortRangeMinRequiredFormat, egressRulesType),
                                )
                                allErrs = append(allErrs, portRangeErrors...)
                        }</span>

                        <span class="cov8" title="1">if tcpOptions.SourcePortRange != nil </span><span class="cov8" title="1">{
                                portRangeErrors := validatePortRange(
                                        tcpOptions.SourcePortRange,
                                        rulePath.Child("tcpOptions").Child("sourcePortRange"),
                                        fmt.Sprintf(tcpSourcePortRangeMaxRequiredFormat, egressRulesType),
                                        fmt.Sprintf(tcpSourcePortRangeMinRequiredFormat, egressRulesType),
                                )
                                allErrs = append(allErrs, portRangeErrors...)
                        }</span>
                }

                // Validate ICMP options
                <span class="cov8" title="1">if rule.IcmpOptions != nil &amp;&amp; rule.IcmpOptions.Type == nil </span><span class="cov8" title="1">{
                        allErrs = append(allErrs, field.Invalid(
                                rulePath.Child("icmpOptions").Child("type"),
                                rule.IcmpOptions.Type,
                                fmt.Sprintf(icmpTypeRequiredFormat, egressRulesType),
                        ))
                }</span>

                // Validate destination is required (except for SERVICE_CIDR_BLOCK type)
                <span class="cov8" title="1">if rule.DestinationType != EgressSecurityRuleDestinationTypeServiceCidrBlock &amp;&amp; rule.Destination == nil </span><span class="cov8" title="1">{
                        allErrs = append(allErrs, field.Invalid(
                                rulePath.Child("destination"),
                                rule.Destination,
                                fmt.Sprintf(destinationRequiredFormat, egressRulesType),
                        ))
                }</span>

                // Validate protocol is required
                <span class="cov8" title="1">if rule.Protocol == nil </span><span class="cov8" title="1">{
                        allErrs = append(allErrs, field.Invalid(
                                rulePath.Child("protocol"),
                                rule.Protocol,
                                fmt.Sprintf(protocolRequiredFormat, egressRulesType),
                        ))
                }</span>

                // Validate CIDR format for CIDR_BLOCK destination type
                <span class="cov8" title="1">if rule.DestinationType == EgressSecurityRuleDestinationTypeCidrBlock &amp;&amp; rule.Destination != nil </span><span class="cov8" title="1">{
                        cidrErrors := validateCIDR(
                                rule.Destination,
                                rulePath.Child("destination"),
                                fmt.Sprintf(invalidCIDRFormatFormat, egressRulesType),
                        )
                        allErrs = append(allErrs, cidrErrors...)
                }</span>
        }

        <span class="cov8" title="1">return allErrs</span>
}

// validateIngressSecurityRuleForNSG validates the Ingress Security Rules for NSG.
func validateIngressSecurityRuleForNSG(ingressRules []IngressSecurityRuleForNSG, fldPath *field.Path) field.ErrorList <span class="cov8" title="1">{
        var allErrs field.ErrorList

        for i, r := range ingressRules </span><span class="cov8" title="1">{
                rulePath := fldPath.Index(i)
                rule := r.IngressSecurityRule

                // Validate UDP options port ranges
                if udpOptions := rule.UdpOptions; udpOptions != nil </span><span class="cov8" title="1">{
                        if udpOptions.DestinationPortRange != nil </span><span class="cov8" title="1">{
                                portRangeErrors := validatePortRange(
                                        udpOptions.DestinationPortRange,
                                        rulePath.Child("udpOptions").Child("destinationPortRange"),
                                        fmt.Sprintf(udpDestinationPortRangeMaxRequiredFormat, ingressRulesType),
                                        fmt.Sprintf(udpDestinationPortRangeMinRequiredFormat, ingressRulesType),
                                )
                                allErrs = append(allErrs, portRangeErrors...)
                        }</span>

                        <span class="cov8" title="1">if udpOptions.SourcePortRange != nil </span><span class="cov8" title="1">{
                                portRangeErrors := validatePortRange(
                                        udpOptions.SourcePortRange,
                                        rulePath.Child("udpOptions").Child("sourcePortRange"),
                                        fmt.Sprintf(udpSourcePortRangeMaxRequiredFormat, ingressRulesType),
                                        fmt.Sprintf(udpSourcePortRangeMinRequiredFormat, ingressRulesType),
                                )
                                allErrs = append(allErrs, portRangeErrors...)
                        }</span>
                }

                // Validate TCP options port ranges
                <span class="cov8" title="1">if tcpOptions := rule.TcpOptions; tcpOptions != nil </span><span class="cov8" title="1">{
                        if tcpOptions.DestinationPortRange != nil </span><span class="cov8" title="1">{
                                portRangeErrors := validatePortRange(
                                        tcpOptions.DestinationPortRange,
                                        rulePath.Child("tcpOptions").Child("destinationPortRange"),
                                        fmt.Sprintf(tcpDestinationPortRangeMaxRequiredFormat, ingressRulesType),
                                        fmt.Sprintf(tcpDestinationPortRangeMinRequiredFormat, ingressRulesType),
                                )
                                allErrs = append(allErrs, portRangeErrors...)
                        }</span>

                        <span class="cov8" title="1">if tcpOptions.SourcePortRange != nil </span><span class="cov8" title="1">{
                                portRangeErrors := validatePortRange(
                                        tcpOptions.SourcePortRange,
                                        rulePath.Child("tcpOptions").Child("sourcePortRange"),
                                        fmt.Sprintf(tcpSourcePortRangeMaxRequiredFormat, ingressRulesType),
                                        fmt.Sprintf(tcpSourcePortRangeMinRequiredFormat, ingressRulesType),
                                )
                                allErrs = append(allErrs, portRangeErrors...)
                        }</span>
                }

                // Validate ICMP options
                <span class="cov8" title="1">if rule.IcmpOptions != nil &amp;&amp; rule.IcmpOptions.Type == nil </span><span class="cov0" title="0">{
                        allErrs = append(allErrs, field.Invalid(
                                rulePath.Child("icmpOptions").Child("type"),
                                rule.IcmpOptions.Type,
                                fmt.Sprintf(icmpTypeRequiredFormat, ingressRulesType),
                        ))
                }</span>

                // Validate source is required (except for SERVICE_CIDR_BLOCK type)
                <span class="cov8" title="1">if rule.SourceType != IngressSecurityRuleSourceTypeServiceCidrBlock &amp;&amp; rule.Source == nil </span><span class="cov8" title="1">{
                        allErrs = append(allErrs, field.Invalid(
                                rulePath.Child("source"),
                                rule.Source,
                                fmt.Sprintf(sourceRequiredFormat, ingressRulesType),
                        ))
                }</span>

                // Validate protocol is required
                <span class="cov8" title="1">if rule.Protocol == nil </span><span class="cov8" title="1">{
                        allErrs = append(allErrs, field.Invalid(
                                rulePath.Child("protocol"),
                                rule.Protocol,
                                fmt.Sprintf(protocolRequiredFormat, ingressRulesType),
                        ))
                }</span>

                // Validate CIDR format for CIDR_BLOCK source type
                <span class="cov8" title="1">if rule.SourceType == IngressSecurityRuleSourceTypeCidrBlock &amp;&amp; rule.Source != nil </span><span class="cov8" title="1">{
                        cidrErrors := validateCIDR(
                                rule.Source,
                                rulePath.Child("source"),
                                fmt.Sprintf(invalidCIDRFormatFormat, ingressRulesType),
                        )
                        allErrs = append(allErrs, cidrErrors...)
                }</span>
        }

        <span class="cov8" title="1">return allErrs</span>
}

// validateSubnets validates a list of Subnets.
func validateSubnets(validRoles []Role, subnets []*Subnet, vcn VCN, fldPath *field.Path) field.ErrorList <span class="cov8" title="1">{
        var allErrs field.ErrorList
        subnetNames := make(map[string]bool, len(subnets))

        for i, subnet := range subnets </span><span class="cov8" title="1">{
                if err := validateSubnetName(subnet.Name, fldPath.Index(i).Child("name")); err != nil </span><span class="cov0" title="0">{
                        allErrs = append(allErrs, err)
                }</span>
                <span class="cov8" title="1">if len(subnet.Name) &gt; 0 </span><span class="cov8" title="1">{
                        if _, ok := subnetNames[subnet.Name]; ok </span><span class="cov8" title="1">{
                                allErrs = append(allErrs, field.Duplicate(fldPath, subnet.Name))
                        }</span>
                        <span class="cov8" title="1">subnetNames[subnet.Name] = true</span>
                }

                <span class="cov8" title="1">if err := validateRole(validRoles, subnet.Role, fldPath.Index(i).Child("role"), "subnet role invalid"); err != nil </span><span class="cov8" title="1">{
                        allErrs = append(allErrs, err)
                }</span>

                <span class="cov8" title="1">subnetCIDRErrors := validateSubnetCIDR(subnet.CIDR, vcn.CIDR, fldPath.Index(i).Child("cidr"))
                allErrs = append(allErrs, subnetCIDRErrors...)</span>
        }

        <span class="cov8" title="1">return allErrs</span>
}

// validateSubnetName validates the Name of a Subnet.
func validateSubnetName(name string, fldPath *field.Path) *field.Error <span class="cov8" title="1">{
        // subnet name can be empty
        if len(name) &gt; 0 </span><span class="cov8" title="1">{
                if invalidNameRegex.Match([]byte(name)) || name == "" </span><span class="cov0" title="0">{
                        return field.Invalid(fldPath, name,
                                fmt.Sprintf("subnet name invalid"))
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// validateRole validates that the subnet role is one of the allowed types
func validateRole(validRoles []Role, subnetRole Role, fldPath *field.Path, errorMsg string) *field.Error <span class="cov8" title="1">{
        for _, role := range validRoles </span><span class="cov8" title="1">{
                if subnetRole == role </span><span class="cov8" title="1">{
                        return nil
                }</span>
        }
        <span class="cov8" title="1">return field.Invalid(fldPath, subnetRole,
                fmt.Sprintf("%s", errorMsg))</span>
}
</pre>
		
		<pre class="file" id="file32" style="display: none">/*
Copyright (c) 2021, 2022 Oracle and/or its affiliates.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package config

import (
        "os"
        "path/filepath"
        "strconv"

        "github.com/oracle/oci-go-sdk/v65/common"
        "github.com/oracle/oci-go-sdk/v65/common/auth"
        "github.com/pkg/errors"
        "gopkg.in/yaml.v2"
)

// set this way to allow for mocks to be used for testing
var instancePrincipalProviderFunc = auth.InstancePrincipalConfigurationProvider

const (
        UseInstancePrincipal = "useInstancePrincipal"
        Tenancy              = "tenancy"
        User                 = "user"
        Passphrase           = "passphrase"
        Key                  = "key"
        Fingerprint          = "fingerprint"
        Region               = "region"
)

// AuthConfig holds the configuration required for communicating with the OCI
// API.
type AuthConfig struct {
        Region                string `yaml:"region"`
        TenancyID             string `yaml:"tenancy"`
        UserID                string `yaml:"user"`
        PrivateKey            string `yaml:"key"`
        Fingerprint           string `yaml:"fingerprint"`
        Passphrase            string `yaml:"passphrase"`
        UseInstancePrincipals bool   `yaml:"useInstancePrincipals"`
}

// FromDir will load a cloud provider configuration file from a given directory.
func FromDir(path string) (*AuthConfig, error) <span class="cov8" title="1">{
        fileInfo, err := os.Stat(path)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if fileInfo.IsDir() </span><span class="cov8" title="1">{
                return getConfigFromDir(path)
        }</span> else<span class="cov8" title="1"> {
                return getConfigFromFile(path)
        }</span>
}

func getConfigFromFile(path string) (authConfig *AuthConfig, err error) <span class="cov8" title="1">{
        var f *os.File
        f, err = os.Open(filepath.Clean(path))
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                if closeErr := f.Close(); closeErr != nil </span><span class="cov0" title="0">{
                        err = closeErr
                }</span>
        }()

        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if f == nil </span><span class="cov0" title="0">{
                return nil, errors.New("no auth config file given")
        }</span>

        <span class="cov8" title="1">cfg := &amp;AuthConfig{}
        err = yaml.NewDecoder(f).Decode(&amp;cfg)
        if err != nil </span><span class="cov8" title="1">{
                return nil, errors.Wrap(err, "unmarshalling auth config")
        }</span>

        <span class="cov8" title="1">return cfg, nil</span>
}

func getConfigFromDir(path string) (*AuthConfig, error) <span class="cov8" title="1">{
        cfg := &amp;AuthConfig{}
        useInstancePrincipalString, err := ReadFile(path, UseInstancePrincipal)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">useInstancePrincipal, err := strconv.ParseBool(useInstancePrincipalString)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if useInstancePrincipal </span><span class="cov8" title="1">{
                cfg.UseInstancePrincipals = useInstancePrincipal
                return cfg, nil
        }</span>
        <span class="cov8" title="1">region, err := ReadFile(path, Region)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">cfg.Region = region

        tenancy, err := ReadFile(path, Tenancy)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">cfg.TenancyID = tenancy

        user, err := ReadFile(path, User)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">cfg.UserID = user

        fingerprint, err := ReadFile(path, Fingerprint)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">cfg.Fingerprint = fingerprint

        passphrase, err := ReadFile(path, Passphrase)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">cfg.Passphrase = passphrase

        key, err := ReadFile(path, Key)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">cfg.PrivateKey = key

        return cfg, nil</span>
}

func NewConfigurationProvider(cfg *AuthConfig) (common.ConfigurationProvider, error) <span class="cov8" title="1">{
        if cfg == nil </span><span class="cov8" title="1">{
                return nil, errors.New("auth config must not be nil")
        }</span>
        <span class="cov8" title="1">if cfg.UseInstancePrincipals </span><span class="cov8" title="1">{
                return instancePrincipalProviderFunc()
        }</span> else<span class="cov0" title="0"> {
                return NewConfigurationProviderWithUserPrincipal(cfg)
        }</span>
}

// nolint:nilnil
func NewConfigurationProviderWithUserPrincipal(cfg *AuthConfig) (common.ConfigurationProvider, error) <span class="cov8" title="1">{
        var conf common.ConfigurationProvider
        if cfg == nil </span><span class="cov8" title="1">{
                return nil, errors.New("cfg cannot be nil")
        }</span>
        <span class="cov8" title="1">conf = common.NewRawConfigurationProvider(
                cfg.TenancyID,
                cfg.UserID,
                cfg.Region,
                cfg.Fingerprint,
                cfg.PrivateKey,
                common.String(cfg.Passphrase))
        return conf, nil</span>
}

func ReadFile(path string, key string) (string, error) <span class="cov8" title="1">{
        filePath := filepath.Join(path, key)
        b, err := os.ReadFile(filepath.Clean(filePath))
        if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>
        <span class="cov8" title="1">return string(b), err</span>
}
</pre>
		
		<pre class="file" id="file33" style="display: none">/*
Copyright (c) 2023 Oracle and/or its affiliates.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package metrics

import (
        "net/http"
        "strings"
        "time"

        "github.com/oracle/oci-go-sdk/v65/common"
)

// HttpRequestDispatcherWrapper is a wrapper around standard common.HTTPRequestDispatcher to handle
// metrics
type HttpRequestDispatcherWrapper struct {
        dispatcher common.HTTPRequestDispatcher
        region     string
}

// Do is wrapper implementation of common.HTTPRequestDispatcher Do method
func (wrapper HttpRequestDispatcherWrapper) Do(req *http.Request) (*http.Response, error) <span class="cov0" title="0">{
        t := time.Now()
        resp, err := wrapper.dispatcher.Do(req)
        defer func() </span><span class="cov0" title="0">{
                // taken from https://docs.oracle.com/en-us/iaas/Content/API/Concepts/usingapi.htm
                // a URL consists of a version string and then a resource
                urlSplit := strings.Split(req.URL.Path, "/")
                if len(urlSplit) &lt; 2 </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">resource := urlSplit[2]
                IncRequestCounter(err, resource, req.Method, wrapper.region, resp)
                ObserverRequestDuration(resource, req.Method, wrapper.region, time.Since(t))</span>
        }()
        <span class="cov0" title="0">return resp, err</span>
}

// NewHttpRequestDispatcherWrapper creates a new instance of HttpRequestDispatcherWrapper
func NewHttpRequestDispatcherWrapper(dispatcher common.HTTPRequestDispatcher, region string) HttpRequestDispatcherWrapper <span class="cov0" title="0">{
        return HttpRequestDispatcherWrapper{
                dispatcher: dispatcher,
                region:     region,
        }
}</span>
</pre>
		
		<pre class="file" id="file34" style="display: none">/*
Copyright (c) 2023 Oracle and/or its affiliates.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package metrics

import (
        "net/http"
        "strconv"
        "time"

        "github.com/prometheus/client_golang/prometheus"
        "sigs.k8s.io/controller-runtime/pkg/metrics"
)

type verb string

const (
        SubSystemOCI     = "oci"
        OCIRequestsTotal = "requests_total"
        Duration         = "request_duration"
        Resource         = "resource"
        StatusCode       = "status_code"
        Operation        = "operation"

        Region        = "region"
        Get    string = "get"
        List   string = "list"
        Create string = "create"
        Update string = "update"
        Delete string = "delete"
)

var (
        ociRequestCounter = prometheus.NewCounterVec(
                prometheus.CounterOpts{
                        Subsystem: SubSystemOCI,
                        Name:      OCIRequestsTotal,
                        Help:      "OCI API requests total.",
                },
                []string{Resource, StatusCode, Operation, Region},
        )
        ociRequestDurationSeconds = prometheus.NewHistogramVec(prometheus.HistogramOpts{
                Subsystem: SubSystemOCI,
                Name:      Duration,
                Help:      "Duration/Latency of HTTP requests to OCI",
        }, []string{Resource, Operation, Region})
)

// IncRequestCounter increments the request count metric for the given resource.
// Unknown errors from request dispatcher will have response code of 999
func IncRequestCounter(err error, resource string, operation string, region string, response *http.Response) <span class="cov0" title="0">{
        statusCode := 999
        if err == nil </span><span class="cov0" title="0">{
                statusCode = response.StatusCode
        }</span>
        <span class="cov0" title="0">ociRequestCounter.With(prometheus.Labels{
                Resource:   resource,
                Operation:  operation,
                StatusCode: strconv.Itoa(statusCode),
                Region:     region,
        }).Inc()</span>
}

// ObserverRequestDuration observes the request duration for the partcular OCI request
func ObserverRequestDuration(resource string, operation string, region string, duration time.Duration) <span class="cov0" title="0">{
        ociRequestDurationSeconds.With(prometheus.Labels{
                Resource:  resource,
                Operation: operation,
                Region:    region,
        }).Observe(duration.Seconds())
}</span>

func init() <span class="cov0" title="0">{
        metrics.Registry.MustRegister(ociRequestCounter)
        metrics.Registry.MustRegister(ociRequestDurationSeconds)
}</span>
</pre>
		
		<pre class="file" id="file35" style="display: none">/*
 Copyright (c) 2021, 2022 Oracle and/or its affiliates.

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

      https://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
*/

package ociutil

import (
        "context"
        "fmt"
        "net/http"
        "strings"
        "time"

        lb "github.com/oracle/cluster-api-provider-oci/cloud/services/loadbalancer"
        nlb "github.com/oracle/cluster-api-provider-oci/cloud/services/networkloadbalancer"

        "github.com/oracle/oci-go-sdk/v65/common"
        "github.com/oracle/oci-go-sdk/v65/core"
        "github.com/oracle/oci-go-sdk/v65/loadbalancer"
        "github.com/oracle/oci-go-sdk/v65/networkloadbalancer"

        "github.com/pkg/errors"
        "k8s.io/apimachinery/pkg/util/wait"
)

const (
        WorkRequestPollInterval   = 5 * time.Second
        WorkRequestTimeout        = 2 * time.Minute
        MaxOPCRetryTokenBytes     = 64
        CreatedBy                 = "CreatedBy"
        OCIClusterAPIProvider     = "OCIClusterAPIProvider"
        ClusterResourceIdentifier = "ClusterResourceIdentifier"
        OutOfHostCapacityErr      = "Out of host capacity"
)

// ErrNotFound is for simulation during testing, OCI SDK does not have a way
// to create Service Errors
var ErrNotFound = errors.New("not found")

// IsNotFound returns true if the given error indicates that a resource could
// not be found.
// nolint:nilaway // We don't need to check if serviceErr is nil, because once ok is true,
// serviceErr is non-nil and will not have any issue in accesing GetHTTPStatusCode() field
func IsNotFound(err error) bool <span class="cov0" title="0">{
        if err == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">if err.Error() == ErrNotFound.Error() </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov0" title="0">err = errors.Cause(err)
        serviceErr, ok := common.IsServiceError(err)
        return ok &amp;&amp; serviceErr.GetHTTPStatusCode() == http.StatusNotFound</span>
}

// AwaitNLBWorkRequest waits for the LB work request to either succeed, fail. See k8s.io/apimachinery/pkg/util/wait
func AwaitNLBWorkRequest(ctx context.Context, networkLoadBalancerClient nlb.NetworkLoadBalancerClient, workRequestId *string) (*networkloadbalancer.WorkRequest, error) <span class="cov0" title="0">{
        var wr *networkloadbalancer.WorkRequest
        immediate := true
        err := wait.PollUntilContextTimeout(ctx, WorkRequestPollInterval, WorkRequestTimeout, immediate, func(ctx context.Context) (done bool, err error) </span><span class="cov0" title="0">{
                twr, err := networkLoadBalancerClient.GetWorkRequest(ctx, networkloadbalancer.GetWorkRequestRequest{
                        WorkRequestId: workRequestId,
                })
                if err != nil </span><span class="cov0" title="0">{
                        return true, errors.Wrap(err, "failed create poll nlb workrequest")
                }</span>
                <span class="cov0" title="0">switch twr.Status </span>{
                case networkloadbalancer.OperationStatusSucceeded:<span class="cov0" title="0">
                        wr = &amp;twr.WorkRequest
                        return true, nil</span>
                case networkloadbalancer.OperationStatusFailed:<span class="cov0" title="0">
                        wreq := networkloadbalancer.ListWorkRequestErrorsRequest{
                                WorkRequestId: workRequestId,
                                CompartmentId: twr.CompartmentId,
                        }
                        final_err := errors.Errorf("WorkRequest %s failed", *workRequestId)
                        wresp, err := networkLoadBalancerClient.ListWorkRequestErrors(ctx, wreq)
                        if err != nil </span><span class="cov0" title="0">{
                                return false, errors.Wrap(final_err, "Failed to fetch the work-request-errors using nlb client")
                        }</span>
                        <span class="cov0" title="0">for _, wr_err := range wresp.WorkRequestErrorCollection.Items </span><span class="cov0" title="0">{
                                final_err = errors.Wrapf(final_err, "%s: %s", *wr_err.Code, *wr_err.Message)
                        }</span>
                        <span class="cov0" title="0">return false, final_err</span>
                }
                <span class="cov0" title="0">return false, nil</span>
        })
        <span class="cov0" title="0">return wr, err</span>
}

// AwaitLBWorkRequest waits for the LBaaS work request to either succeed, fail. See k8s.io/apimachinery/pkg/util/wait
func AwaitLBWorkRequest(ctx context.Context, loadBalancerClient lb.LoadBalancerClient, workRequestId *string) (*loadbalancer.WorkRequest, error) <span class="cov0" title="0">{
        var wr *loadbalancer.WorkRequest
        immediate := true
        err := wait.PollUntilContextTimeout(ctx, WorkRequestPollInterval, WorkRequestTimeout, immediate, func(ctx context.Context) (done bool, err error) </span><span class="cov0" title="0">{
                twr, err := loadBalancerClient.GetWorkRequest(ctx, loadbalancer.GetWorkRequestRequest{
                        WorkRequestId: workRequestId,
                })
                if err != nil </span><span class="cov0" title="0">{
                        return true, errors.Wrap(err, "failed create poll lb workrequest")
                }</span>
                <span class="cov0" title="0">switch twr.WorkRequest.LifecycleState </span>{
                case loadbalancer.WorkRequestLifecycleStateSucceeded:<span class="cov0" title="0">
                        wr = &amp;twr.WorkRequest
                        return true, nil</span>
                case loadbalancer.WorkRequestLifecycleStateFailed:<span class="cov0" title="0">
                        final_err := errors.Errorf("WorkRequest %s failed", *workRequestId)
                        for _, wreq := range twr.WorkRequest.ErrorDetails </span><span class="cov0" title="0">{
                                final_err = errors.Wrapf(final_err, "%s: %s", wreq.ErrorCode, *wreq.Message)
                        }</span>
                        <span class="cov0" title="0">return false, final_err</span>
                }
                <span class="cov0" title="0">return false, nil</span>
        })
        <span class="cov0" title="0">return wr, err</span>
}

func truncateOPCRetryToken(str string) string <span class="cov0" title="0">{
        b := []byte(str)
        if len(b) &gt; MaxOPCRetryTokenBytes </span><span class="cov0" title="0">{
                return string(b[0:MaxOPCRetryTokenBytes])
        }</span>
        <span class="cov0" title="0">return str</span>
}

// GetOPCRetryToken truncates the values input and returns the OPC retry token
func GetOPCRetryToken(format string, values ...interface{}) *string <span class="cov0" title="0">{
        return common.String(truncateOPCRetryToken(fmt.Sprintf(format, values...)))
}</span>

// GetBaseLineOcpuOptimizationEnum iterates over the valid baseline OCPUs to validate the passed in value
func GetBaseLineOcpuOptimizationEnum(baseLineOcpuOptmimizationString string) (core.LaunchInstanceShapeConfigDetailsBaselineOcpuUtilizationEnum, error) <span class="cov8" title="1">{
        for _, e := range core.GetLaunchInstanceShapeConfigDetailsBaselineOcpuUtilizationEnumValues() </span><span class="cov8" title="1">{
                if string(e) == baseLineOcpuOptmimizationString </span><span class="cov8" title="1">{
                        return e, nil
                }</span>
        }
        <span class="cov8" title="1">return "", errors.New("invalid baseline cpu optimization parameter")</span>
}

// GetInstanceConfigBaseLineOcpuOptimizationEnum iterates over the valid baseline OCPUs to validate the passed in value
func GetInstanceConfigBaseLineOcpuOptimizationEnum(baseLineOcpuOptmimizationString string) (core.InstanceConfigurationLaunchInstanceShapeConfigDetailsBaselineOcpuUtilizationEnum, error) <span class="cov0" title="0">{
        for _, e := range core.GetInstanceConfigurationLaunchInstanceShapeConfigDetailsBaselineOcpuUtilizationEnumValues() </span><span class="cov0" title="0">{
                if string(e) == baseLineOcpuOptmimizationString </span><span class="cov0" title="0">{
                        return e, nil
                }</span>
        }
        <span class="cov0" title="0">return "", errors.New("invalid baseline cpu optimization parameter")</span>
}

// GetDefaultClusterTags creates and returns a map of the default tags for all clusters
func GetDefaultClusterTags() map[string]string <span class="cov8" title="1">{
        tags := make(map[string]string)
        tags[CreatedBy] = OCIClusterAPIProvider
        return tags
}</span>

// BuildClusterTags uses the default tags and adds the ClusterResourceUID tag
func BuildClusterTags(ClusterResourceUID string) map[string]string <span class="cov8" title="1">{
        tags := GetDefaultClusterTags()
        tags[ClusterResourceIdentifier] = ClusterResourceUID
        return tags
}</span>

// IsOutOfHostCapacity returns true when the OCI service error indicates that the fault domain ran out of capacity.
// Error code: https://docs.public.content.oci.oraclecloud.com/en-us/iaas/Content/Compute/known-issues.htm?#out-of-host-capacity-error-when-creating-compute-instances
func IsOutOfHostCapacity(err error) bool <span class="cov8" title="1">{
        if err == nil </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">err = errors.Cause(err)
        if serviceErr, ok := common.IsServiceError(err); ok </span><span class="cov8" title="1">{
                return serviceErr.GetHTTPStatusCode() == http.StatusInternalServerError &amp;&amp;
                        strings.Contains(strings.ToLower(serviceErr.GetMessage()), strings.ToLower(OutOfHostCapacityErr))
        }</span>
        <span class="cov8" title="1">return false</span>
}

// DerefString returns the string value if the pointer isn't nil, otherwise returns empty string
func DerefString(s *string) string <span class="cov0" title="0">{
        if s != nil </span><span class="cov0" title="0">{
                return *s
        }</span>

        <span class="cov0" title="0">return ""</span>
}
</pre>
		
		<pre class="file" id="file36" style="display: none">package ptr

import infrastructurev1beta2 "github.com/oracle/cluster-api-provider-oci/api/v1beta2"

// ToString returns string value dereferenced if the passed
// in pointer was not nil. Returns a string zero value if the
// pointer was nil.
func ToString(p *string) (v string) <span class="cov8" title="1">{
        if p == nil </span><span class="cov8" title="1">{
                return v
        }</span>

        <span class="cov8" title="1">return *p</span>
}

// ToBool returns bool value dereferenced if the passed
// in pointer was not nil. Returns a bool zero value (false) if the
// pointer was nil.
func ToBool(p *bool) (v bool) <span class="cov8" title="1">{
        if p == nil </span><span class="cov8" title="1">{
                return v
        }</span>

        <span class="cov8" title="1">return *p</span>
}

// ToStringSlice returns a slice of string values, that are
// dereferenced if the passed in pointer was not nil. Returns a string
// zero value if the pointer was nil.
func ToStringSlice(vs []*string) []string <span class="cov8" title="1">{
        ps := make([]string, len(vs))
        for i, v := range vs </span><span class="cov8" title="1">{
                ps[i] = ToString(v)
        }</span>

        <span class="cov8" title="1">return ps</span>
}

// ToNSGSlice returns a slice of NSG values, that are
// dereferenced if the passed in pointer was not nil. Returns an empty slice
// zero value if the pointer was nil.
func ToNSGSlice(vs []*infrastructurev1beta2.NSG) []infrastructurev1beta2.NSG <span class="cov8" title="1">{
        ps := make([]infrastructurev1beta2.NSG, len(vs))
        for i, v := range vs </span><span class="cov8" title="1">{
                if v != nil </span><span class="cov8" title="1">{
                        ps[i] = *v
                }</span>
        }

        <span class="cov8" title="1">return ps</span>
}

// ToSubnetSlice returns a slice of Subnet values, that are
// dereferenced if the passed in pointer was not nil. Returns an empty slice
// zero value if the pointer was nil.
func ToSubnetSlice(vs []*infrastructurev1beta2.Subnet) []infrastructurev1beta2.Subnet <span class="cov8" title="1">{
        ps := make([]infrastructurev1beta2.Subnet, len(vs))
        for i, v := range vs </span><span class="cov8" title="1">{
                if v != nil </span><span class="cov8" title="1">{
                        ps[i] = *v
                }</span>
        }

        <span class="cov8" title="1">return ps</span>
}
</pre>
		
		<pre class="file" id="file37" style="display: none">/*
Copyright (c) 2022, Oracle and/or its affiliates.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package scope

import (
        "crypto/x509"
        "net/http"
        "sync"

        "github.com/go-logr/logr"
        "github.com/oracle/cluster-api-provider-oci/api/v1beta2"
        "github.com/oracle/cluster-api-provider-oci/cloud/metrics"
        "github.com/oracle/cluster-api-provider-oci/cloud/services/base"
        "github.com/oracle/cluster-api-provider-oci/cloud/services/compute"
        "github.com/oracle/cluster-api-provider-oci/cloud/services/computemanagement"
        containerEngineClient "github.com/oracle/cluster-api-provider-oci/cloud/services/containerengine"
        identityClient "github.com/oracle/cluster-api-provider-oci/cloud/services/identity"
        lb "github.com/oracle/cluster-api-provider-oci/cloud/services/loadbalancer"
        nlb "github.com/oracle/cluster-api-provider-oci/cloud/services/networkloadbalancer"
        "github.com/oracle/cluster-api-provider-oci/cloud/services/vcn"
        wr "github.com/oracle/cluster-api-provider-oci/cloud/services/workrequests"
        "github.com/oracle/cluster-api-provider-oci/version"
        "github.com/oracle/oci-go-sdk/v65/common"
        "github.com/oracle/oci-go-sdk/v65/containerengine"
        "github.com/oracle/oci-go-sdk/v65/core"
        "github.com/oracle/oci-go-sdk/v65/identity"
        "github.com/oracle/oci-go-sdk/v65/loadbalancer"
        "github.com/oracle/oci-go-sdk/v65/networkloadbalancer"
        "github.com/oracle/oci-go-sdk/v65/workrequests"
        "github.com/pkg/errors"
        "k8s.io/klog/v2/klogr"
)

// OCIClients is the struct of all the needed OCI clients
type OCIClients struct {
        ComputeClient             compute.ComputeClient
        ComputeManagementClient   computemanagement.Client
        VCNClient                 vcn.Client
        NetworkLoadBalancerClient nlb.NetworkLoadBalancerClient
        LoadBalancerClient        lb.LoadBalancerClient
        IdentityClient            identityClient.Client
        ContainerEngineClient     containerEngineClient.Client
        WorkRequestsClient        wr.Client
        BaseClient                base.BaseClient
}

// ClientProvider defines the regional clients
type ClientProvider struct {
        *logr.Logger
        ociClients            map[string]OCIClients
        ociClientsLock        *sync.RWMutex
        ociAuthConfigProvider common.ConfigurationProvider
        ociClientOverrides    *v1beta2.ClientOverrides
        certOverride          *x509.CertPool
}

// ClientProviderParams is the params struct for NewClientProvider
type ClientProviderParams struct {
        // OciAuthConfigProvider wraps information about the account owner
        OciAuthConfigProvider common.ConfigurationProvider

        // ClientOverrides contains information about client host url overrides.
        ClientOverrides *v1beta2.ClientOverrides

        // CertOverride a x509 CertPool to use as an override for client TLSClientConfig
        CertOverride *x509.CertPool
}

// NewClientProvider builds the ClientProvider with a client for the given region
func NewClientProvider(params ClientProviderParams) (*ClientProvider, error) <span class="cov8" title="1">{
        log := klogr.New()

        if params.OciAuthConfigProvider == nil </span><span class="cov8" title="1">{
                return nil, errors.New("ConfigurationProvider can not be nil")
        }</span>

        <span class="cov8" title="1">provider := ClientProvider{
                Logger:                &amp;log,
                certOverride:          params.CertOverride,
                ociAuthConfigProvider: params.OciAuthConfigProvider,
                ociClients:            map[string]OCIClients{},
                ociClientsLock:        new(sync.RWMutex),
                ociClientOverrides:    params.ClientOverrides,
        }

        return &amp;provider, nil</span>
}

// GetAuthProvider returns the client provider auth config
// nolint:nilaway
func (c *ClientProvider) GetAuthProvider() common.ConfigurationProvider <span class="cov8" title="1">{
        return c.ociAuthConfigProvider
}</span>

// GetOrBuildClient if the OCIClients exist for the region they are returned, if not clients will build them
func (c *ClientProvider) GetOrBuildClient(region string) (OCIClients, error) <span class="cov8" title="1">{
        if c == nil || c.ociClients == nil </span><span class="cov0" title="0">{
                return OCIClients{}, errors.New("Client provider is not initialized")
        }</span>
        <span class="cov8" title="1">if len(region) &lt;= 0 </span><span class="cov0" title="0">{
                return OCIClients{}, errors.New("ClientProvider.GetOrBuildClient region can not be empty")
        }</span>

        <span class="cov8" title="1">c.ociClientsLock.RLock()
        clients, regionalClientsExists := c.ociClients[region]
        c.ociClientsLock.RUnlock()

        if regionalClientsExists </span><span class="cov8" title="1">{
                return clients, nil
        }</span>

        <span class="cov8" title="1">c.ociClientsLock.Lock()
        defer c.ociClientsLock.Unlock()
        regionalClient, err := c.createClients(region)
        if err != nil </span><span class="cov0" title="0">{
                return regionalClient, err
        }</span>
        <span class="cov8" title="1">c.ociClients[region] = regionalClient

        return regionalClient, nil</span>
}

// GetRegion returns the region from the authentication config provider
func (c *ClientProvider) GetRegion() (string, error) <span class="cov0" title="0">{
        return c.ociAuthConfigProvider.Region()
}</span>

func (c *ClientProvider) createClients(region string) (OCIClients, error) <span class="cov8" title="1">{
        vcnClient, err := c.createVcnClient(region, c.ociAuthConfigProvider, c.Logger)
        if err != nil </span><span class="cov0" title="0">{
                return OCIClients{}, err
        }</span>
        <span class="cov8" title="1">nlbClient, err := c.createNLbClient(region, c.ociAuthConfigProvider, c.Logger)
        if err != nil </span><span class="cov0" title="0">{
                return OCIClients{}, err
        }</span>
        <span class="cov8" title="1">lbClient, err := c.createLBClient(region, c.ociAuthConfigProvider, c.Logger)
        if err != nil </span><span class="cov0" title="0">{
                return OCIClients{}, err
        }</span>
        <span class="cov8" title="1">identityClt, err := c.createIdentityClient(region, c.ociAuthConfigProvider, c.Logger)
        if err != nil </span><span class="cov0" title="0">{
                return OCIClients{}, err
        }</span>
        <span class="cov8" title="1">computeClient, err := c.createComputeClient(region, c.ociAuthConfigProvider, c.Logger)
        if err != nil </span><span class="cov0" title="0">{
                return OCIClients{}, err
        }</span>
        <span class="cov8" title="1">computeManagementClient, err := c.createComputeManagementClient(region, c.ociAuthConfigProvider, c.Logger)
        if err != nil </span><span class="cov0" title="0">{
                return OCIClients{}, err
        }</span>
        <span class="cov8" title="1">containerEngineClt, err := c.createContainerEngineClient(region, c.ociAuthConfigProvider, c.Logger)
        if err != nil </span><span class="cov0" title="0">{
                return OCIClients{}, err
        }</span>
        <span class="cov8" title="1">workrequestsClt, err := c.createWorkrequestsClient(region, c.ociAuthConfigProvider, c.Logger)
        if err != nil </span><span class="cov0" title="0">{
                return OCIClients{}, err
        }</span>
        <span class="cov8" title="1">baseClient, err := c.createBaseClient(region, c.ociAuthConfigProvider, c.Logger)
        if err != nil </span><span class="cov0" title="0">{
                return OCIClients{}, err
        }</span>

        <span class="cov8" title="1">return OCIClients{
                VCNClient:                 vcnClient,
                NetworkLoadBalancerClient: nlbClient,
                LoadBalancerClient:        lbClient,
                IdentityClient:            identityClt,
                ComputeClient:             computeClient,
                ComputeManagementClient:   computeManagementClient,
                ContainerEngineClient:     containerEngineClt,
                WorkRequestsClient:        workrequestsClt,
                BaseClient:                baseClient,
        }, err</span>
}

func (c *ClientProvider) createVcnClient(region string, ociAuthConfigProvider common.ConfigurationProvider, logger *logr.Logger) (*core.VirtualNetworkClient, error) <span class="cov8" title="1">{
        vcnClient, err := core.NewVirtualNetworkClientWithConfigurationProvider(ociAuthConfigProvider)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error(err, "unable to create OCI VCN Client")
                return nil, err
        }</span>
        <span class="cov8" title="1">vcnClient.SetRegion(region)
        dispatcher := vcnClient.HTTPClient
        vcnClient.HTTPClient = metrics.NewHttpRequestDispatcherWrapper(dispatcher, region)

        if c.ociClientOverrides != nil &amp;&amp; c.ociClientOverrides.VCNClientUrl != nil </span><span class="cov0" title="0">{
                vcnClient.Host = *c.ociClientOverrides.VCNClientUrl
        }</span>
        <span class="cov8" title="1">vcnClient.Interceptor = setVersionHeader()

        return &amp;vcnClient, nil</span>
}

func (c *ClientProvider) createNLbClient(region string, ociAuthConfigProvider common.ConfigurationProvider, logger *logr.Logger) (*networkloadbalancer.NetworkLoadBalancerClient, error) <span class="cov8" title="1">{
        nlbClient, err := networkloadbalancer.NewNetworkLoadBalancerClientWithConfigurationProvider(ociAuthConfigProvider)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error(err, "unable to create OCI LB Client")
                return nil, err
        }</span>
        <span class="cov8" title="1">nlbClient.SetRegion(region)
        dispatcher := nlbClient.HTTPClient
        nlbClient.HTTPClient = metrics.NewHttpRequestDispatcherWrapper(dispatcher, region)

        if c.ociClientOverrides != nil &amp;&amp; c.ociClientOverrides.NetworkLoadBalancerClientUrl != nil </span><span class="cov0" title="0">{
                nlbClient.Host = *c.ociClientOverrides.NetworkLoadBalancerClientUrl
        }</span>
        <span class="cov8" title="1">nlbClient.Interceptor = setVersionHeader()

        return &amp;nlbClient, nil</span>
}

func (c *ClientProvider) createLBClient(region string, ociAuthConfigProvider common.ConfigurationProvider, logger *logr.Logger) (*loadbalancer.LoadBalancerClient, error) <span class="cov8" title="1">{
        lbClient, err := loadbalancer.NewLoadBalancerClientWithConfigurationProvider(ociAuthConfigProvider)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error(err, "unable to create OCI LBaaS Client")
                return nil, err
        }</span>
        <span class="cov8" title="1">lbClient.SetRegion(region)
        dispatcher := lbClient.HTTPClient
        lbClient.HTTPClient = metrics.NewHttpRequestDispatcherWrapper(dispatcher, region)

        if c.ociClientOverrides != nil &amp;&amp; c.ociClientOverrides.LoadBalancerClientUrl != nil </span><span class="cov0" title="0">{
                lbClient.Host = *c.ociClientOverrides.LoadBalancerClientUrl
        }</span>
        <span class="cov8" title="1">lbClient.Interceptor = setVersionHeader()

        return &amp;lbClient, nil</span>
}

func (c *ClientProvider) createIdentityClient(region string, ociAuthConfigProvider common.ConfigurationProvider, logger *logr.Logger) (*identity.IdentityClient, error) <span class="cov8" title="1">{
        identityClt, err := identity.NewIdentityClientWithConfigurationProvider(ociAuthConfigProvider)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error(err, "unable to create OCI Identity Client")
                return nil, err
        }</span>
        <span class="cov8" title="1">identityClt.SetRegion(region)
        dispatcher := identityClt.HTTPClient
        identityClt.HTTPClient = metrics.NewHttpRequestDispatcherWrapper(dispatcher, region)

        if c.ociClientOverrides != nil &amp;&amp; c.ociClientOverrides.IdentityClientUrl != nil </span><span class="cov0" title="0">{
                identityClt.Host = *c.ociClientOverrides.IdentityClientUrl
        }</span>
        <span class="cov8" title="1">identityClt.Interceptor = setVersionHeader()

        return &amp;identityClt, nil</span>
}

func (c *ClientProvider) createComputeClient(region string, ociAuthConfigProvider common.ConfigurationProvider, logger *logr.Logger) (compute.ComputeClient, error) <span class="cov8" title="1">{
        computeClient, err := core.NewComputeClientWithConfigurationProvider(ociAuthConfigProvider)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error(err, "unable to create OCI Compute Client")
                return nil, err
        }</span>
        <span class="cov8" title="1">computeClient.SetRegion(region)
        dispatcher := computeClient.HTTPClient
        computeClient.HTTPClient = metrics.NewHttpRequestDispatcherWrapper(dispatcher, region)

        if c.ociClientOverrides != nil &amp;&amp; c.ociClientOverrides.ComputeClientUrl != nil </span><span class="cov0" title="0">{
                computeClient.Host = *c.ociClientOverrides.ComputeClientUrl
        }</span>
        <span class="cov8" title="1">computeClient.Interceptor = setVersionHeader()

        return &amp;computeClient, nil</span>
}

func (c *ClientProvider) createComputeManagementClient(region string, ociAuthConfigProvider common.ConfigurationProvider, logger *logr.Logger) (*core.ComputeManagementClient, error) <span class="cov8" title="1">{
        computeManagementClient, err := core.NewComputeManagementClientWithConfigurationProvider(ociAuthConfigProvider)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error(err, "unable to create OCI Compute Management Client")
                return nil, err
        }</span>
        <span class="cov8" title="1">computeManagementClient.SetRegion(region)
        dispatcher := computeManagementClient.HTTPClient
        computeManagementClient.HTTPClient = metrics.NewHttpRequestDispatcherWrapper(dispatcher, region)

        if c.ociClientOverrides != nil &amp;&amp; c.ociClientOverrides.ComputeManagementClientUrl != nil </span><span class="cov0" title="0">{
                computeManagementClient.Host = *c.ociClientOverrides.ComputeManagementClientUrl
        }</span>
        <span class="cov8" title="1">computeManagementClient.Interceptor = setVersionHeader()

        return &amp;computeManagementClient, nil</span>
}

func (c *ClientProvider) createContainerEngineClient(region string, ociAuthConfigProvider common.ConfigurationProvider, logger *logr.Logger) (*containerengine.ContainerEngineClient, error) <span class="cov8" title="1">{
        containerEngineClt, err := containerengine.NewContainerEngineClientWithConfigurationProvider(ociAuthConfigProvider)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error(err, "unable to create OCI Container Engine Client")
                return nil, err
        }</span>
        <span class="cov8" title="1">containerEngineClt.SetRegion(region)
        dispatcher := containerEngineClt.HTTPClient
        containerEngineClt.HTTPClient = metrics.NewHttpRequestDispatcherWrapper(dispatcher, region)

        if c.ociClientOverrides != nil &amp;&amp; c.ociClientOverrides.ContainerEngineClientUrl != nil </span><span class="cov0" title="0">{
                containerEngineClt.Host = *c.ociClientOverrides.ContainerEngineClientUrl
        }</span>
        <span class="cov8" title="1">containerEngineClt.Interceptor = setVersionHeader()

        return &amp;containerEngineClt, nil</span>
}

func (c *ClientProvider) createWorkrequestsClient(region string, ociAuthConfigProvider common.ConfigurationProvider, logger *logr.Logger) (*workrequests.WorkRequestClient, error) <span class="cov8" title="1">{
        workrequestsClt, err := workrequests.NewWorkRequestClientWithConfigurationProvider(ociAuthConfigProvider)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error(err, "unable to create OCI WorkRequests client")
                return nil, err
        }</span>
        <span class="cov8" title="1">workrequestsClt.SetRegion(region)
        dispatcher := workrequestsClt.HTTPClient
        workrequestsClt.HTTPClient = metrics.NewHttpRequestDispatcherWrapper(dispatcher, region)

        if c.ociClientOverrides != nil &amp;&amp; c.ociClientOverrides.WorkrequestClientUrl != nil </span><span class="cov0" title="0">{
                workrequestsClt.Host = *c.ociClientOverrides.WorkrequestClientUrl
        }</span>
        <span class="cov8" title="1">workrequestsClt.Interceptor = setVersionHeader()

        return &amp;workrequestsClt, nil</span>
}

func (c *ClientProvider) createBaseClient(region string, ociAuthConfigProvider common.ConfigurationProvider, logger *logr.Logger) (base.BaseClient, error) <span class="cov8" title="1">{
        baseClient, err := base.NewBaseClient(ociAuthConfigProvider, logger)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error(err, "unable to create OCI Base Client")
                return nil, err
        }</span>
        <span class="cov8" title="1">return baseClient, nil</span>
}

func setVersionHeader() func(request *http.Request) error <span class="cov8" title="1">{
        return func(request *http.Request) error </span><span class="cov0" title="0">{
                request.Header.Set("X-CAPOCI-VERSION", version.GitVersion)
                return nil
        }</span>
}
</pre>
		
		<pre class="file" id="file38" style="display: none">/*
Copyright (c) 2022, Oracle and/or its affiliates.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package scope

import (
        "bytes"
        "crypto/rand"
        "crypto/rsa"
        "crypto/x509"
        "encoding/pem"
        "fmt"
        "sync"

        "github.com/oracle/cluster-api-provider-oci/cloud/config"
        "github.com/oracle/cluster-api-provider-oci/cloud/services/compute"
        "github.com/oracle/cluster-api-provider-oci/cloud/services/identity"
        "github.com/oracle/cluster-api-provider-oci/cloud/services/vcn"
        "github.com/oracle/oci-go-sdk/v65/loadbalancer"
        "github.com/oracle/oci-go-sdk/v65/networkloadbalancer"
        "github.com/oracle/oci-go-sdk/v65/workrequests"
        "k8s.io/klog/v2/klogr"
)

type MockOCIClients struct {
        VCNClient                 vcn.Client
        ComputeClient             compute.ComputeClient
        NetworkLoadBalancerClient *networkloadbalancer.NetworkLoadBalancerClient
        LoadBalancerClient        *loadbalancer.LoadBalancerClient
        IdentityClient            identity.Client
        WorkRequestsClient        *workrequests.WorkRequestClient
}

var (
        MockTestRegion = "us-lexington-1"
)

func MockNewClientProvider(mockClients MockOCIClients) (*ClientProvider, error) <span class="cov8" title="1">{

        clientsInject := map[string]OCIClients{MockTestRegion: {
                VCNClient:                 mockClients.VCNClient,
                NetworkLoadBalancerClient: mockClients.NetworkLoadBalancerClient,
                LoadBalancerClient:        mockClients.LoadBalancerClient,
                IdentityClient:            mockClients.IdentityClient,
                ComputeClient:             mockClients.ComputeClient,
                WorkRequestsClient:        mockClients.WorkRequestsClient,
        }}

        authConfig, err := MockAuthConfig()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">ociAuthConfigProvider, err := config.NewConfigurationProvider(&amp;authConfig)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("expected ociAuthConfigProvider to be created %s \n", err)
                return nil, err
        }</span>
        <span class="cov8" title="1">log := klogr.New()
        clientProvider := ClientProvider{
                Logger:                &amp;log,
                ociClients:            clientsInject,
                ociClientsLock:        new(sync.RWMutex),
                ociAuthConfigProvider: ociAuthConfigProvider,
        }

        return &amp;clientProvider, nil</span>
}

func MockAuthConfig() (config.AuthConfig, error) <span class="cov8" title="1">{
        privateKey, err := generatePrivateKeyPEM()
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println("error generating a private key")
                return config.AuthConfig{}, err
        }</span>

        <span class="cov8" title="1">authConfig := config.AuthConfig{
                UseInstancePrincipals: false,
                Region:                MockTestRegion,
                Fingerprint:           "mock_computemanagement-finger-print",
                PrivateKey:            privateKey,
                UserID:                "ocid1.tenancy.oc1..&lt;unique_ID&gt;",
                TenancyID:             "ocid1.tenancy.oc1..&lt;unique_ID&gt;",
        }

        return authConfig, nil</span>
}

func generatePrivateKeyPEM() (string, error) <span class="cov8" title="1">{
        privateKey, err := rsa.GenerateKey(rand.Reader, 2048)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov8" title="1">privateKeyBytes := x509.MarshalPKCS1PrivateKey(privateKey)
        privateKeyBlock := &amp;pem.Block{
                Type:  "RSA PRIVATE KEY",
                Bytes: privateKeyBytes,
        }

        var privateKeyBuf bytes.Buffer
        err = pem.Encode(&amp;privateKeyBuf, privateKeyBlock)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("error when encode private pem: %s \n", err)
                return "", err
        }</span>

        <span class="cov8" title="1">return privateKeyBuf.String(), err</span>
}
</pre>
		
		<pre class="file" id="file39" style="display: none">/*
 Copyright (c) 2021, 2022 Oracle and/or its affiliates.

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

      https://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
*/

package scope

import (
        "context"
        "fmt"
        "strconv"
        "strings"

        "github.com/go-logr/logr"
        infrastructurev1beta2 "github.com/oracle/cluster-api-provider-oci/api/v1beta2"
        "github.com/oracle/cluster-api-provider-oci/cloud/ociutil"
        identityClient "github.com/oracle/cluster-api-provider-oci/cloud/services/identity"
        lb "github.com/oracle/cluster-api-provider-oci/cloud/services/loadbalancer"
        nlb "github.com/oracle/cluster-api-provider-oci/cloud/services/networkloadbalancer"
        "github.com/oracle/cluster-api-provider-oci/cloud/services/vcn"
        "github.com/oracle/oci-go-sdk/v65/common"
        "github.com/oracle/oci-go-sdk/v65/identity"
        "github.com/pkg/errors"
        "k8s.io/klog/v2/klogr"
        clusterv1 "sigs.k8s.io/cluster-api/api/core/v1beta1"
        "sigs.k8s.io/cluster-api/util/patch"
        "sigs.k8s.io/controller-runtime/pkg/client"
)

const (
        AvailabilityDomain                = "AvailabilityDomain"
        FaultDomain                       = "FaultDomain"
        OCIClusterKind                    = "OCICluster"
        OCIManagedClusterKind             = "OCIManagedCluster"
        OCIManagedClusterControlPlaneKind = "OCIManagedClusterControlPlane"
)

// ClusterScopeParams defines the params need to create a new ClusterScope
type ClusterScopeParams struct {
        Client                    client.Client
        Logger                    *logr.Logger
        Cluster                   *clusterv1.Cluster
        VCNClient                 vcn.Client
        NetworkLoadBalancerClient nlb.NetworkLoadBalancerClient
        LoadBalancerClient        lb.LoadBalancerClient
        IdentityClient            identityClient.Client
        // RegionIdentifier Identifier as specified here https://docs.oracle.com/en-us/iaas/Content/General/Concepts/regions.htm
        RegionIdentifier      string
        OCIAuthConfigProvider common.ConfigurationProvider
        ClientProvider        *ClientProvider
        OCIClusterAccessor    OCIClusterAccessor
        // RegionIdentifier Key as specified here https://docs.oracle.com/en-us/iaas/Content/General/Concepts/regions.htm
        RegionKey string
}

type ClusterScope struct {
        *logr.Logger
        client                    client.Client
        patchHelper               *patch.Helper
        Cluster                   *clusterv1.Cluster
        VCNClient                 vcn.Client
        NetworkLoadBalancerClient nlb.NetworkLoadBalancerClient
        LoadBalancerClient        lb.LoadBalancerClient
        IdentityClient            identityClient.Client
        // RegionIdentifier Identifier as specified here https://docs.oracle.com/en-us/iaas/Content/General/Concepts/regions.htm
        RegionIdentifier   string
        ClientProvider     *ClientProvider
        OCIClusterAccessor OCIClusterAccessor
        // RegionIdentifier Key as specified here https://docs.oracle.com/en-us/iaas/Content/General/Concepts/regions.htm
        RegionKey string
}

// NewClusterScope creates a ClusterScope given the ClusterScopeParams
func NewClusterScope(params ClusterScopeParams) (*ClusterScope, error) <span class="cov8" title="1">{
        // TODO add conditions everywhere properly and events as well
        if params.Cluster == nil </span><span class="cov0" title="0">{
                return nil, errors.New("failed to generate new scope from nil Cluster")
        }</span>
        <span class="cov8" title="1">if params.OCIClusterAccessor == nil </span><span class="cov0" title="0">{
                return nil, errors.New("failed to generate new scope from nil OCIClusterAccessor")
        }</span>

        <span class="cov8" title="1">if params.Logger == nil </span><span class="cov8" title="1">{
                log := klogr.New()
                params.Logger = &amp;log
        }</span>

        <span class="cov8" title="1">return &amp;ClusterScope{
                Logger:                    params.Logger,
                client:                    params.Client,
                Cluster:                   params.Cluster,
                VCNClient:                 params.VCNClient,
                NetworkLoadBalancerClient: params.NetworkLoadBalancerClient,
                LoadBalancerClient:        params.LoadBalancerClient,
                IdentityClient:            params.IdentityClient,
                RegionIdentifier:          params.RegionIdentifier,
                ClientProvider:            params.ClientProvider,
                OCIClusterAccessor:        params.OCIClusterAccessor,
                RegionKey:                 params.RegionKey,
        }, nil</span>
}

func (s *ClusterScope) IsResourceCreatedByClusterAPI(resourceFreeFormTags map[string]string) bool <span class="cov8" title="1">{
        tagsAddedByClusterAPI := ociutil.BuildClusterTags(s.OCIClusterAccessor.GetOCIResourceIdentifier())
        for k, v := range tagsAddedByClusterAPI </span><span class="cov8" title="1">{
                if resourceFreeFormTags[k] != v </span><span class="cov8" title="1">{
                        return false
                }</span>
        }
        <span class="cov8" title="1">return true</span>
}

func (s *ClusterScope) ReconcileFailureDomains(ctx context.Context) error <span class="cov8" title="1">{
        if s.OCIClusterAccessor.GetFailureDomains() == nil </span><span class="cov8" title="1">{
                return s.setFailureDomains(ctx)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// setFailureDomains sets the failure domains of the environment based on whether it is single AD or multi AD regions
// in case of single AD regions, the failure domain will be fault domain, in case of multi Ad regions, it will
// be AD
func (s *ClusterScope) setFailureDomains(ctx context.Context) error <span class="cov8" title="1">{
        adMap := s.OCIClusterAccessor.GetAvailabilityDomains()
        if adMap == nil </span><span class="cov8" title="1">{
                reqAd := identity.ListAvailabilityDomainsRequest{CompartmentId: common.String(s.GetCompartmentId())}

                respAd, err := s.IdentityClient.ListAvailabilityDomains(ctx, reqAd)
                if err != nil </span><span class="cov8" title="1">{
                        s.Logger.Error(err, "failed to list identity domains")
                        return err
                }</span>

                // build the AD list for cluster
                <span class="cov8" title="1">adMap, err = s.setAvailabiltyDomainSpec(ctx, respAd.Items)
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">numOfAds := len(adMap)
        if numOfAds != 1 &amp;&amp; numOfAds != 3 </span><span class="cov8" title="1">{
                err := errors.New(fmt.Sprintf("invalid number of Availability Domains, should be either 1 or 3, but got %d", numOfAds))
                s.Logger.Error(err, "invalid number of Availability Domains")
                return err
        }</span>

        <span class="cov8" title="1">if numOfAds == 3 </span><span class="cov8" title="1">{
                for k := range adMap </span><span class="cov8" title="1">{
                        adIndex := strings.LastIndexAny(k, "-")
                        if adIndex &lt; 0 </span><span class="cov8" title="1">{
                                return errors.New(fmt.Sprintf("could not infer ad number from availability domain %s", k))
                        }</span>
                        <span class="cov8" title="1">adNumber := k[adIndex+1:]
                        _, err := strconv.Atoi(adNumber)
                        if err != nil </span><span class="cov0" title="0">{
                                return errors.New(fmt.Sprintf("availability domain is not a valid integer: availability domain %s", k))
                        }</span>
                        <span class="cov8" title="1">s.SetFailureDomain(adNumber, clusterv1.FailureDomainSpec{
                                ControlPlane: true,
                                Attributes:   map[string]string{AvailabilityDomain: k},
                        })</span>
                }
        } else<span class="cov8" title="1"> {
                // only first element is used, hence break at the end
                for k := range adMap </span><span class="cov8" title="1">{
                        for i, fd := range adMap[k].FaultDomains </span><span class="cov8" title="1">{
                                s.SetFailureDomain(strconv.Itoa(i+1), clusterv1.FailureDomainSpec{
                                        ControlPlane: true,
                                        Attributes: map[string]string{
                                                AvailabilityDomain: k,
                                                FaultDomain:        fd,
                                        },
                                })
                        }</span>
                        <span class="cov8" title="1">break</span>
                }

        }

        <span class="cov8" title="1">return nil</span>
}

// SetFailureDomain sets the cluster's failure domain in the status
func (s *ClusterScope) SetFailureDomain(id string, spec clusterv1.FailureDomainSpec) <span class="cov8" title="1">{
        s.OCIClusterAccessor.SetFailureDomain(id, spec)
}</span>

// setAvailabiltyDomainSpec builds the OCIAvailabilityDomain list and sets the OCICluster's spec with this list
// so that other parts of the provider have access to ADs and FDs without having to make multiple calls to identity.
func (s *ClusterScope) setAvailabiltyDomainSpec(ctx context.Context, ads []identity.AvailabilityDomain) (map[string]infrastructurev1beta2.OCIAvailabilityDomain, error) <span class="cov8" title="1">{
        clusterAds := make(map[string]infrastructurev1beta2.OCIAvailabilityDomain)
        for _, ad := range ads </span><span class="cov8" title="1">{
                reqFd := identity.ListFaultDomainsRequest{
                        CompartmentId:      common.String(s.GetCompartmentId()),
                        AvailabilityDomain: ad.Name,
                }
                respFd, err := s.IdentityClient.ListFaultDomains(ctx, reqFd)
                if err != nil </span><span class="cov8" title="1">{
                        s.Logger.Error(err, "failed to list fault domains")
                        return nil, err
                }</span>

                <span class="cov8" title="1">var faultDomains []string
                for _, fd := range respFd.Items </span><span class="cov8" title="1">{
                        faultDomains = append(faultDomains, *fd.Name)
                }</span>

                <span class="cov8" title="1">adName := *ad.Name
                clusterAds[adName] = infrastructurev1beta2.OCIAvailabilityDomain{
                        Name:         adName,
                        FaultDomains: faultDomains,
                }</span>
        }
        <span class="cov8" title="1">s.OCIClusterAccessor.SetAvailabilityDomains(clusterAds)

        return clusterAds, nil</span>
}

// GetDefinedTags returns a map of DefinedTags defined in the OCICluster's spec
func (s *ClusterScope) GetDefinedTags() map[string]map[string]interface{} <span class="cov8" title="1">{
        tags := s.OCIClusterAccessor.GetDefinedTags()
        if tags == nil </span><span class="cov8" title="1">{
                return make(map[string]map[string]interface{})
        }</span>
        <span class="cov8" title="1">definedTags := make(map[string]map[string]interface{})
        for ns, mapNs := range tags </span><span class="cov8" title="1">{
                mapValues := make(map[string]interface{})
                for k, v := range mapNs </span><span class="cov8" title="1">{
                        mapValues[k] = v
                }</span>
                <span class="cov8" title="1">definedTags[ns] = mapValues</span>
        }
        <span class="cov8" title="1">return definedTags</span>
}

// GetCompartmentId returns the CompartmentId defined in OCICluster's spec
func (s *ClusterScope) GetCompartmentId() string <span class="cov8" title="1">{
        return s.OCIClusterAccessor.GetCompartmentId()
}</span>

// APIServerPort returns the APIServerPort to use when creating the load balancer.
func (s *ClusterScope) APIServerPort() int32 <span class="cov8" title="1">{
        if s.Cluster.Spec.ClusterNetwork != nil &amp;&amp; s.Cluster.Spec.ClusterNetwork.APIServerPort != nil </span><span class="cov0" title="0">{
                return *s.Cluster.Spec.ClusterNetwork.APIServerPort
        }</span>
        <span class="cov8" title="1">return ApiServerPort</span>
}

// GetFreeFormTags returns a map of FreeformTags defined in the OCICluster's spec
func (s *ClusterScope) GetFreeFormTags() map[string]string <span class="cov8" title="1">{
        tags := s.OCIClusterAccessor.GetFreeformTags()
        completeTags := make(map[string]string)
        for k, v := range tags </span><span class="cov8" title="1">{
                completeTags[k] = v
        }</span>
        <span class="cov8" title="1">tagsAddedByClusterAPI := ociutil.BuildClusterTags(s.OCIClusterAccessor.GetOCIResourceIdentifier())
        for k, v := range tagsAddedByClusterAPI </span><span class="cov8" title="1">{
                completeTags[k] = v
        }</span>
        <span class="cov8" title="1">return completeTags</span>
}

func (s *ClusterScope) GetOCIClusterAccessor() OCIClusterAccessor <span class="cov0" title="0">{
        return s.OCIClusterAccessor
}</span>

func (s *ClusterScope) getDRG() *infrastructurev1beta2.DRG <span class="cov8" title="1">{
        return s.OCIClusterAccessor.GetNetworkSpec().VCNPeering.DRG
}</span>

func (s *ClusterScope) getDrgID() *string <span class="cov8" title="1">{
        return s.getDRG().ID
}</span>

func (s *ClusterScope) isPeeringEnabled() bool <span class="cov8" title="1">{
        return s.OCIClusterAccessor.GetNetworkSpec().VCNPeering != nil
}</span>

// SetRegionKey sets the region key in the scope
func (s *ClusterScope) SetRegionKey(ctx context.Context) error <span class="cov0" title="0">{
        regionCode, err := GetRegionCodeFromRegion(ctx, s.IdentityClient, s.RegionIdentifier)
        if err != nil </span><span class="cov0" title="0">{
                s.Logger.Error(err, "failed to get shortId for the region")
                return err
        }</span>
        <span class="cov0" title="0">s.RegionKey = regionCode
        return nil</span>
}

// GetRegionCodeFromRegion pulls all OCI regions available and returns the passed in region's code if contained in
// the list.
//
// example: "ca-toronto-1" -&gt; "YYZ"
func GetRegionCodeFromRegion(ctx context.Context, identityClient identityClient.Client, region string) (string, error) <span class="cov0" title="0">{
        regionCodes, err := identityClient.ListRegions(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return "", errors.Wrap(err, "failed to list oci regions")
        }</span>
        <span class="cov0" title="0">for _, regionCode := range regionCodes.Items </span><span class="cov0" title="0">{
                if *regionCode.Name == region </span><span class="cov0" title="0">{
                        return *regionCode.Key, nil
                }</span>
        }
        <span class="cov0" title="0">return "", errors.Errorf("unable to get region code from region name")</span>
}
</pre>
		
		<pre class="file" id="file40" style="display: none">/*
 Copyright (c) 2021, 2022 Oracle and/or its affiliates.

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

      https://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
*/

package scope

import (
        "context"
        "fmt"

        "github.com/oracle/cluster-api-provider-oci/cloud/ociutil"
        "github.com/oracle/oci-go-sdk/v65/common"
        "github.com/oracle/oci-go-sdk/v65/core"
        "github.com/pkg/errors"
)

// ReconcileDRG tries to move the DRG to the desired OCICluster Spec
func (s *ClusterScope) ReconcileDRG(ctx context.Context) error <span class="cov8" title="1">{
        if !s.isPeeringEnabled() </span><span class="cov8" title="1">{
                s.Logger.Info("VCN Peering is not enabled, ignoring reconciliation")
                return nil
        }</span>
        <span class="cov8" title="1">if s.getDRG() == nil </span><span class="cov8" title="1">{
                s.Logger.Info("DRG is not enabled, ignoring reconciliation")
                return nil
        }</span>
        <span class="cov8" title="1">if !s.getDRG().Manage </span><span class="cov8" title="1">{
                s.Logger.Info("DRG Manage is specified as false, will skip reconciliation of the DRG")
                return nil
        }</span>
        <span class="cov8" title="1">drg, err := s.GetDRG(ctx)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">if drg != nil </span><span class="cov8" title="1">{
                s.getDRG().ID = drg.Id
                s.Logger.Info("No Reconciliation Required for DRG", "drg", drg.Id)
                return nil
        }</span>

        <span class="cov8" title="1">drg, err = s.createDRG(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">s.getDRG().ID = drg.Id
        s.Logger.Info("Successfully created DRG", "drg", *drg.Id)
        return nil</span>
}

// GetDRG retrieves the Cluster's core.Drg using the one of the following methods
//
// 1. the OCICluster's spec Drg
//
// 2. Listing the Drgs for the Compartment (by ID) and filtering by tag
// nolint:nilnil
func (s *ClusterScope) GetDRG(ctx context.Context) (*core.Drg, error) <span class="cov8" title="1">{
        drgId := s.getDRG().ID
        if drgId != nil </span><span class="cov8" title="1">{
                response, err := s.VCNClient.GetDrg(ctx, core.GetDrgRequest{
                        DrgId: drgId,
                })
                if err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">drg := response.Drg
                if s.IsResourceCreatedByClusterAPI(drg.FreeformTags) </span><span class="cov8" title="1">{
                        return &amp;drg, nil
                }</span> else<span class="cov0" title="0"> {
                        return nil, errors.New("cluster api tags have been modified out of context")
                }</span>
        }
        <span class="cov8" title="1">var page *string

        for </span><span class="cov8" title="1">{
                response, err := s.VCNClient.ListDrgs(ctx, core.ListDrgsRequest{
                        CompartmentId: common.String(s.GetCompartmentId()),
                        Page:          page,
                })
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">for _, drg := range response.Items </span><span class="cov0" title="0">{
                        if *drg.DisplayName == s.getDRG().Name </span><span class="cov0" title="0">{
                                if s.IsResourceCreatedByClusterAPI(drg.FreeformTags) </span><span class="cov0" title="0">{
                                        return &amp;drg, nil
                                }</span> else<span class="cov0" title="0"> {
                                        return nil, errors.New("cluster api tags have been modified out of context")
                                }</span>
                        }
                }
                <span class="cov8" title="1">if response.OpcNextPage == nil </span><span class="cov8" title="1">{
                        break</span>
                } else<span class="cov0" title="0"> {
                        page = response.OpcNextPage
                }</span>
        }

        <span class="cov8" title="1">return nil, nil</span>
}

func (s *ClusterScope) createDRG(ctx context.Context) (*core.Drg, error) <span class="cov8" title="1">{
        response, err := s.VCNClient.CreateDrg(ctx, core.CreateDrgRequest{
                CreateDrgDetails: core.CreateDrgDetails{
                        CompartmentId: common.String(s.GetCompartmentId()),
                        FreeformTags:  s.GetFreeFormTags(),
                        DefinedTags:   s.GetDefinedTags(),
                        DisplayName:   common.String(s.GetDRGName()),
                },
                OpcRetryToken: ociutil.GetOPCRetryToken("%s-%s", "create-drg", string(s.OCIClusterAccessor.GetOCIResourceIdentifier())),
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return &amp;response.Drg, nil</span>
}

func (s *ClusterScope) GetDRGName() string <span class="cov8" title="1">{
        if s.getDRG().Name != "" </span><span class="cov0" title="0">{
                return s.getDRG().Name
        }</span>
        <span class="cov8" title="1">return fmt.Sprintf("%s", s.OCIClusterAccessor.GetName())</span>
}

// DeleteDRG tries to delete the DRG
func (s *ClusterScope) DeleteDRG(ctx context.Context) error <span class="cov8" title="1">{
        if !s.isPeeringEnabled() </span><span class="cov8" title="1">{
                s.Logger.Info("VCN Peering is not enabled, ignoring reconciliation")
                return nil
        }</span>
        <span class="cov8" title="1">if s.getDRG() == nil </span><span class="cov8" title="1">{
                s.Logger.Info("DRG is not enabled, ignoring reconciliation")
                return nil
        }</span>
        <span class="cov8" title="1">if !s.getDRG().Manage </span><span class="cov8" title="1">{
                s.Logger.Info("DRG Manage is specified as false, will skip deletion of the DRG")
                return nil
        }</span>

        <span class="cov8" title="1">drg, err := s.GetDRG(ctx)

        if err != nil &amp;&amp; !ociutil.IsNotFound(err) </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">if drg == nil </span><span class="cov8" title="1">{
                s.Logger.Info("DRG is already deleted")
                return nil
        }</span>
        <span class="cov8" title="1">_, err = s.VCNClient.DeleteDrg(ctx, core.DeleteDrgRequest{
                DrgId: drg.Id,
        })
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file41" style="display: none">/*
 Copyright (c) 2021, 2022 Oracle and/or its affiliates.

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

      https://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
*/

package scope

import (
        "context"
        "time"

        "github.com/oracle/cluster-api-provider-oci/cloud/ociutil"
        vcn "github.com/oracle/cluster-api-provider-oci/cloud/services/vcn"
        "github.com/oracle/oci-go-sdk/v65/common"
        "github.com/oracle/oci-go-sdk/v65/core"
        "github.com/pkg/errors"
        "k8s.io/apimachinery/pkg/util/wait"
)

const (
        PollInterval   = 5 * time.Second
        RequestTimeout = 2 * time.Minute
)

// ReconcileDRGRPCAttachment reconciles DRG RPC attachments
func (s *ClusterScope) ReconcileDRGRPCAttachment(ctx context.Context) error <span class="cov8" title="1">{
        if !s.isPeeringEnabled() </span><span class="cov8" title="1">{
                s.Logger.Info("VCN Peering is not enabled, ignoring reconciliation")
                return nil
        }</span>

        <span class="cov8" title="1">if s.getDRG() == nil </span><span class="cov8" title="1">{
                return errors.New("DRG has not been specified")
        }</span>
        <span class="cov8" title="1">if s.getDrgID() == nil </span><span class="cov8" title="1">{
                return errors.New("DRG ID has not been set")
        }</span>

        <span class="cov8" title="1">for _, rpcSpec := range s.OCIClusterAccessor.GetNetworkSpec().VCNPeering.RemotePeeringConnections </span><span class="cov8" title="1">{
                localRpc, err := s.lookupRPC(ctx, s.getDrgID(), rpcSpec.RPCConnectionId, s.VCNClient)
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
                <span class="cov8" title="1">if localRpc != nil </span><span class="cov0" title="0">{
                        rpcSpec.RPCConnectionId = localRpc.Id
                        s.Logger.Info("Local RPC exists", "rpcId", localRpc.Id)
                }</span> else<span class="cov8" title="1"> {
                        localRpc, err = s.createRPC(ctx, s.getDrgID(), s.OCIClusterAccessor.GetName(), s.VCNClient)
                        if err != nil </span><span class="cov8" title="1">{
                                return err
                        }</span>
                        <span class="cov8" title="1">s.Logger.Info("Local RPC has been created", "rpcId", localRpc.Id)
                        rpcSpec.RPCConnectionId = localRpc.Id</span>
                }
                <span class="cov8" title="1">err = s.waitForRPCToBeProvisioned(ctx, localRpc, s.VCNClient)
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>

                <span class="cov8" title="1">if rpcSpec.PeerDRGId == nil </span><span class="cov8" title="1">{
                        return errors.New("peer DRG ID has not been specified")
                }</span>
                <span class="cov8" title="1">if rpcSpec.ManagePeerRPC </span><span class="cov8" title="1">{
                        clientProvider, err := s.ClientProvider.GetOrBuildClient(rpcSpec.PeerRegionName)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">remoteRpc, err := s.lookupRPC(ctx, rpcSpec.PeerDRGId, rpcSpec.PeerRPCConnectionId, clientProvider.VCNClient)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">if remoteRpc != nil </span><span class="cov0" title="0">{
                                s.Logger.Info("Remote RPC exists", "rpcId", localRpc.Id)
                                s.Logger.Info("Connection status of 2 peered RPCs", "status", localRpc.PeeringStatus)
                                rpcSpec.PeerRPCConnectionId = remoteRpc.Id
                        }</span> else<span class="cov8" title="1"> {
                                remoteRpc, err = s.createRPC(ctx, rpcSpec.PeerDRGId, s.OCIClusterAccessor.GetName(), clientProvider.VCNClient)
                                if err != nil </span><span class="cov8" title="1">{
                                        return err
                                }</span>
                                <span class="cov8" title="1">s.Logger.Info("Remote RPC has been created", "rpcId", remoteRpc.Id)
                                rpcSpec.PeerRPCConnectionId = remoteRpc.Id</span>
                        }
                        <span class="cov8" title="1">err = s.waitForRPCToBeProvisioned(ctx, remoteRpc, clientProvider.VCNClient)
                        if err != nil </span><span class="cov8" title="1">{
                                return err
                        }</span>
                }

                <span class="cov8" title="1">if localRpc.PeeringStatus == core.RemotePeeringConnectionPeeringStatusNew </span><span class="cov8" title="1">{
                        if rpcSpec.PeerRPCConnectionId == nil </span><span class="cov8" title="1">{
                                return errors.New("peer RPC Connection ID is empty")
                        }</span>
                        <span class="cov8" title="1">_, err := s.VCNClient.ConnectRemotePeeringConnections(ctx, core.ConnectRemotePeeringConnectionsRequest{
                                RemotePeeringConnectionId: rpcSpec.RPCConnectionId,
                                ConnectRemotePeeringConnectionsDetails: core.ConnectRemotePeeringConnectionsDetails{
                                        PeerId:         rpcSpec.PeerRPCConnectionId,
                                        PeerRegionName: common.String(rpcSpec.PeerRegionName),
                                },
                        })
                        if err != nil </span><span class="cov8" title="1">{
                                return err
                        }</span>
                        <span class="cov8" title="1">s.Logger.Info("Connect request initiated for local and peer RPCs", "rpcId", rpcSpec.RPCConnectionId)</span>
                }
                <span class="cov8" title="1">if localRpc.PeeringStatus != core.RemotePeeringConnectionPeeringStatusPeered </span><span class="cov8" title="1">{
                        err := wait.PollWithContext(ctx, PollInterval, RequestTimeout, func(ctx context.Context) (done bool, err error) </span><span class="cov8" title="1">{
                                rpc, err := s.getRPC(ctx, localRpc.Id, s.VCNClient)
                                if err != nil </span><span class="cov0" title="0">{
                                        return true, err
                                }</span>
                                <span class="cov8" title="1">s.Logger.Info("RPC peering status", "rpcId", rpc.Id, "peeringStatus", localRpc.PeeringStatus)
                                switch rpc.PeeringStatus </span>{
                                case core.RemotePeeringConnectionPeeringStatusPeered:<span class="cov8" title="1">
                                        return true, nil</span>
                                case core.RemotePeeringConnectionPeeringStatusRevoked, core.RemotePeeringConnectionPeeringStatusInvalid,
                                        core.RemotePeeringConnectionPeeringStatusNew:<span class="cov8" title="1">
                                        return true, errors.Errorf("invalid peering status %s of RPC %s", rpc.PeeringStatus, *rpc.Id)</span>
                                case core.RemotePeeringConnectionPeeringStatusPending:<span class="cov0" title="0">
                                        return false, nil</span>
                                }
                                <span class="cov0" title="0">return false, nil</span>
                        })
                        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                                return err
                        }</span>
                }
                <span class="cov8" title="1">s.Logger.Info("Connection has been established between the 2 peered RPCs")</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (s *ClusterScope) createRPC(ctx context.Context, drgId *string, displayName string, vcnClient vcn.Client) (*core.RemotePeeringConnection, error) <span class="cov8" title="1">{
        response, err := vcnClient.CreateRemotePeeringConnection(ctx, core.CreateRemotePeeringConnectionRequest{
                CreateRemotePeeringConnectionDetails: core.CreateRemotePeeringConnectionDetails{
                        DisplayName:   common.String(displayName),
                        DrgId:         drgId,
                        FreeformTags:  s.GetFreeFormTags(),
                        DefinedTags:   s.GetDefinedTags(),
                        CompartmentId: common.String(s.GetCompartmentId()),
                },
        })
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;response.RemotePeeringConnection, nil</span>
}

// nolint:nilnil
func (s *ClusterScope) lookupRPC(ctx context.Context, drgId *string, rpcId *string, vcnClient vcn.Client) (*core.RemotePeeringConnection, error) <span class="cov8" title="1">{
        if rpcId != nil </span><span class="cov8" title="1">{
                attachment, err := s.getRPC(ctx, rpcId, vcnClient)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">if s.IsResourceCreatedByClusterAPI(attachment.FreeformTags) </span><span class="cov8" title="1">{
                        return attachment, nil
                }</span> else<span class="cov0" title="0"> {
                        return nil, errors.New("cluster api tags have been modified out of context")
                }</span>
        } else<span class="cov8" title="1"> {
                var rpcs []core.RemotePeeringConnection
                for </span><span class="cov8" title="1">{
                        var page *string
                        response, err := vcnClient.ListRemotePeeringConnections(ctx, core.ListRemotePeeringConnectionsRequest{
                                DrgId:         drgId,
                                CompartmentId: common.String(s.GetCompartmentId()),
                                Page:          page,
                        })
                        if err != nil </span><span class="cov8" title="1">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">for _, rpc := range response.Items </span><span class="cov0" title="0">{
                                if *rpc.DisplayName == s.OCIClusterAccessor.GetName() </span><span class="cov0" title="0">{
                                        if s.IsResourceCreatedByClusterAPI(rpc.FreeformTags) </span><span class="cov0" title="0">{
                                                rpcs = append(rpcs, rpc)
                                        }</span> else<span class="cov0" title="0"> {
                                                return nil, errors.New("cluster api tags have been modified out of context")
                                        }</span>
                                }
                        }
                        <span class="cov8" title="1">if response.OpcNextPage == nil </span><span class="cov8" title="1">{
                                break</span>
                        } else<span class="cov0" title="0"> {
                                page = response.OpcNextPage
                        }</span>
                }

                <span class="cov8" title="1">if len(rpcs) == 0 </span><span class="cov8" title="1">{
                        return nil, nil
                }</span> else<span class="cov0" title="0"> if len(rpcs) &gt; 1 </span><span class="cov0" title="0">{
                        return nil, errors.New("found more than one attachment with same display name")
                }</span> else<span class="cov0" title="0"> {
                        return &amp;rpcs[0], nil
                }</span>
        }
}

func (s *ClusterScope) updateDRGRpc(ctx context.Context, rpcId *string, vcnClient vcn.Client) (*core.RemotePeeringConnection, error) <span class="cov0" title="0">{
        response, err := vcnClient.UpdateRemotePeeringConnection(ctx, core.UpdateRemotePeeringConnectionRequest{
                RemotePeeringConnectionId: rpcId,
                UpdateRemotePeeringConnectionDetails: core.UpdateRemotePeeringConnectionDetails{
                        FreeformTags: s.GetFreeFormTags(),
                        DefinedTags:  s.GetDefinedTags(),
                },
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;response.RemotePeeringConnection, nil</span>
}

func (s *ClusterScope) getRPC(ctx context.Context, rpcId *string, vcnClient vcn.Client) (*core.RemotePeeringConnection, error) <span class="cov8" title="1">{
        response, err := vcnClient.GetRemotePeeringConnection(ctx, core.GetRemotePeeringConnectionRequest{
                RemotePeeringConnectionId: rpcId,
        })
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return &amp;response.RemotePeeringConnection, nil</span>
}

func (s *ClusterScope) deleteRPC(ctx context.Context, rpcId *string, vcnClient vcn.Client) error <span class="cov8" title="1">{
        _, err := vcnClient.DeleteRemotePeeringConnection(ctx, core.DeleteRemotePeeringConnectionRequest{
                RemotePeeringConnectionId: rpcId,
        })
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">err = s.waitForRPCToBeDeleted(ctx, rpcId, vcnClient)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (s *ClusterScope) waitForRPCToBeProvisioned(ctx context.Context, rpc *core.RemotePeeringConnection, vcnClient vcn.Client) error <span class="cov8" title="1">{
        switch rpc.LifecycleState </span>{
        case core.RemotePeeringConnectionLifecycleStateAvailable:<span class="cov0" title="0">
                return nil</span>
        case core.RemotePeeringConnectionLifecycleStateTerminating, core.RemotePeeringConnectionLifecycleStateTerminated:<span class="cov0" title="0">
                return errors.New("invalid RPC lifecycle state")</span>
        }

        <span class="cov8" title="1">immediate := true
        err := wait.PollUntilContextTimeout(ctx, PollInterval, RequestTimeout, immediate, func(ctx context.Context) (done bool, err error) </span><span class="cov8" title="1">{
                rpc, err := s.getRPC(ctx, rpc.Id, vcnClient)
                if err != nil </span><span class="cov8" title="1">{
                        return true, err
                }</span>
                <span class="cov8" title="1">s.Logger.Info("RPC lifecycle state", "rpcId", rpc.Id, "state", rpc.LifecycleState)
                switch rpc.LifecycleState </span>{
                case core.RemotePeeringConnectionLifecycleStateAvailable:<span class="cov8" title="1">
                        return true, nil</span>
                case core.RemotePeeringConnectionLifecycleStateTerminating, core.RemotePeeringConnectionLifecycleStateTerminated:<span class="cov0" title="0">
                        return true, errors.New("invalid RPC lifecycle state")</span>
                }
                <span class="cov0" title="0">return false, nil</span>
        })
        <span class="cov8" title="1">return err</span>
}

func (s *ClusterScope) waitForRPCToBeDeleted(ctx context.Context, rpcId *string, vcnClient vcn.Client) error <span class="cov8" title="1">{
        immediate := true
        err := wait.PollUntilContextTimeout(ctx, PollInterval, RequestTimeout, immediate, func(ctx context.Context) (done bool, err error) </span><span class="cov8" title="1">{
                rpc, err := s.getRPC(ctx, rpcId, vcnClient)
                if err != nil </span><span class="cov0" title="0">{
                        if ociutil.IsNotFound(err) </span><span class="cov0" title="0">{
                                return true, nil
                        }</span> else<span class="cov0" title="0"> {
                                return true, err
                        }</span>
                }
                <span class="cov8" title="1">if rpc == nil || rpc.LifecycleState == core.RemotePeeringConnectionLifecycleStateTerminated </span><span class="cov8" title="1">{
                        return true, nil
                }</span>
                <span class="cov0" title="0">return false, nil</span>
        })
        <span class="cov8" title="1">return err</span>
}

// DeleteDRGRPCAttachment deletes DRG RPC attachments
func (s *ClusterScope) DeleteDRGRPCAttachment(ctx context.Context) error <span class="cov8" title="1">{
        if !s.isPeeringEnabled() </span><span class="cov8" title="1">{
                s.Logger.Info("VCN Peering is not enabled, ignoring reconciliation")
                return nil
        }</span>

        <span class="cov8" title="1">if s.getDRG() == nil </span><span class="cov0" title="0">{
                s.Logger.Info("DRG has not been specified")
                return nil
        }</span>
        <span class="cov8" title="1">if s.getDrgID() == nil </span><span class="cov0" title="0">{
                s.Logger.Info("DRG ID has not been set")
                return nil
        }</span>

        <span class="cov8" title="1">for _, rpcSpec := range s.OCIClusterAccessor.GetNetworkSpec().VCNPeering.RemotePeeringConnections </span><span class="cov8" title="1">{
                localRpc, err := s.lookupRPC(ctx, s.getDrgID(), rpcSpec.RPCConnectionId, s.VCNClient)
                if err != nil &amp;&amp; !ociutil.IsNotFound(err) </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">if localRpc == nil </span><span class="cov0" title="0">{
                        s.Logger.Info("Local RPC is already deleted")
                        return nil
                }</span> else<span class="cov8" title="1"> {
                        err := s.deleteRPC(ctx, localRpc.Id, s.VCNClient)
                        if err != nil </span><span class="cov8" title="1">{
                                return err
                        }</span>
                        <span class="cov8" title="1">s.Logger.Info("Local RPC has been deleted", "rpcId", localRpc.Id)</span>
                }
                <span class="cov8" title="1">if rpcSpec.ManagePeerRPC </span><span class="cov8" title="1">{
                        clientProvider, err := s.ClientProvider.GetOrBuildClient(rpcSpec.PeerRegionName)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">remoteRpc, err := s.lookupRPC(ctx, rpcSpec.PeerDRGId, rpcSpec.PeerRPCConnectionId, clientProvider.VCNClient)
                        if err != nil &amp;&amp; !ociutil.IsNotFound(err) </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">if remoteRpc == nil </span><span class="cov0" title="0">{
                                s.Logger.Info("Remote RPC is already deleted")
                                return nil
                        }</span> else<span class="cov8" title="1"> {
                                err := s.deleteRPC(ctx, remoteRpc.Id, clientProvider.VCNClient)
                                if err != nil </span><span class="cov8" title="1">{
                                        return err
                                }</span>
                                <span class="cov8" title="1">s.Logger.Info("Remote RPC has been deleted", "rpcId", remoteRpc.Id)</span>
                        }
                }
        }
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file42" style="display: none">/*
 Copyright (c) 2021, 2022 Oracle and/or its affiliates.

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

      https://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
*/

package scope

import (
        "context"

        "github.com/oracle/cluster-api-provider-oci/cloud/ociutil"
        "github.com/oracle/oci-go-sdk/v65/common"
        "github.com/oracle/oci-go-sdk/v65/core"
        "github.com/pkg/errors"
)

// ReconcileDRGVCNAttachment tries to attach the DRG to the VCN
func (s *ClusterScope) ReconcileDRGVCNAttachment(ctx context.Context) error <span class="cov8" title="1">{
        if !s.isPeeringEnabled() </span><span class="cov8" title="1">{
                s.Logger.Info("VCN Peering is not enabled, ignoring reconciliation")
                return nil
        }</span>

        <span class="cov8" title="1">if s.getDRG() == nil </span><span class="cov0" title="0">{
                return errors.New("DRG is nil")
        }</span>

        <span class="cov8" title="1">attachment, err := s.GetDRGAttachment(ctx)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">if attachment != nil </span><span class="cov8" title="1">{
                s.getDRG().VcnAttachmentId = attachment.Id
                s.Logger.Info("DRG already attached to VCN")
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">return nil</span>
        }

        <span class="cov8" title="1">response, err := s.VCNClient.CreateDrgAttachment(ctx, core.CreateDrgAttachmentRequest{
                CreateDrgAttachmentDetails: core.CreateDrgAttachmentDetails{
                        DisplayName:  common.String(s.OCIClusterAccessor.GetName()),
                        DrgId:        s.getDrgID(),
                        VcnId:        s.OCIClusterAccessor.GetNetworkSpec().Vcn.ID,
                        FreeformTags: s.GetFreeFormTags(),
                        DefinedTags:  s.GetDefinedTags(),
                },
        })
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">s.getDRG().VcnAttachmentId = response.Id
        s.Logger.Info("DRG has been attached", "attachmentId", response.Id)
        return nil</span>
}

// nolint:nilnil
func (s *ClusterScope) GetDRGAttachment(ctx context.Context) (*core.DrgAttachment, error) <span class="cov8" title="1">{
        if s.getDRG() == nil </span><span class="cov0" title="0">{
                return nil, errors.New("DRG is nil")
        }</span>
        <span class="cov8" title="1">if s.getDRG().VcnAttachmentId != nil </span><span class="cov8" title="1">{
                response, err := s.VCNClient.GetDrgAttachment(ctx, core.GetDrgAttachmentRequest{
                        DrgAttachmentId: s.getDRG().VcnAttachmentId,
                })
                if err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">if s.IsResourceCreatedByClusterAPI(response.FreeformTags) </span><span class="cov8" title="1">{
                        return &amp;response.DrgAttachment, nil
                }</span> else<span class="cov0" title="0"> {
                        return nil, errors.New("cluster api tags have been modified out of context")
                }</span>
        }

        <span class="cov8" title="1">attachments, err := s.VCNClient.ListDrgAttachments(ctx, core.ListDrgAttachmentsRequest{
                AttachmentType: core.ListDrgAttachmentsAttachmentTypeVcn,
                DisplayName:    common.String(s.OCIClusterAccessor.GetName()),
                DrgId:          s.getDrgID(),
                NetworkId:      s.OCIClusterAccessor.GetNetworkSpec().Vcn.ID,
                CompartmentId:  common.String(s.GetCompartmentId()),
        })

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if len(attachments.Items) == 0 </span><span class="cov8" title="1">{
                return nil, nil
        }</span> else<span class="cov0" title="0"> if len(attachments.Items) &gt; 1 </span><span class="cov0" title="0">{
                return nil, errors.New("found more than one DRG VCN attachment to same VCN, please remove any " +
                        "DRG VCN attachments which has been created outside Cluster API for Oracle for the VCN")
        }</span> else<span class="cov0" title="0"> {
                attachment := attachments.Items[0]
                if s.IsResourceCreatedByClusterAPI(attachment.FreeformTags) </span><span class="cov0" title="0">{
                        return &amp;attachment, nil
                }</span> else<span class="cov0" title="0"> {
                        return nil, errors.New("cluster api tags have been modified out of context")
                }</span>
        }
}

func (s *ClusterScope) UpdateDRGAttachment(ctx context.Context) (*core.DrgAttachment, error) <span class="cov0" title="0">{
        response, err := s.VCNClient.UpdateDrgAttachment(ctx, core.UpdateDrgAttachmentRequest{
                DrgAttachmentId: s.getDRG().VcnAttachmentId,
                UpdateDrgAttachmentDetails: core.UpdateDrgAttachmentDetails{
                        FreeformTags: s.GetFreeFormTags(),
                        DefinedTags:  s.GetDefinedTags(),
                },
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;response.DrgAttachment, nil</span>
}

func (s *ClusterScope) DeleteDRGVCNAttachment(ctx context.Context) error <span class="cov8" title="1">{
        if !s.isPeeringEnabled() </span><span class="cov8" title="1">{
                s.Logger.Info("VCN Peering is not enabled, ignoring reconciliation")
                return nil
        }</span>
        <span class="cov8" title="1">attachment, err := s.GetDRGAttachment(ctx)
        if err != nil &amp;&amp; !ociutil.IsNotFound(err) </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">if attachment == nil </span><span class="cov8" title="1">{
                s.Logger.Info("DRG VCN Attachment is already deleted")
                return nil
        }</span>
        <span class="cov8" title="1">_, err = s.VCNClient.DeleteDrgAttachment(ctx, core.DeleteDrgAttachmentRequest{
                DrgAttachmentId: attachment.Id,
        })
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file43" style="display: none">/*
 Copyright (c) 2021, 2022 Oracle and/or its affiliates.

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

      https://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
*/

package scope

import (
        "context"

        "github.com/oracle/cluster-api-provider-oci/cloud/ociutil"
        "github.com/oracle/oci-go-sdk/v65/common"
        "github.com/oracle/oci-go-sdk/v65/core"
        "github.com/pkg/errors"
)

// ReconcileInternetGateway tries to move the Internet Gateway to the desired OCICluster Spec
func (s *ClusterScope) ReconcileInternetGateway(ctx context.Context) error <span class="cov8" title="1">{
        if s.OCIClusterAccessor.GetNetworkSpec().Vcn.InternetGateway.Skip </span><span class="cov8" title="1">{
                s.Logger.Info("Skipping Internet Gateway reconciliation as per spec")
                return nil
        }</span>
        <span class="cov8" title="1">if s.IsAllSubnetsPrivate() </span><span class="cov8" title="1">{
                s.Logger.Info("All subnets are private, we don't need internet gateway")
                return nil
        }</span>
        <span class="cov8" title="1">var err error
        igw, err := s.GetInternetGateway(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if igw != nil </span><span class="cov8" title="1">{
                s.OCIClusterAccessor.GetNetworkSpec().Vcn.InternetGateway.Id = igw.Id
                s.Logger.Info("No Reconciliation Required for Internet Gateway", "internet_gateway", igw.Id)
                return nil
        }</span>
        <span class="cov8" title="1">internetGateway, err := s.CreateInternetGateway(ctx)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">s.OCIClusterAccessor.GetNetworkSpec().Vcn.InternetGateway.Id = internetGateway
        return err</span>
}

// GetInternetGateway retrieves the Cluster's core.InternetGateway using the one of the following methods
//
// 1. the OCICluster's spec InternetGatewayId
//
// 2. Listing the Internet Gateways for the Compartment (by ID) and filtering by tag
// nolint:nilnil
func (s *ClusterScope) GetInternetGateway(ctx context.Context) (*core.InternetGateway, error) <span class="cov8" title="1">{
        gwId := s.OCIClusterAccessor.GetNetworkSpec().Vcn.InternetGateway.Id
        if gwId != nil </span><span class="cov8" title="1">{
                resp, err := s.VCNClient.GetInternetGateway(ctx, core.GetInternetGatewayRequest{
                        IgId: gwId,
                })
                if err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">igw := resp.InternetGateway
                if s.IsResourceCreatedByClusterAPI(igw.FreeformTags) </span><span class="cov8" title="1">{
                        return &amp;igw, nil
                }</span> else<span class="cov0" title="0"> {
                        return nil, errors.New("cluster api tags have been modified out of context")
                }</span>
        }
        <span class="cov8" title="1">igws, err := s.VCNClient.ListInternetGateways(ctx, core.ListInternetGatewaysRequest{
                CompartmentId: common.String(s.GetCompartmentId()),
                VcnId:         s.getVcnId(),
                DisplayName:   common.String(InternetGatewayName),
        })
        if err != nil </span><span class="cov0" title="0">{
                s.Logger.Error(err, "failed to list internet gateways")
                return nil, errors.Wrap(err, "failed to list internet gateways")
        }</span>
        <span class="cov8" title="1">for _, igw := range igws.Items </span><span class="cov8" title="1">{
                if s.IsResourceCreatedByClusterAPI(igw.FreeformTags) </span><span class="cov8" title="1">{
                        return &amp;igw, nil
                }</span>
        }
        <span class="cov8" title="1">return nil, nil</span>
}

// CreateInternetGateway creates the Internet Gateway for the cluster based on the ClusterScope
func (s *ClusterScope) CreateInternetGateway(ctx context.Context) (*string, error) <span class="cov8" title="1">{
        igwDetails := core.CreateInternetGatewayDetails{
                CompartmentId: common.String(s.GetCompartmentId()),
                DisplayName:   common.String(InternetGatewayName),
                IsEnabled:     common.Bool(true),
                VcnId:         s.getVcnId(),
                FreeformTags:  s.GetFreeFormTags(),
                DefinedTags:   s.GetDefinedTags(),
        }
        igwResponse, err := s.VCNClient.CreateInternetGateway(ctx, core.CreateInternetGatewayRequest{
                CreateInternetGatewayDetails: igwDetails,
        })
        if err != nil </span><span class="cov8" title="1">{
                s.Logger.Error(err, "failed create internet gateway")
                return nil, errors.Wrap(err, "failed create internet gateway")
        }</span>
        <span class="cov8" title="1">s.Logger.Info("Successfully created the internet gateway", "igw", *igwResponse.Id)
        return igwResponse.Id, nil</span>
}

// DeleteInternetGateway retrieves and attempts to delete the Internet Gateway if found.
func (s *ClusterScope) DeleteInternetGateway(ctx context.Context) error <span class="cov8" title="1">{
        if s.OCIClusterAccessor.GetNetworkSpec().Vcn.RouteTable.Skip </span><span class="cov0" title="0">{
                s.Logger.Info("Skipping Internet Gateway reconciliation as per spec")
                return nil
        }</span>
        <span class="cov8" title="1">igw, err := s.GetInternetGateway(ctx)
        if err != nil &amp;&amp; !ociutil.IsNotFound(err) </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">if igw == nil </span><span class="cov8" title="1">{
                s.Logger.Info("Internet Gateway is already deleted")
                return nil
        }</span>
        <span class="cov8" title="1">_, err = s.VCNClient.DeleteInternetGateway(ctx, core.DeleteInternetGatewayRequest{
                IgId: igw.Id,
        })
        if err != nil </span><span class="cov8" title="1">{
                s.Logger.Error(err, "failed to delete InternetGateway")
                return errors.Wrap(err, "failed to delete InternetGateway")
        }</span>
        <span class="cov8" title="1">s.Logger.Info("Successfully deleted InternetGateway", "igw", igw.Id)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file44" style="display: none">/*
 Copyright (c) 2022 Oracle and/or its affiliates.

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

      https://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
*/

package scope

import (
        "context"
        "fmt"

        infrastructurev1beta2 "github.com/oracle/cluster-api-provider-oci/api/v1beta2"
        "github.com/oracle/cluster-api-provider-oci/cloud/ociutil"
        "github.com/oracle/cluster-api-provider-oci/cloud/ociutil/ptr"
        "github.com/oracle/oci-go-sdk/v65/common"
        "github.com/oracle/oci-go-sdk/v65/loadbalancer"
        "github.com/pkg/errors"
        clusterv1 "sigs.k8s.io/cluster-api/api/core/v1beta1"
)

// ReconcileApiServerLB tries to move the Load Balancer to the desired OCICluster Spec
func (s *ClusterScope) ReconcileApiServerLB(ctx context.Context) error <span class="cov8" title="1">{
        desiredApiServerLb := s.LBSpec()

        lb, err := s.GetLoadBalancers(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if lb != nil </span><span class="cov8" title="1">{
                if lb.LifecycleState != loadbalancer.LoadBalancerLifecycleStateActive </span><span class="cov8" title="1">{
                        return errors.New(fmt.Sprintf("load balancer is in %s state. Waiting for ACTIVE state.", lb.LifecycleState))
                }</span>
                <span class="cov8" title="1">lbIP, err := s.getLoadbalancerIp(*lb)
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
                <span class="cov8" title="1">networkSpec := s.OCIClusterAccessor.GetNetworkSpec()
                networkSpec.APIServerLB.LoadBalancerId = lb.Id
                s.OCIClusterAccessor.SetControlPlaneEndpoint(clusterv1.APIEndpoint{
                        Host: *lbIP,
                        Port: s.APIServerPort(),
                })
                if s.IsLBEqual(lb, desiredApiServerLb) </span><span class="cov8" title="1">{
                        s.Logger.Info("No Reconciliation Required for ApiServerLB", "lb", lb.Id)
                        return nil
                }</span>
                <span class="cov8" title="1">s.Logger.Info("Reconciliation Required for ApiServerLB", "lb", lb.Id)
                return s.UpdateLB(ctx, desiredApiServerLb)</span>
        }
        <span class="cov8" title="1">lbID, lbIP, err := s.CreateLB(ctx, desiredApiServerLb)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">networkSpec := s.OCIClusterAccessor.GetNetworkSpec()
        networkSpec.APIServerLB.LoadBalancerId = lbID
        s.OCIClusterAccessor.SetControlPlaneEndpoint(clusterv1.APIEndpoint{
                Host: *lbIP,
                Port: s.APIServerPort(),
        })
        return err</span>
}

// DeleteApiServerLB retrieves and attempts to delete the Load Balancer if found.
// It will await the Work Request completion before returning
func (s *ClusterScope) DeleteApiServerLB(ctx context.Context) error <span class="cov8" title="1">{
        lb, err := s.GetLoadBalancers(ctx)
        if err != nil &amp;&amp; !ociutil.IsNotFound(err) </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if lb == nil </span><span class="cov8" title="1">{
                s.Logger.Info("loadbalancer is already deleted")
                return nil
        }</span>
        <span class="cov8" title="1">lbResponse, err := s.LoadBalancerClient.DeleteLoadBalancer(ctx, loadbalancer.DeleteLoadBalancerRequest{
                LoadBalancerId: lb.Id,
        })
        if err != nil </span><span class="cov8" title="1">{
                s.Logger.Error(err, "failed to delete apiserver lb")
                return errors.Wrap(err, "failed to delete apiserver lb")
        }</span>
        <span class="cov8" title="1">_, err = ociutil.AwaitLBWorkRequest(ctx, s.LoadBalancerClient, lbResponse.OpcWorkRequestId)
        if err != nil </span><span class="cov8" title="1">{
                return errors.Wrap(err, "work request to delete lb failed")
        }</span>
        <span class="cov8" title="1">s.Logger.Info("Successfully deleted apiserver lb", "lb", lb.Id)
        return nil</span>
}

// LBSpec builds the LoadBalancer from the ClusterScope and returns it
func (s *ClusterScope) LBSpec() infrastructurev1beta2.LoadBalancer <span class="cov8" title="1">{
        lbSpec := infrastructurev1beta2.LoadBalancer{
                Name: s.GetControlPlaneLoadBalancerName(),
        }
        return lbSpec
}</span>

// GetControlPlaneLoadBalancerName returns the user defined APIServerLB name from the spec or
// assigns the name based on the OCICluster's name
func (s *ClusterScope) GetControlPlaneLbsLoadBalancerName() string <span class="cov0" title="0">{
        if s.OCIClusterAccessor.GetNetworkSpec().APIServerLB.Name != "" </span><span class="cov0" title="0">{
                return s.OCIClusterAccessor.GetNetworkSpec().APIServerLB.Name
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("%s-%s", s.OCIClusterAccessor.GetName(), "apiserver")</span>
}

// UpdateLB updates existing Load Balancer's DisplayName, FreeformTags and DefinedTags
func (s *ClusterScope) UpdateLB(ctx context.Context, lb infrastructurev1beta2.LoadBalancer) error <span class="cov8" title="1">{
        lbId := s.OCIClusterAccessor.GetNetworkSpec().APIServerLB.LoadBalancerId
        updateLBDetails := loadbalancer.UpdateLoadBalancerDetails{
                DisplayName:  common.String(lb.Name),
                FreeformTags: s.GetFreeFormTags(),
                DefinedTags:  s.GetDefinedTags(),
        }
        lbResponse, err := s.LoadBalancerClient.UpdateLoadBalancer(ctx, loadbalancer.UpdateLoadBalancerRequest{
                UpdateLoadBalancerDetails: updateLBDetails,
                LoadBalancerId:            lbId,
        })
        if err != nil </span><span class="cov8" title="1">{
                s.Logger.Error(err, "failed to reconcile the apiserver LB, failed to generate update lb workrequest")
                return errors.Wrap(err, "failed to reconcile the apiserver LB, failed to generate update lb workrequest")
        }</span>
        <span class="cov8" title="1">_, err = ociutil.AwaitLBWorkRequest(ctx, s.LoadBalancerClient, lbResponse.OpcWorkRequestId)
        if err != nil </span><span class="cov8" title="1">{
                s.Logger.Error(err, "failed to reconcile the apiserver LB, failed to update lb")
                return errors.Wrap(err, "failed to reconcile the apiserver LB, failed to update lb")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// CreateLB configures and creates the Load Balancer for the cluster based on the ClusterScope.
// This configures the LB Listeners and Backend Sets in order to create the Load Balancer.
// It will await the Work Request completion before returning
//
// See https://docs.oracle.com/en-us/iaas/Content/LoadBalancer/overview.htm for more details on the Network
// Load Balancer
func (s *ClusterScope) CreateLB(ctx context.Context, lb infrastructurev1beta2.LoadBalancer) (*string, *string, error) <span class="cov8" title="1">{
        listenerDetails := make(map[string]loadbalancer.ListenerDetails)
        listenerDetails[APIServerLBListener] = loadbalancer.ListenerDetails{
                Protocol:              common.String("TCP"),
                Port:                  common.Int(int(s.APIServerPort())),
                DefaultBackendSetName: common.String(APIServerLBBackendSetName),
        }
        backendSetDetails := make(map[string]loadbalancer.BackendSetDetails)
        backendSetDetails[APIServerLBBackendSetName] = loadbalancer.BackendSetDetails{
                Policy: common.String("ROUND_ROBIN"),
                HealthChecker: &amp;loadbalancer.HealthCheckerDetails{
                        Port:     common.Int(int(s.APIServerPort())),
                        Protocol: common.String("TCP"),
                },
                Backends: []loadbalancer.BackendDetails{},
        }
        var controlPlaneEndpointSubnets []string
        for _, subnet := range ptr.ToSubnetSlice(s.OCIClusterAccessor.GetNetworkSpec().Vcn.Subnets) </span><span class="cov8" title="1">{
                if subnet.ID != nil &amp;&amp; subnet.Role == infrastructurev1beta2.ControlPlaneEndpointRole </span><span class="cov8" title="1">{
                        controlPlaneEndpointSubnets = append(controlPlaneEndpointSubnets, ptr.ToString(subnet.ID))
                }</span>
        }
        <span class="cov8" title="1">if len(controlPlaneEndpointSubnets) &lt; 1 </span><span class="cov8" title="1">{
                return nil, nil, errors.New("control plane endpoint subnet not provided")
        }</span>

        <span class="cov8" title="1">lbDetails := loadbalancer.CreateLoadBalancerDetails{
                CompartmentId: common.String(s.GetCompartmentId()),
                DisplayName:   common.String(lb.Name),
                ShapeName:     common.String("flexible"),
                ShapeDetails: &amp;loadbalancer.ShapeDetails{MinimumBandwidthInMbps: common.Int(10),
                        MaximumBandwidthInMbps: common.Int(100)},
                SubnetIds:    controlPlaneEndpointSubnets,
                IsPrivate:    common.Bool(s.isControlPlaneEndpointSubnetPrivate()),
                Listeners:    listenerDetails,
                BackendSets:  backendSetDetails,
                FreeformTags: s.GetFreeFormTags(),
                DefinedTags:  s.GetDefinedTags(),
        }
        nsgs := make([]string, 0)
        for _, nsg := range ptr.ToNSGSlice(s.OCIClusterAccessor.GetNetworkSpec().Vcn.NetworkSecurityGroup.List) </span><span class="cov8" title="1">{
                if nsg.Role == infrastructurev1beta2.ControlPlaneEndpointRole </span><span class="cov8" title="1">{
                        if nsg.ID != nil </span><span class="cov8" title="1">{
                                nsgs = append(nsgs, *nsg.ID)
                        }</span>
                }
        }
        <span class="cov8" title="1">lbDetails.NetworkSecurityGroupIds = nsgs

        s.Logger.Info("Creating load balancer...")
        lbResponse, err := s.LoadBalancerClient.CreateLoadBalancer(ctx, loadbalancer.CreateLoadBalancerRequest{
                CreateLoadBalancerDetails: lbDetails,
                OpcRetryToken:             ociutil.GetOPCRetryToken("%s-%s", "create-lb", s.OCIClusterAccessor.GetOCIResourceIdentifier()),
        })
        if err != nil </span><span class="cov8" title="1">{
                s.Logger.Error(err, "failed to create apiserver lb, failed to create work request")
                return nil, nil, errors.Wrap(err, "failed to create apiserver lb, failed to create work request")
        }</span>

        <span class="cov8" title="1">wr, err := ociutil.AwaitLBWorkRequest(ctx, s.LoadBalancerClient, lbResponse.OpcWorkRequestId)
        if err != nil </span><span class="cov8" title="1">{
                return nil, nil, errors.Wrap(err, "awaiting load balancer")
        }</span>

        <span class="cov8" title="1">lbs, err := s.LoadBalancerClient.GetLoadBalancer(ctx, loadbalancer.GetLoadBalancerRequest{
                LoadBalancerId: wr.LoadBalancerId,
        })
        if err != nil </span><span class="cov0" title="0">{
                s.Logger.Error(err, "failed to get apiserver lb after creation")
                return nil, nil, errors.Wrap(err, "failed to get apiserver lb after creation")
        }</span>

        <span class="cov8" title="1">lbIp, err := s.getLoadbalancerIp(lbs.LoadBalancer)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov8" title="1">s.Logger.Info("Successfully created apiserver lb", "lb", lbs.Id, "ip", lbIp)
        return lbs.Id, lbIp, nil</span>
}

func (s *ClusterScope) getLoadbalancerIp(lb loadbalancer.LoadBalancer) (*string, error) <span class="cov8" title="1">{
        var lbIp *string
        if len(lb.IpAddresses) &lt; 1 </span><span class="cov8" title="1">{
                return nil, errors.New("lb does not have valid ip addresses")
        }</span>
        <span class="cov8" title="1">if ptr.ToBool(lb.IsPrivate) </span><span class="cov0" title="0">{
                lbIp = lb.IpAddresses[0].IpAddress
        }</span> else<span class="cov8" title="1"> {
                for _, ip := range lb.IpAddresses </span><span class="cov8" title="1">{
                        if *ip.IsPublic </span><span class="cov8" title="1">{
                                lbIp = ip.IpAddress
                        }</span>
                }
        }
        <span class="cov8" title="1">if lbIp == nil </span><span class="cov8" title="1">{
                return nil, errors.New("lb does not have valid public ip address")
        }</span>
        <span class="cov8" title="1">return lbIp, nil</span>
}

// IsLBEqual determines if the actual loadbalancer.LoadBalancer is equal to the desired.
// Equality is determined by DisplayName, FreeformTags and DefinedTags matching.
func (s *ClusterScope) IsLBEqual(actual *loadbalancer.LoadBalancer, desired infrastructurev1beta2.LoadBalancer) bool <span class="cov8" title="1">{
        if desired.Name != *actual.DisplayName </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">return true</span>
}

// GetLoadBalancers retrieves the Cluster's loadbalancer.LoadBalancer using the one of the following methods
//
// 1. the OCICluster's spec LoadBalancerId
//
// 2. Listing the LoadBalancers for the Compartment (by ID) and DisplayName then filtering by tag
// nolint:nilnil
func (s *ClusterScope) GetLoadBalancers(ctx context.Context) (*loadbalancer.LoadBalancer, error) <span class="cov8" title="1">{
        lbOcid := s.OCIClusterAccessor.GetNetworkSpec().APIServerLB.LoadBalancerId
        if lbOcid != nil </span><span class="cov8" title="1">{
                resp, err := s.LoadBalancerClient.GetLoadBalancer(ctx, loadbalancer.GetLoadBalancerRequest{
                        LoadBalancerId: lbOcid,
                })
                if err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">nlb := resp.LoadBalancer
                if s.IsResourceCreatedByClusterAPI(nlb.FreeformTags) </span><span class="cov8" title="1">{
                        return &amp;nlb, nil
                }</span> else<span class="cov0" title="0"> {
                        return nil, errors.New("cluster api tags have been modified out of context")
                }</span>
        }
        <span class="cov8" title="1">var page *string
        for </span><span class="cov8" title="1">{
                lbs, err := s.LoadBalancerClient.ListLoadBalancers(ctx, loadbalancer.ListLoadBalancersRequest{
                        CompartmentId: common.String(s.GetCompartmentId()),
                        DisplayName:   common.String(s.GetControlPlaneLoadBalancerName()),
                        Page:          page,
                })
                if err != nil </span><span class="cov0" title="0">{
                        s.Logger.Error(err, "Failed to list lb by name")
                        return nil, errors.Wrap(err, "failed to list lb by name")
                }</span>

                <span class="cov8" title="1">for _, lb := range lbs.Items </span><span class="cov8" title="1">{
                        if s.IsResourceCreatedByClusterAPI(lb.FreeformTags) </span><span class="cov8" title="1">{
                                resp, err := s.LoadBalancerClient.GetLoadBalancer(ctx, loadbalancer.GetLoadBalancerRequest{
                                        LoadBalancerId: lb.Id,
                                })
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, err
                                }</span>
                                <span class="cov8" title="1">return &amp;resp.LoadBalancer, nil</span>
                        }
                }

                <span class="cov8" title="1">if lbs.OpcNextPage == nil </span><span class="cov8" title="1">{
                        break</span>
                } else<span class="cov0" title="0"> {
                        page = lbs.OpcNextPage
                }</span>
        }
        <span class="cov8" title="1">return nil, nil</span>
}
</pre>
		
		<pre class="file" id="file45" style="display: none">/*
 Copyright (c) 2021, 2022 Oracle and/or its affiliates.

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

      https://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
*/

package scope

import (
        "context"
        "crypto/rand"
        "encoding/base64"
        "fmt"
        "math/big"
        "net/url"
        "strconv"

        "github.com/go-logr/logr"
        infrastructurev1beta2 "github.com/oracle/cluster-api-provider-oci/api/v1beta2"
        "github.com/oracle/cluster-api-provider-oci/cloud/ociutil"
        "github.com/oracle/cluster-api-provider-oci/cloud/ociutil/ptr"
        "github.com/oracle/cluster-api-provider-oci/cloud/services/compute"
        lb "github.com/oracle/cluster-api-provider-oci/cloud/services/loadbalancer"
        nlb "github.com/oracle/cluster-api-provider-oci/cloud/services/networkloadbalancer"
        "github.com/oracle/cluster-api-provider-oci/cloud/services/vcn"
        wr "github.com/oracle/cluster-api-provider-oci/cloud/services/workrequests"
        "github.com/oracle/oci-go-sdk/v65/common"
        "github.com/oracle/oci-go-sdk/v65/core"
        "github.com/oracle/oci-go-sdk/v65/loadbalancer"
        "github.com/oracle/oci-go-sdk/v65/networkloadbalancer"
        "github.com/pkg/errors"
        corev1 "k8s.io/api/core/v1"
        "k8s.io/apimachinery/pkg/types"
        "k8s.io/klog/v2/klogr"
        "k8s.io/utils/pointer"
        clusterv1 "sigs.k8s.io/cluster-api/api/core/v1beta1"
        "sigs.k8s.io/cluster-api/util/deprecated/v1beta1/conditions"
        "sigs.k8s.io/cluster-api/util/patch"
        "sigs.k8s.io/controller-runtime/pkg/client"
)

const OCIMachineKind = "OCIMachine"

// MachineScopeParams defines the params need to create a new MachineScope
type MachineScopeParams struct {
        Logger                    *logr.Logger
        Cluster                   *clusterv1.Cluster
        Machine                   *clusterv1.Machine
        Client                    client.Client
        ComputeClient             compute.ComputeClient
        OCIClusterAccessor        OCIClusterAccessor
        OCIMachine                *infrastructurev1beta2.OCIMachine
        VCNClient                 vcn.Client
        NetworkLoadBalancerClient nlb.NetworkLoadBalancerClient
        LoadBalancerClient        lb.LoadBalancerClient
        WorkRequestsClient        wr.Client
}

type MachineScope struct {
        *logr.Logger
        Client                    client.Client
        patchHelper               *patch.Helper
        Cluster                   *clusterv1.Cluster
        Machine                   *clusterv1.Machine
        ComputeClient             compute.ComputeClient
        OCIClusterAccessor        OCIClusterAccessor
        OCIMachine                *infrastructurev1beta2.OCIMachine
        VCNClient                 vcn.Client
        NetworkLoadBalancerClient nlb.NetworkLoadBalancerClient
        LoadBalancerClient        lb.LoadBalancerClient
        WorkRequestsClient        wr.Client
}

// NewMachineScope creates a MachineScope given the MachineScopeParams
func NewMachineScope(params MachineScopeParams) (*MachineScope, error) <span class="cov8" title="1">{
        if params.Machine == nil </span><span class="cov0" title="0">{
                return nil, errors.New("failed to generate new scope from nil Machine")
        }</span>
        <span class="cov8" title="1">if params.OCIClusterAccessor == nil </span><span class="cov0" title="0">{
                return nil, errors.New("failed to generate new scope from nil OCICluster")
        }</span>

        <span class="cov8" title="1">if params.Logger == nil </span><span class="cov8" title="1">{
                log := klogr.New()
                params.Logger = &amp;log
        }</span>
        <span class="cov8" title="1">helper, err := patch.NewHelper(params.OCIMachine, params.Client)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "failed to init patch helper")
        }</span>

        <span class="cov8" title="1">return &amp;MachineScope{
                Logger:                    params.Logger,
                Client:                    params.Client,
                ComputeClient:             params.ComputeClient,
                Cluster:                   params.Cluster,
                OCIClusterAccessor:        params.OCIClusterAccessor,
                patchHelper:               helper,
                Machine:                   params.Machine,
                OCIMachine:                params.OCIMachine,
                VCNClient:                 params.VCNClient,
                NetworkLoadBalancerClient: params.NetworkLoadBalancerClient,
                LoadBalancerClient:        params.LoadBalancerClient,
                WorkRequestsClient:        params.WorkRequestsClient,
        }, nil</span>
}

// GetOrCreateMachine will get machine instance or create if the instances doesn't exist
func (m *MachineScope) GetOrCreateMachine(ctx context.Context) (*core.Instance, error) <span class="cov8" title="1">{
        instance, err := m.GetMachine(ctx)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if instance != nil </span><span class="cov8" title="1">{
                m.Logger.Info("Found an existing instance")
                return instance, nil
        }</span>
        <span class="cov8" title="1">m.Logger.Info("Creating machine with name", "machine-name", m.OCIMachine.GetName())

        cloudInitData, err := m.GetBootstrapData()
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">shapeConfig := core.LaunchInstanceShapeConfigDetails{}
        if (m.OCIMachine.Spec.ShapeConfig != infrastructurev1beta2.ShapeConfig{}) </span><span class="cov8" title="1">{
                ocpuString := m.OCIMachine.Spec.ShapeConfig.Ocpus
                if ocpuString != "" </span><span class="cov8" title="1">{
                        ocpus, err := strconv.ParseFloat(ocpuString, 32)
                        if err != nil </span><span class="cov8" title="1">{
                                return nil, errors.New(fmt.Sprintf("ocpus provided %s is not a valid floating point",
                                        ocpuString))
                        }</span>
                        <span class="cov8" title="1">shapeConfig.Ocpus = common.Float32(float32(ocpus))</span>
                }

                <span class="cov8" title="1">memoryInGBsString := m.OCIMachine.Spec.ShapeConfig.MemoryInGBs
                if memoryInGBsString != "" </span><span class="cov8" title="1">{
                        memoryInGBs, err := strconv.ParseFloat(memoryInGBsString, 32)
                        if err != nil </span><span class="cov8" title="1">{
                                return nil, errors.New(fmt.Sprintf("memoryInGBs provided %s is not a valid floating point",
                                        memoryInGBsString))
                        }</span>
                        <span class="cov8" title="1">shapeConfig.MemoryInGBs = common.Float32(float32(memoryInGBs))</span>
                }
                <span class="cov8" title="1">baselineOcpuOptString := m.OCIMachine.Spec.ShapeConfig.BaselineOcpuUtilization
                if baselineOcpuOptString != "" </span><span class="cov8" title="1">{
                        value, err := ociutil.GetBaseLineOcpuOptimizationEnum(baselineOcpuOptString)
                        if err != nil </span><span class="cov8" title="1">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">shapeConfig.BaselineOcpuUtilization = value</span>
                }
        }
        <span class="cov8" title="1">sourceDetails := core.InstanceSourceViaImageDetails{
                ImageId: common.String(m.OCIMachine.Spec.ImageId),
        }
        if m.OCIMachine.Spec.BootVolumeSizeInGBs != "" </span><span class="cov8" title="1">{
                bootVolumeSizeInGBsString := m.OCIMachine.Spec.BootVolumeSizeInGBs
                if bootVolumeSizeInGBsString != "" </span><span class="cov8" title="1">{
                        bootVolumeSizeInGBs, err := strconv.ParseFloat(bootVolumeSizeInGBsString, 64)
                        if err != nil </span><span class="cov8" title="1">{
                                return nil, errors.New(fmt.Sprintf("bootVolumeSizeInGBs provided %s is not a valid floating point",
                                        bootVolumeSizeInGBsString))
                        }</span>
                        <span class="cov8" title="1">sourceDetails.BootVolumeSizeInGBs = common.Int64(int64(bootVolumeSizeInGBs))</span>
                }
        }
        <span class="cov8" title="1">if m.OCIMachine.Spec.InstanceSourceViaImageDetails != nil </span><span class="cov8" title="1">{
                sourceDetails.KmsKeyId = m.OCIMachine.Spec.InstanceSourceViaImageDetails.KmsKeyId
                sourceDetails.BootVolumeVpusPerGB = m.OCIMachine.Spec.InstanceSourceViaImageDetails.BootVolumeVpusPerGB
        }</span>

        <span class="cov8" title="1">subnetId := m.OCIMachine.Spec.NetworkDetails.SubnetId
        if subnetId == nil </span><span class="cov8" title="1">{
                if m.IsControlPlane() </span><span class="cov0" title="0">{
                        subnetId = m.getGetControlPlaneMachineSubnet()
                }</span> else<span class="cov8" title="1"> {
                        subnetId = m.getWorkerMachineSubnet()
                }</span>
        }

        <span class="cov8" title="1">var nsgIds []string
        machineNsgIds := m.OCIMachine.Spec.NetworkDetails.NSGIds
        nsgId := m.OCIMachine.Spec.NetworkDetails.NSGId
        if machineNsgIds != nil &amp;&amp; len(machineNsgIds) &gt; 0 </span><span class="cov8" title="1">{
                nsgIds = machineNsgIds
        }</span> else<span class="cov8" title="1"> if nsgId != nil </span><span class="cov8" title="1">{
                nsgIds = []string{*nsgId}
        }</span> else<span class="cov8" title="1"> {
                if m.IsControlPlane() </span><span class="cov0" title="0">{
                        nsgIds = m.getGetControlPlaneMachineNSGs()
                }</span> else<span class="cov8" title="1"> {
                        nsgIds = m.getWorkerMachineNSGs()
                }</span>
        }

        <span class="cov8" title="1">availabilityDomain, faultDomain, retry, err := m.resolveAvailabilityAndFaultDomain()
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">metadata := m.OCIMachine.Spec.Metadata
        if metadata == nil </span><span class="cov8" title="1">{
                metadata = make(map[string]string)
        }</span>
        <span class="cov8" title="1">metadata["user_data"] = base64.StdEncoding.EncodeToString([]byte(cloudInitData))

        tags := m.getFreeFormTags()

        definedTags := ConvertMachineDefinedTags(m.OCIMachine.Spec.DefinedTags)

        launchDetails := core.LaunchInstanceDetails{DisplayName: common.String(m.OCIMachine.Name),
                SourceDetails: sourceDetails,
                CreateVnicDetails: &amp;core.CreateVnicDetails{
                        SubnetId:               subnetId,
                        AssignIpv6Ip:           common.Bool(m.OCIMachine.Spec.NetworkDetails.AssignIpv6Ip),
                        AssignPublicIp:         common.Bool(m.OCIMachine.Spec.NetworkDetails.AssignPublicIp),
                        FreeformTags:           tags,
                        DefinedTags:            definedTags,
                        HostnameLabel:          m.OCIMachine.Spec.NetworkDetails.HostnameLabel,
                        SkipSourceDestCheck:    m.OCIMachine.Spec.NetworkDetails.SkipSourceDestCheck,
                        AssignPrivateDnsRecord: m.OCIMachine.Spec.NetworkDetails.AssignPrivateDnsRecord,
                        DisplayName:            m.OCIMachine.Spec.NetworkDetails.DisplayName,
                },
                ComputeClusterId:               m.OCIMachine.Spec.ComputeClusterId,
                Metadata:                       metadata,
                Shape:                          common.String(m.OCIMachine.Spec.Shape),
                AvailabilityDomain:             common.String(availabilityDomain),
                CompartmentId:                  common.String(m.getCompartmentId()),
                IsPvEncryptionInTransitEnabled: common.Bool(m.OCIMachine.Spec.IsPvEncryptionInTransitEnabled),
                FreeformTags:                   tags,
                DefinedTags:                    definedTags,
                //                ExtendedMetadata:               m.OCIMachine.Spec.ExtendedMetadata,
                DedicatedVmHostId: m.OCIMachine.Spec.DedicatedVmHostId,
        }
        // Compute API does not behave well if the shape config is empty for fixed shapes
        // hence set it only if it non empty
        if (shapeConfig != core.LaunchInstanceShapeConfigDetails{}) </span><span class="cov8" title="1">{
                launchDetails.ShapeConfig = &amp;shapeConfig
        }</span>
        <span class="cov8" title="1">if faultDomain != "" </span><span class="cov8" title="1">{
                launchDetails.FaultDomain = common.String(faultDomain)
        }</span>
        <span class="cov8" title="1">launchDetails.CreateVnicDetails.NsgIds = nsgIds
        if m.OCIMachine.Spec.CapacityReservationId != nil </span><span class="cov8" title="1">{
                launchDetails.CapacityReservationId = m.OCIMachine.Spec.CapacityReservationId
        }</span>
        <span class="cov8" title="1">launchDetails.AgentConfig = m.getAgentConfig()
        launchDetails.LaunchOptions = m.getLaunchOptions()
        launchDetails.InstanceOptions = m.getInstanceOptions()
        launchDetails.AvailabilityConfig = m.getAvailabilityConfig()
        launchDetails.PreemptibleInstanceConfig = m.getPreemptibleInstanceConfig()
        launchDetails.PlatformConfig = m.getPlatformConfig()
        launchDetails.LaunchVolumeAttachments = m.getLaunchVolumeAttachments()
        // Build the list of fault domains to attempt launch in
        faultDomains := m.buildFaultDomainRetryList(availabilityDomain, faultDomain, retry)
        return m.launchInstanceWithFaultDomainRetry(ctx, launchDetails, faultDomains)</span>
}

// launchInstanceWithFaultDomainRetry iterates through the provided fault domains and
// attempts to launch an instance in each until one succeeds, all fail, or a non-capacity error occurs.
func (m *MachineScope) launchInstanceWithFaultDomainRetry(ctx context.Context, baseDetails core.LaunchInstanceDetails, faultDomains []string) (*core.Instance, error) <span class="cov8" title="1">{
        if m.OCIMachine == nil </span><span class="cov0" title="0">{
                return nil, errors.New("machine scope is missing OCIMachine")
        }</span>

        <span class="cov8" title="1">baseRetryToken := ociutil.GetOPCRetryToken("%s", string(m.OCIMachine.UID))
        var lastErr error
        totalAttempts := len(faultDomains)

        for idx, fd := range faultDomains </span><span class="cov8" title="1">{
                details := baseDetails
                if fd != "" </span><span class="cov8" title="1">{
                        details.FaultDomain = common.String(fd)
                }</span>

                // Derive a fault-domain-specific retry token to avoid
                // requests being rejected as duplicates.
                <span class="cov8" title="1">tokenVal := ociutil.DerefString(baseRetryToken)
                if fd != "" </span><span class="cov8" title="1">{
                        tokenVal = tokenVal + "-" + fd
                }</span>
                <span class="cov8" title="1">retryToken := common.String(tokenVal)

                m.Logger.Info("Attempting instance launch", "faultDomain", fd, "attemptNumber", idx+1, "totalAttempts", totalAttempts)
                resp, err := m.ComputeClient.LaunchInstance(ctx, core.LaunchInstanceRequest{
                        LaunchInstanceDetails: details,
                        OpcRetryToken:         retryToken,
                })

                if err == nil </span><span class="cov8" title="1">{
                        return &amp;resp.Instance, nil
                }</span>

                // Stop immediately on non-capacity errors
                <span class="cov8" title="1">if !ociutil.IsOutOfHostCapacity(err) </span><span class="cov8" title="1">{
                        return nil, err
                }</span>

                // For out-of-capacity errors, only retry if there are more fault domains to try
                <span class="cov8" title="1">if idx == len(faultDomains)-1 </span><span class="cov8" title="1">{
                        lastErr = err
                        break</span>
                }

                <span class="cov8" title="1">lastErr = err
                nextFD := faultDomains[idx+1]
                m.Logger.Info("Fault domain has run out of host capacity, retrying in a different domain", "nextFaultDomain", nextFD)</span>
        }
        <span class="cov8" title="1">return nil, errors.Wrap(lastErr, "failed to launch instance after trying all fault domains")</span>
}

// buildFaultDomainRetryList returns the list of fault domains we should try
// when launching in the given availability domain.
// If retry is false, returns only 1 initialFaultDomain.
// Otherwise, returns all 3 fault domains for the availability domain.
func (m *MachineScope) buildFaultDomainRetryList(availabilityDomain, initialFaultDomain string, retry bool) []string <span class="cov8" title="1">{
        faultDomainList := []string{initialFaultDomain}
        if !retry || availabilityDomain == "" </span><span class="cov8" title="1">{
                return faultDomainList
        }</span>

        // we call faultDomainsForAvailabilityDomain and append to faultDomainList because we want to make
        // initialFaultDomain always followed by the other fault domains in order.
        <span class="cov8" title="1">for _, fd := range m.faultDomainsForAvailabilityDomain(availabilityDomain) </span><span class="cov8" title="1">{
                if fd == initialFaultDomain </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">faultDomainList = append(faultDomainList, fd)</span>
        }

        <span class="cov8" title="1">return faultDomainList</span>
}

// faultDomainsForAvailabilityDomain returns the fault domains for the given availability domain.
func (m *MachineScope) faultDomainsForAvailabilityDomain(availabilityDomain string) []string <span class="cov8" title="1">{
        if adMap := m.OCIClusterAccessor.GetAvailabilityDomains(); adMap != nil </span><span class="cov8" title="1">{
                if adEntry, ok := adMap[availabilityDomain]; ok </span><span class="cov8" title="1">{
                        return append([]string(nil), adEntry.FaultDomains...)
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (m *MachineScope) resolveAvailabilityAndFaultDomain() (string, string, bool, error) <span class="cov8" title="1">{
        failureDomainKey := m.Machine.Spec.FailureDomain
        if failureDomainKey == nil </span><span class="cov0" title="0">{
                randomFailureDomain, err := rand.Int(rand.Reader, big.NewInt(3))
                if err != nil </span><span class="cov0" title="0">{
                        m.Logger.Error(err, "Failed to generate random failure domain")
                        return "", "", false, err
                }</span>
                <span class="cov0" title="0">failureDomainKey = common.String(strconv.Itoa(int(randomFailureDomain.Int64()) + 1))</span>
        }

        <span class="cov8" title="1">failureDomainIndex, err := strconv.Atoi(*failureDomainKey)
        if err != nil </span><span class="cov8" title="1">{
                m.Logger.Error(err, "Failure Domain is not a valid integer")
                return "", "", false, errors.Wrap(err, "invalid failure domain parameter, must be a valid integer")
        }</span>
        <span class="cov8" title="1">if failureDomainIndex &lt; 1 || failureDomainIndex &gt; 3 </span><span class="cov8" title="1">{
                err = errors.New("failure domain should be a value between 1 and 3")
                m.Logger.Error(err, "Failure domain should be a value between 1 and 3")
                return "", "", false, err
        }</span>
        <span class="cov8" title="1">m.Logger.Info("Failure Domain being used", "failure-domain", failureDomainIndex)

        fdEntry, exists := m.OCIClusterAccessor.GetFailureDomains()[*failureDomainKey]
        if !exists </span><span class="cov0" title="0">{
                err := errors.New("failure domain not found in cluster failure domains")
                m.Logger.Error(err, "Failure domain not found", "failure-domain", *failureDomainKey)
                return "", "", false, err
        }</span>
        <span class="cov8" title="1">availabilityDomain := fdEntry.Attributes[AvailabilityDomain]
        faultDomain := fdEntry.Attributes[FaultDomain]

        return availabilityDomain, faultDomain, faultDomain != "", nil</span>
}

func (m *MachineScope) getFreeFormTags() map[string]string <span class="cov8" title="1">{
        tags := ociutil.BuildClusterTags(m.OCIClusterAccessor.GetOCIResourceIdentifier())
        // first use cluster level tags, then override with machine level tags
        if m.OCIClusterAccessor.GetFreeformTags() != nil </span><span class="cov0" title="0">{
                for k, v := range m.OCIClusterAccessor.GetFreeformTags() </span><span class="cov0" title="0">{
                        tags[k] = v
                }</span>
        }
        <span class="cov8" title="1">if m.OCIMachine.Spec.FreeformTags != nil </span><span class="cov0" title="0">{
                for k, v := range m.OCIMachine.Spec.FreeformTags </span><span class="cov0" title="0">{
                        tags[k] = v
                }</span>
        }
        <span class="cov8" title="1">return tags</span>
}

// DeleteMachine terminates the instance using InstanceId from the OCIMachine spec and deletes the boot volume
func (m *MachineScope) DeleteMachine(ctx context.Context, instance *core.Instance) error <span class="cov8" title="1">{
        req := core.TerminateInstanceRequest{InstanceId: instance.Id,
                PreserveBootVolume:                 common.Bool(m.OCIMachine.Spec.PreserveBootVolume),
                PreserveDataVolumesCreatedAtLaunch: common.Bool(m.OCIMachine.Spec.PreserveDataVolumesCreatedAtLaunch),
        }
        _, err := m.ComputeClient.TerminateInstance(ctx, req)
        return err
}</span>

// IsResourceCreatedByClusterAPI determines if the instance was created by the cluster using the
// tags created at instance launch.
func (m *MachineScope) IsResourceCreatedByClusterAPI(resourceFreeFormTags map[string]string) bool <span class="cov8" title="1">{
        tagsAddedByClusterAPI := ociutil.BuildClusterTags(string(m.OCIClusterAccessor.GetOCIResourceIdentifier()))
        for k, v := range tagsAddedByClusterAPI </span><span class="cov8" title="1">{
                if resourceFreeFormTags[k] != v </span><span class="cov0" title="0">{
                        return false
                }</span>
        }
        <span class="cov8" title="1">return true</span>
}

func (m *MachineScope) getMachineFromOCID(ctx context.Context, instanceID *string) (*core.Instance, error) <span class="cov8" title="1">{
        req := core.GetInstanceRequest{InstanceId: instanceID}

        // Send the request using the service client
        resp, err := m.ComputeClient.GetInstance(ctx, req)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return &amp;resp.Instance, nil</span>
}

// GetMachineByDisplayName returns the machine from the compartment if there is a matching DisplayName,
// and it was created by the cluster
// nolint:nilnil
func (m *MachineScope) GetMachineByDisplayName(ctx context.Context, name string) (*core.Instance, error) <span class="cov8" title="1">{
        var page *string
        for </span><span class="cov8" title="1">{
                req := core.ListInstancesRequest{DisplayName: common.String(name),
                        CompartmentId: common.String(m.getCompartmentId()), Page: page}
                resp, err := m.ComputeClient.ListInstances(ctx, req)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">if len(resp.Items) == 0 </span><span class="cov8" title="1">{
                        return nil, nil
                }</span>
                <span class="cov8" title="1">for _, instance := range resp.Items </span><span class="cov8" title="1">{
                        if m.IsResourceCreatedByClusterAPI(instance.FreeformTags) </span><span class="cov8" title="1">{
                                return &amp;instance, nil
                        }</span>
                }

                <span class="cov0" title="0">if resp.OpcNextPage == nil </span><span class="cov0" title="0">{
                        break</span>
                } else<span class="cov0" title="0"> {
                        page = resp.OpcNextPage
                }</span>
        }
        <span class="cov0" title="0">return nil, nil</span>
}

// PatchObject persists the cluster configuration and status.
func (m *MachineScope) PatchObject(ctx context.Context) error <span class="cov0" title="0">{
        conditions.SetSummary(m.OCIMachine)
        return m.patchHelper.Patch(ctx, m.OCIMachine)
}</span>

// Close closes the current scope persisting the cluster configuration and status.
func (m *MachineScope) Close(ctx context.Context) error <span class="cov0" title="0">{
        return m.PatchObject(ctx)
}</span>

// GetBootstrapData returns the bootstrap data from the secret in the Machine's bootstrap.dataSecretName.
func (m *MachineScope) GetBootstrapData() (string, error) <span class="cov8" title="1">{
        if m.Machine.Spec.Bootstrap.DataSecretName == nil </span><span class="cov8" title="1">{
                return "", errors.New("error retrieving bootstrap data: linked Machine's bootstrap.dataSecretName is nil")
        }</span>

        <span class="cov8" title="1">secret := &amp;corev1.Secret{}
        key := types.NamespacedName{Namespace: m.Machine.Namespace, Name: *m.Machine.Spec.Bootstrap.DataSecretName}
        if err := m.Client.Get(context.TODO(), key, secret); err != nil </span><span class="cov0" title="0">{
                return "", errors.Wrapf(err, "failed to retrieve bootstrap data secret for OCIMachine %s/%s", m.Machine.Namespace, m.Machine.Name)
        }</span>

        <span class="cov8" title="1">value, ok := secret.Data["value"]
        if !ok </span><span class="cov0" title="0">{
                return "", errors.New("error retrieving bootstrap data: secret value key is missing")
        }</span>
        <span class="cov8" title="1">return string(value), nil</span>
}

// Name returns the OCIMachine name.
func (m *MachineScope) Name() string <span class="cov8" title="1">{
        return m.OCIMachine.Name
}</span>

// GetInstanceId returns the OCIMachine instance id.
func (m *MachineScope) GetInstanceId() *string <span class="cov8" title="1">{
        return m.OCIMachine.Spec.InstanceId
}</span>

// SetReady sets the OCIMachine Ready Status.
func (m *MachineScope) SetReady() <span class="cov0" title="0">{
        m.OCIMachine.Status.Ready = true
}</span>

// SetNotReady sets the OCIMachine Ready Status to false.
func (m *MachineScope) SetNotReady() <span class="cov0" title="0">{
        m.OCIMachine.Status.Ready = false
}</span>

// IsReady returns the ready status of the machine.
func (m *MachineScope) IsReady() bool <span class="cov0" title="0">{
        return m.OCIMachine.Status.Ready
}</span>

// SetFailureMessage sets the OCIMachine status error message.
func (m *MachineScope) SetFailureMessage(v error) <span class="cov0" title="0">{
        m.OCIMachine.Status.FailureMessage = pointer.StringPtr(v.Error())
}</span>

// SetFailureReason sets the OCIMachine status error reason.
func (m *MachineScope) SetFailureReason(v string) <span class="cov0" title="0">{
        m.OCIMachine.Status.FailureReason = &amp;v
}</span>

// GetMachine will attempt to get the machine instance by instance id, or display name if not instance id
func (m *MachineScope) GetMachine(ctx context.Context) (*core.Instance, error) <span class="cov8" title="1">{
        if m.GetInstanceId() != nil </span><span class="cov8" title="1">{
                return m.getMachineFromOCID(ctx, m.GetInstanceId())
        }</span>
        <span class="cov8" title="1">instance, err := m.GetMachineByDisplayName(ctx, m.OCIMachine.Name)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return instance, err</span>
}

// GetMachineIPFromStatus returns the IP address from the OCIMachine's status if it is the Internal IP
func (m *MachineScope) GetMachineIPFromStatus() (string, error) <span class="cov8" title="1">{
        machine := m.OCIMachine
        if machine.Status.Addresses == nil || len(machine.Status.Addresses) == 0 </span><span class="cov8" title="1">{
                return "", errors.New("could not find machine IP Address in status object")
        }</span>
        <span class="cov8" title="1">for _, ip := range machine.Status.Addresses </span><span class="cov8" title="1">{
                if ip.Type == clusterv1.MachineInternalIP </span><span class="cov8" title="1">{
                        return ip.Address, nil
                }</span>
        }
        <span class="cov0" title="0">return "", errors.New("could not find machine Internal IP Address in status object")</span>
}

// GetInstanceIp returns the OCIMachine's instance IP from its primary VNIC attachment.
//
// See https://docs.oracle.com/en-us/iaas/Content/Network/Tasks/managingVNICs.htm for more on VNICs
func (m *MachineScope) GetInstanceIp(ctx context.Context) (*string, error) <span class="cov0" title="0">{
        var page *string
        for </span><span class="cov0" title="0">{
                resp, err := m.ComputeClient.ListVnicAttachments(ctx, core.ListVnicAttachmentsRequest{
                        InstanceId:    m.GetInstanceId(),
                        CompartmentId: common.String(m.getCompartmentId()),
                        Page:          page,
                })
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">for _, attachment := range resp.Items </span><span class="cov0" title="0">{
                        if attachment.LifecycleState != core.VnicAttachmentLifecycleStateAttached </span><span class="cov0" title="0">{
                                m.Logger.Info("VNIC attachment is not in attached state", "vnicAttachmentID", *attachment.Id)
                                continue</span>
                        }

                        <span class="cov0" title="0">if attachment.VnicId == nil </span><span class="cov0" title="0">{
                                // Should never happen but lets be extra cautious as field is non-mandatory in OCI API.
                                m.Logger.Error(errors.New("VNIC attachment is attached but has no VNIC ID"), "vnicAttachmentID", *attachment.Id)
                                continue</span>
                        }
                        <span class="cov0" title="0">vnic, err := m.VCNClient.GetVnic(ctx, core.GetVnicRequest{
                                VnicId: attachment.VnicId,
                        })

                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">if vnic.IsPrimary != nil &amp;&amp; *vnic.IsPrimary </span><span class="cov0" title="0">{
                                return vnic.PrivateIp, nil
                        }</span>
                }

                <span class="cov0" title="0">if resp.OpcNextPage == nil </span><span class="cov0" title="0">{
                        break</span>
                } else<span class="cov0" title="0"> {
                        page = resp.OpcNextPage
                }</span>
        }

        <span class="cov0" title="0">return nil, errors.New("primary VNIC not found")</span>
}

// ReconcileCreateInstanceOnLB sets up backend sets for the load balancer
func (m *MachineScope) ReconcileCreateInstanceOnLB(ctx context.Context) error <span class="cov8" title="1">{
        instanceIp, err := m.GetMachineIPFromStatus()
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">loadbalancerId := m.OCIClusterAccessor.GetNetworkSpec().APIServerLB.LoadBalancerId
        m.Logger.Info("Private IP of the instance", "private-ip", instanceIp)
        m.Logger.Info("Control Plane load balancer", "id", loadbalancerId)

        // Check the load balancer type
        loadbalancerType := m.OCIClusterAccessor.GetNetworkSpec().APIServerLB.LoadBalancerType
        // By default, the load balancer type is Network Load Balancer
        // Unless user specifies the load balancer type to be LBaaS
        if loadbalancerType == infrastructurev1beta2.LoadBalancerTypeLB </span><span class="cov8" title="1">{
                lb, err := m.LoadBalancerClient.GetLoadBalancer(ctx, loadbalancer.GetLoadBalancerRequest{
                        LoadBalancerId: loadbalancerId,
                })
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
                <span class="cov8" title="1">backendSet := lb.BackendSets[APIServerLBBackendSetName]
                // When creating a LB, there is no way to set the backend Name, default backend name is the instance IP and port
                // So we use default backend name instead of machine name
                backendName := instanceIp + ":" + strconv.Itoa(int(m.OCIClusterAccessor.GetControlPlaneEndpoint().Port))
                if !m.containsLBBackend(backendSet, backendName) </span><span class="cov8" title="1">{
                        logger := m.Logger.WithValues("backend-set", *backendSet.Name)
                        logger.Info("Checking work request status for create backend")
                        // we always try to create the backend if it exists during a reconcile loop and wait for the work request
                        // to complete. If there is a work request in progress, in the rare case, CAPOCI pod restarts during the
                        // work request, the create backend call may throw an error which is ok, as reconcile will go into
                        // an exponential backoff
                        resp, err := m.LoadBalancerClient.CreateBackend(ctx, loadbalancer.CreateBackendRequest{
                                LoadBalancerId: loadbalancerId,
                                BackendSetName: backendSet.Name,
                                CreateBackendDetails: loadbalancer.CreateBackendDetails{
                                        IpAddress: common.String(instanceIp),
                                        Port:      common.Int(int(m.OCIClusterAccessor.GetControlPlaneEndpoint().Port)),
                                },
                                OpcRetryToken: ociutil.GetOPCRetryToken("%s-%s", "create-backend", string(m.OCIMachine.UID)),
                        })
                        if err != nil </span><span class="cov8" title="1">{
                                return err
                        }</span>
                        <span class="cov8" title="1">m.OCIMachine.Status.CreateBackendWorkRequestId = *resp.OpcWorkRequestId
                        logger.Info("Add instance to LB backend-set", "WorkRequestId", resp.OpcWorkRequestId)
                        logger.Info("Waiting for LB work request to be complete")
                        _, err = ociutil.AwaitLBWorkRequest(ctx, m.LoadBalancerClient, resp.OpcWorkRequestId)
                        if err != nil </span><span class="cov8" title="1">{
                                return err
                        }</span>
                }

        } else<span class="cov8" title="1"> {
                lb, err := m.NetworkLoadBalancerClient.GetNetworkLoadBalancer(ctx, networkloadbalancer.GetNetworkLoadBalancerRequest{
                        NetworkLoadBalancerId: loadbalancerId,
                })
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
                <span class="cov8" title="1">backendSet := lb.BackendSets[APIServerLBBackendSetName]
                if !m.containsNLBBackend(backendSet, m.Name()) </span><span class="cov8" title="1">{
                        logger := m.Logger.WithValues("backend-set", *backendSet.Name)
                        logger.Info("Checking work request status for create backend")
                        // we always try to create the backend if it exists during a reconcile loop and wait for the work request
                        // to complete. If there is a work request in progress, in the rare case, CAPOCI pod restarts during the
                        // work request, the create backend call may throw an error which is ok, as reconcile will go into
                        // an exponential backoff
                        resp, err := m.NetworkLoadBalancerClient.CreateBackend(ctx, networkloadbalancer.CreateBackendRequest{
                                NetworkLoadBalancerId: loadbalancerId,
                                BackendSetName:        backendSet.Name,
                                CreateBackendDetails: networkloadbalancer.CreateBackendDetails{
                                        IpAddress: common.String(instanceIp),
                                        Port:      common.Int(int(m.OCIClusterAccessor.GetControlPlaneEndpoint().Port)),
                                        Name:      common.String(m.Name()),
                                },
                                OpcRetryToken: ociutil.GetOPCRetryToken("%s-%s", "create-backend", string(m.OCIMachine.UID)),
                        })
                        if err != nil </span><span class="cov8" title="1">{
                                return err
                        }</span>
                        <span class="cov8" title="1">m.OCIMachine.Status.CreateBackendWorkRequestId = *resp.OpcWorkRequestId
                        logger.Info("Add instance to NLB backend-set", "WorkRequestId", resp.OpcWorkRequestId)
                        logger.Info("Waiting for NLB work request to be complete")
                        _, err = ociutil.AwaitNLBWorkRequest(ctx, m.NetworkLoadBalancerClient, resp.OpcWorkRequestId)
                        if err != nil </span><span class="cov8" title="1">{
                                return err
                        }</span>
                        <span class="cov8" title="1">logger.Info("NLB Backend addition work request is complete")</span>
                }
        }
        <span class="cov8" title="1">return nil</span>
}

// ReconcileDeleteInstanceOnLB checks to make sure the instance is part of a backend set then deletes the backend
// on the NetworkLoadBalancer
//
// # It will await the Work Request completion before returning
//
// See https://docs.oracle.com/en-us/iaas/Content/NetworkLoadBalancer/BackendServers/backend_server_management.htm#BackendServerManagement
// for more info on Backend Server Management
func (m *MachineScope) ReconcileDeleteInstanceOnLB(ctx context.Context) error <span class="cov8" title="1">{
        loadbalancerId := m.OCIClusterAccessor.GetNetworkSpec().APIServerLB.LoadBalancerId
        // Check the load balancer type
        loadbalancerType := m.OCIClusterAccessor.GetNetworkSpec().APIServerLB.LoadBalancerType
        if loadbalancerType == infrastructurev1beta2.LoadBalancerTypeLB </span><span class="cov8" title="1">{
                lb, err := m.LoadBalancerClient.GetLoadBalancer(ctx, loadbalancer.GetLoadBalancerRequest{
                        LoadBalancerId: loadbalancerId,
                })
                if err != nil </span><span class="cov8" title="1">{
                        if ociutil.IsNotFound(err) </span><span class="cov8" title="1">{
                                m.Logger.Info("LB has been deleted", "lb", *loadbalancerId)
                                return nil
                        }</span>
                        <span class="cov8" title="1">return err</span>
                }
                <span class="cov8" title="1">backendSet := lb.BackendSets[APIServerLBBackendSetName]
                // in case of delete from LB backend, if the instance does not have an IP, we consider
                // the instance to not have been added in first place and hence return nil
                if len(m.OCIMachine.Status.Addresses) &lt;= 0 </span><span class="cov8" title="1">{
                        m.Logger.Info("Instance does not have IP Address, hence ignoring LBaaS reconciliation on delete")
                        return nil
                }</span>
                <span class="cov8" title="1">instanceIp, err := m.GetMachineIPFromStatus()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">backendName := instanceIp + ":" + strconv.Itoa(int(m.OCIClusterAccessor.GetControlPlaneEndpoint().Port))
                if m.containsLBBackend(backendSet, backendName) </span><span class="cov8" title="1">{
                        logger := m.Logger.WithValues("backend-set", *backendSet.Name)
                        // in OCI CLI, the colon in the backend name is replaced by %3A
                        // replace the colon in the backend name by %3A to avoid the error in PCA
                        escapedBackendName := url.QueryEscape(backendName)
                        // we always try to delete the backend if it exists during a reconcile loop and wait for the work request
                        // to complete. If there is a work request in progress, in the rare case, CAPOCI pod restarts during the
                        // work request, the delete backend call may throw an error which is ok, as reconcile will go into
                        // an exponential backoff
                        resp, err := m.LoadBalancerClient.DeleteBackend(ctx, loadbalancer.DeleteBackendRequest{
                                LoadBalancerId: loadbalancerId,
                                BackendSetName: backendSet.Name,
                                BackendName:    common.String(escapedBackendName),
                        })
                        if err != nil </span><span class="cov8" title="1">{
                                logger.Error(err, "Delete instance from LB backend-set failed",
                                        "backendSetName", *backendSet.Name,
                                        "backendName", escapedBackendName,
                                )
                                return err
                        }</span>
                        <span class="cov8" title="1">m.OCIMachine.Status.DeleteBackendWorkRequestId = *resp.OpcWorkRequestId
                        logger.Info("Delete instance from LB backend-set", "WorkRequestId", resp.OpcWorkRequestId)
                        logger.Info("Waiting for LB work request to be complete")
                        _, err = ociutil.AwaitLBWorkRequest(ctx, m.LoadBalancerClient, resp.OpcWorkRequestId)
                        if err != nil </span><span class="cov8" title="1">{
                                return err
                        }</span>
                        <span class="cov8" title="1">logger.Info("LB Backend addition work request is complete")</span>
                }
        } else<span class="cov8" title="1"> {
                lb, err := m.NetworkLoadBalancerClient.GetNetworkLoadBalancer(ctx, networkloadbalancer.GetNetworkLoadBalancerRequest{
                        NetworkLoadBalancerId: loadbalancerId,
                })
                if err != nil </span><span class="cov8" title="1">{
                        if ociutil.IsNotFound(err) </span><span class="cov8" title="1">{
                                m.Logger.Info("NLB has been deleted", "nlb", *loadbalancerId)
                                return nil
                        }</span>
                        <span class="cov8" title="1">return err</span>
                }
                <span class="cov8" title="1">backendSet := lb.BackendSets[APIServerLBBackendSetName]
                if m.containsNLBBackend(backendSet, m.Name()) </span><span class="cov8" title="1">{
                        logger := m.Logger.WithValues("backend-set", *backendSet.Name)
                        // we always try to delete the backend if it exists during a reconcile loop and wait for the work request
                        // to complete. If there is a work request in progress, in the rare case, CAPOCI pod restarts during the
                        // work request, the delete backend call may throw an error which is ok, as reconcile will go into
                        // an exponential backoff
                        resp, err := m.NetworkLoadBalancerClient.DeleteBackend(ctx, networkloadbalancer.DeleteBackendRequest{
                                NetworkLoadBalancerId: loadbalancerId,
                                BackendSetName:        backendSet.Name,
                                BackendName:           common.String(m.Name()),
                        })
                        if err != nil </span><span class="cov8" title="1">{
                                return err
                        }</span>
                        <span class="cov8" title="1">m.OCIMachine.Status.DeleteBackendWorkRequestId = *resp.OpcWorkRequestId
                        logger.Info("Delete instance from LB backend-set", "WorkRequestId", resp.OpcWorkRequestId)
                        logger.Info("Waiting for LB work request to be complete")
                        _, err = ociutil.AwaitNLBWorkRequest(ctx, m.NetworkLoadBalancerClient, resp.OpcWorkRequestId)
                        if err != nil </span><span class="cov8" title="1">{
                                return err
                        }</span>
                }
        }
        <span class="cov8" title="1">return nil</span>
}

func (m *MachineScope) containsNLBBackend(backendSet networkloadbalancer.BackendSet, backendName string) bool <span class="cov8" title="1">{
        for _, backend := range backendSet.Backends </span><span class="cov8" title="1">{
                if *backend.Name == backendName </span><span class="cov8" title="1">{
                        m.Logger.Info("Instance present in the backend")
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

func (m *MachineScope) containsLBBackend(backendSet loadbalancer.BackendSet, backendName string) bool <span class="cov8" title="1">{
        for _, backend := range backendSet.Backends </span><span class="cov8" title="1">{
                if *backend.Name == backendName </span><span class="cov8" title="1">{
                        m.Logger.Info("Instance present in the backend")
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

// IsControlPlane returns true if the machine is a control plane.
func (m *MachineScope) IsControlPlane() bool <span class="cov8" title="1">{
        _, ok := m.Machine.Labels[clusterv1.MachineControlPlaneLabel]
        return ok
}</span>

func (m *MachineScope) getCompartmentId() string <span class="cov8" title="1">{
        if m.OCIMachine.Spec.CompartmentId != "" </span><span class="cov8" title="1">{
                return m.OCIMachine.Spec.CompartmentId
        }</span>
        <span class="cov8" title="1">return m.OCIClusterAccessor.GetCompartmentId()</span>
}

func (m *MachineScope) getGetControlPlaneMachineSubnet() *string <span class="cov0" title="0">{
        for _, subnet := range ptr.ToSubnetSlice(m.OCIClusterAccessor.GetNetworkSpec().Vcn.Subnets) </span><span class="cov0" title="0">{
                if subnet.Role == infrastructurev1beta2.ControlPlaneRole </span><span class="cov0" title="0">{
                        return subnet.ID
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (m *MachineScope) getGetControlPlaneMachineNSGs() []string <span class="cov0" title="0">{
        nsgs := make([]string, 0)
        for _, nsg := range ptr.ToNSGSlice(m.OCIClusterAccessor.GetNetworkSpec().Vcn.NetworkSecurityGroup.List) </span><span class="cov0" title="0">{
                if nsg.Role == infrastructurev1beta2.ControlPlaneRole </span><span class="cov0" title="0">{
                        if nsg.ID != nil </span><span class="cov0" title="0">{
                                nsgs = append(nsgs, *nsg.ID)
                        }</span>
                }
        }
        <span class="cov0" title="0">return nsgs</span>
}

// getMachineSubnet iterates through the OCICluster Vcn subnets
// and returns the subnet ID if the name matches
func (m *MachineScope) getMachineSubnet(name string) (*string, error) <span class="cov0" title="0">{
        for _, subnet := range ptr.ToSubnetSlice(m.OCIClusterAccessor.GetNetworkSpec().Vcn.Subnets) </span><span class="cov0" title="0">{
                if subnet.Name == name </span><span class="cov0" title="0">{
                        return subnet.ID, nil
                }</span>
        }
        <span class="cov0" title="0">return nil, errors.New(fmt.Sprintf("Subnet with name %s not found for cluster %s", name, m.OCIClusterAccessor.GetName()))</span>
}

func (m *MachineScope) getWorkerMachineSubnet() *string <span class="cov8" title="1">{
        for _, subnet := range ptr.ToSubnetSlice(m.OCIClusterAccessor.GetNetworkSpec().Vcn.Subnets) </span><span class="cov8" title="1">{
                if subnet.Role == infrastructurev1beta2.WorkerRole </span><span class="cov8" title="1">{
                        // if a subnet name is defined, use the correct subnet
                        if m.OCIMachine.Spec.SubnetName != "" </span><span class="cov8" title="1">{
                                if m.OCIMachine.Spec.SubnetName == subnet.Name </span><span class="cov8" title="1">{
                                        return subnet.ID
                                }</span>
                        } else<span class="cov8" title="1"> {
                                return subnet.ID
                        }</span>
                }
        }
        <span class="cov8" title="1">return nil</span>
}

func (m *MachineScope) getWorkerMachineNSGs() []string <span class="cov8" title="1">{
        if len(m.OCIMachine.Spec.NetworkDetails.NsgNames) &gt; 0 </span><span class="cov8" title="1">{
                nsgs := make([]string, 0)
                for _, nsgName := range m.OCIMachine.Spec.NetworkDetails.NsgNames </span><span class="cov8" title="1">{
                        for _, nsg := range ptr.ToNSGSlice(m.OCIClusterAccessor.GetNetworkSpec().Vcn.NetworkSecurityGroup.List) </span><span class="cov8" title="1">{
                                if nsg.Name == nsgName </span><span class="cov8" title="1">{
                                        if nsg.ID != nil </span><span class="cov8" title="1">{
                                                nsgs = append(nsgs, *nsg.ID)
                                        }</span>
                                }
                        }
                }
                <span class="cov8" title="1">return nsgs</span>
        } else<span class="cov8" title="1"> {
                nsgs := make([]string, 0)
                for _, nsg := range ptr.ToNSGSlice(m.OCIClusterAccessor.GetNetworkSpec().Vcn.NetworkSecurityGroup.List) </span><span class="cov8" title="1">{
                        if nsg.Role == infrastructurev1beta2.WorkerRole </span><span class="cov8" title="1">{
                                if nsg.ID != nil </span><span class="cov8" title="1">{
                                        nsgs = append(nsgs, *nsg.ID)
                                }</span>
                        }
                }
                <span class="cov8" title="1">return nsgs</span>
        }
}

func (m *MachineScope) getAgentConfig() *core.LaunchInstanceAgentConfigDetails <span class="cov8" title="1">{
        agentConfigSpec := m.OCIMachine.Spec.AgentConfig
        if agentConfigSpec != nil </span><span class="cov8" title="1">{
                agentConfig := &amp;core.LaunchInstanceAgentConfigDetails{
                        IsMonitoringDisabled:  agentConfigSpec.IsMonitoringDisabled,
                        IsManagementDisabled:  agentConfigSpec.IsManagementDisabled,
                        AreAllPluginsDisabled: agentConfigSpec.AreAllPluginsDisabled,
                }
                if len(agentConfigSpec.PluginsConfig) &gt; 0 </span><span class="cov8" title="1">{
                        pluginConfigList := make([]core.InstanceAgentPluginConfigDetails, len(agentConfigSpec.PluginsConfig))
                        for i, pluginConfigSpec := range agentConfigSpec.PluginsConfig </span><span class="cov8" title="1">{
                                pluginConfigRequest := core.InstanceAgentPluginConfigDetails{
                                        Name: pluginConfigSpec.Name,
                                }
                                desiredState, _ := core.GetMappingInstanceAgentPluginConfigDetailsDesiredStateEnum(string(pluginConfigSpec.DesiredState))
                                pluginConfigRequest.DesiredState = desiredState
                                pluginConfigList[i] = pluginConfigRequest
                        }</span>
                        <span class="cov8" title="1">agentConfig.PluginsConfig = pluginConfigList</span>
                }
                <span class="cov8" title="1">return agentConfig</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (m *MachineScope) getLaunchOptions() *core.LaunchOptions <span class="cov8" title="1">{
        launcOptionsSpec := m.OCIMachine.Spec.LaunchOptions
        if launcOptionsSpec != nil </span><span class="cov8" title="1">{
                launchOptions := &amp;core.LaunchOptions{
                        IsConsistentVolumeNamingEnabled: launcOptionsSpec.IsConsistentVolumeNamingEnabled,
                }
                if launcOptionsSpec.BootVolumeType != "" </span><span class="cov8" title="1">{
                        bootVolume, _ := core.GetMappingLaunchOptionsBootVolumeTypeEnum(string(launcOptionsSpec.BootVolumeType))
                        launchOptions.BootVolumeType = bootVolume
                }</span>
                <span class="cov8" title="1">if launcOptionsSpec.Firmware != "" </span><span class="cov8" title="1">{
                        firmware, _ := core.GetMappingLaunchOptionsFirmwareEnum(string(launcOptionsSpec.Firmware))
                        launchOptions.Firmware = firmware
                }</span>
                <span class="cov8" title="1">if launcOptionsSpec.NetworkType != "" </span><span class="cov8" title="1">{
                        networkType, _ := core.GetMappingLaunchOptionsNetworkTypeEnum(string(launcOptionsSpec.NetworkType))
                        launchOptions.NetworkType = networkType
                }</span>
                <span class="cov8" title="1">if launcOptionsSpec.RemoteDataVolumeType != "" </span><span class="cov8" title="1">{
                        remoteVolumeType, _ := core.GetMappingLaunchOptionsRemoteDataVolumeTypeEnum(string(launcOptionsSpec.RemoteDataVolumeType))
                        launchOptions.RemoteDataVolumeType = remoteVolumeType
                }</span>
                <span class="cov8" title="1">return launchOptions</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (m *MachineScope) getInstanceOptions() *core.InstanceOptions <span class="cov8" title="1">{
        instanceOptionsSpec := m.OCIMachine.Spec.InstanceOptions
        if instanceOptionsSpec != nil </span><span class="cov8" title="1">{
                return &amp;core.InstanceOptions{
                        AreLegacyImdsEndpointsDisabled: instanceOptionsSpec.AreLegacyImdsEndpointsDisabled,
                }
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (m *MachineScope) getAvailabilityConfig() *core.LaunchInstanceAvailabilityConfigDetails <span class="cov8" title="1">{
        avalabilityConfigSpec := m.OCIMachine.Spec.AvailabilityConfig
        if avalabilityConfigSpec != nil </span><span class="cov8" title="1">{
                recoveryAction, _ := core.GetMappingLaunchInstanceAvailabilityConfigDetailsRecoveryActionEnum(string(avalabilityConfigSpec.RecoveryAction))
                return &amp;core.LaunchInstanceAvailabilityConfigDetails{
                        IsLiveMigrationPreferred: avalabilityConfigSpec.IsLiveMigrationPreferred,
                        RecoveryAction:           recoveryAction,
                }
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (m *MachineScope) getPreemptibleInstanceConfig() *core.PreemptibleInstanceConfigDetails <span class="cov8" title="1">{
        preEmptibleInstanceConfigSpec := m.OCIMachine.Spec.PreemptibleInstanceConfig
        if preEmptibleInstanceConfigSpec != nil </span><span class="cov8" title="1">{
                preemptibleInstanceConfig := &amp;core.PreemptibleInstanceConfigDetails{}
                if preEmptibleInstanceConfigSpec.TerminatePreemptionAction != nil </span><span class="cov8" title="1">{
                        preemptibleInstanceConfig.PreemptionAction = core.TerminatePreemptionAction{
                                PreserveBootVolume: preEmptibleInstanceConfigSpec.TerminatePreemptionAction.PreserveBootVolume,
                        }
                }</span>
                <span class="cov8" title="1">return preemptibleInstanceConfig</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (m *MachineScope) getPlatformConfig() core.PlatformConfig <span class="cov8" title="1">{
        platformConfig := m.OCIMachine.Spec.PlatformConfig
        if platformConfig != nil </span><span class="cov8" title="1">{
                switch platformConfig.PlatformConfigType </span>{
                case infrastructurev1beta2.PlatformConfigTypeAmdRomeBmGpu:<span class="cov8" title="1">
                        numaNodesPerSocket, _ := core.GetMappingAmdRomeBmGpuPlatformConfigNumaNodesPerSocketEnum(string(platformConfig.AmdRomeBmGpuPlatformConfig.NumaNodesPerSocket))
                        return core.AmdRomeBmGpuPlatformConfig{
                                IsSecureBootEnabled:                      platformConfig.AmdRomeBmGpuPlatformConfig.IsSecureBootEnabled,
                                IsTrustedPlatformModuleEnabled:           platformConfig.AmdRomeBmGpuPlatformConfig.IsTrustedPlatformModuleEnabled,
                                IsMeasuredBootEnabled:                    platformConfig.AmdRomeBmGpuPlatformConfig.IsMeasuredBootEnabled,
                                IsMemoryEncryptionEnabled:                platformConfig.AmdRomeBmGpuPlatformConfig.IsMemoryEncryptionEnabled,
                                IsSymmetricMultiThreadingEnabled:         platformConfig.AmdRomeBmGpuPlatformConfig.IsSymmetricMultiThreadingEnabled,
                                IsAccessControlServiceEnabled:            platformConfig.AmdRomeBmGpuPlatformConfig.IsAccessControlServiceEnabled,
                                AreVirtualInstructionsEnabled:            platformConfig.AmdRomeBmGpuPlatformConfig.AreVirtualInstructionsEnabled,
                                IsInputOutputMemoryManagementUnitEnabled: platformConfig.AmdRomeBmGpuPlatformConfig.IsInputOutputMemoryManagementUnitEnabled,
                                NumaNodesPerSocket:                       numaNodesPerSocket,
                        }</span>
                case infrastructurev1beta2.PlatformConfigTypeAmdRomeBm:<span class="cov8" title="1">
                        numaNodesPerSocket, _ := core.GetMappingAmdRomeBmPlatformConfigNumaNodesPerSocketEnum(string(platformConfig.AmdRomeBmPlatformConfig.NumaNodesPerSocket))
                        return core.AmdRomeBmPlatformConfig{
                                IsSecureBootEnabled:                      platformConfig.AmdRomeBmPlatformConfig.IsSecureBootEnabled,
                                IsTrustedPlatformModuleEnabled:           platformConfig.AmdRomeBmPlatformConfig.IsTrustedPlatformModuleEnabled,
                                IsMeasuredBootEnabled:                    platformConfig.AmdRomeBmPlatformConfig.IsMeasuredBootEnabled,
                                IsMemoryEncryptionEnabled:                platformConfig.AmdRomeBmPlatformConfig.IsMemoryEncryptionEnabled,
                                IsSymmetricMultiThreadingEnabled:         platformConfig.AmdRomeBmPlatformConfig.IsSymmetricMultiThreadingEnabled,
                                IsAccessControlServiceEnabled:            platformConfig.AmdRomeBmPlatformConfig.IsAccessControlServiceEnabled,
                                AreVirtualInstructionsEnabled:            platformConfig.AmdRomeBmPlatformConfig.AreVirtualInstructionsEnabled,
                                IsInputOutputMemoryManagementUnitEnabled: platformConfig.AmdRomeBmPlatformConfig.IsInputOutputMemoryManagementUnitEnabled,
                                PercentageOfCoresEnabled:                 platformConfig.AmdRomeBmPlatformConfig.PercentageOfCoresEnabled,
                                NumaNodesPerSocket:                       numaNodesPerSocket,
                        }</span>
                case infrastructurev1beta2.PlatformConfigTypeIntelIcelakeBm:<span class="cov8" title="1">
                        numaNodesPerSocket, _ := core.GetMappingIntelIcelakeBmPlatformConfigNumaNodesPerSocketEnum(string(platformConfig.IntelIcelakeBmPlatformConfig.NumaNodesPerSocket))
                        return core.IntelIcelakeBmPlatformConfig{
                                IsSecureBootEnabled:                      platformConfig.IntelIcelakeBmPlatformConfig.IsSecureBootEnabled,
                                IsTrustedPlatformModuleEnabled:           platformConfig.IntelIcelakeBmPlatformConfig.IsTrustedPlatformModuleEnabled,
                                IsMeasuredBootEnabled:                    platformConfig.IntelIcelakeBmPlatformConfig.IsMeasuredBootEnabled,
                                IsMemoryEncryptionEnabled:                platformConfig.IntelIcelakeBmPlatformConfig.IsMemoryEncryptionEnabled,
                                IsSymmetricMultiThreadingEnabled:         platformConfig.IntelIcelakeBmPlatformConfig.IsSymmetricMultiThreadingEnabled,
                                PercentageOfCoresEnabled:                 platformConfig.IntelIcelakeBmPlatformConfig.PercentageOfCoresEnabled,
                                IsInputOutputMemoryManagementUnitEnabled: platformConfig.IntelIcelakeBmPlatformConfig.IsInputOutputMemoryManagementUnitEnabled,
                                NumaNodesPerSocket:                       numaNodesPerSocket,
                        }</span>
                case infrastructurev1beta2.PlatformConfigTypeAmdvm:<span class="cov8" title="1">
                        return core.AmdVmPlatformConfig{
                                IsSecureBootEnabled:            platformConfig.AmdVmPlatformConfig.IsSecureBootEnabled,
                                IsTrustedPlatformModuleEnabled: platformConfig.AmdVmPlatformConfig.IsTrustedPlatformModuleEnabled,
                                IsMeasuredBootEnabled:          platformConfig.AmdVmPlatformConfig.IsMeasuredBootEnabled,
                                IsMemoryEncryptionEnabled:      platformConfig.AmdVmPlatformConfig.IsMemoryEncryptionEnabled,
                        }</span>
                case infrastructurev1beta2.PlatformConfigTypeIntelVm:<span class="cov8" title="1">
                        return core.IntelVmPlatformConfig{
                                IsSecureBootEnabled:            platformConfig.IntelVmPlatformConfig.IsSecureBootEnabled,
                                IsTrustedPlatformModuleEnabled: platformConfig.IntelVmPlatformConfig.IsTrustedPlatformModuleEnabled,
                                IsMeasuredBootEnabled:          platformConfig.IntelVmPlatformConfig.IsMeasuredBootEnabled,
                                IsMemoryEncryptionEnabled:      platformConfig.IntelVmPlatformConfig.IsMemoryEncryptionEnabled,
                        }</span>
                case infrastructurev1beta2.PlatformConfigTypeIntelSkylakeBm:<span class="cov8" title="1">
                        return core.IntelSkylakeBmPlatformConfig{
                                IsSecureBootEnabled:            platformConfig.IntelSkylakeBmPlatformConfig.IsSecureBootEnabled,
                                IsTrustedPlatformModuleEnabled: platformConfig.IntelSkylakeBmPlatformConfig.IsTrustedPlatformModuleEnabled,
                                IsMeasuredBootEnabled:          platformConfig.IntelSkylakeBmPlatformConfig.IsMeasuredBootEnabled,
                                IsMemoryEncryptionEnabled:      platformConfig.IntelSkylakeBmPlatformConfig.IsMemoryEncryptionEnabled,
                        }</span>
                case infrastructurev1beta2.PlatformConfigTypeAmdMilanBm:<span class="cov8" title="1">
                        numaNodesPerSocket, _ := core.GetMappingAmdMilanBmPlatformConfigNumaNodesPerSocketEnum(string(platformConfig.AmdMilanBmPlatformConfig.NumaNodesPerSocket))
                        return core.AmdMilanBmPlatformConfig{
                                IsSecureBootEnabled:                      platformConfig.AmdMilanBmPlatformConfig.IsSecureBootEnabled,
                                IsTrustedPlatformModuleEnabled:           platformConfig.AmdMilanBmPlatformConfig.IsTrustedPlatformModuleEnabled,
                                IsMeasuredBootEnabled:                    platformConfig.AmdMilanBmPlatformConfig.IsMeasuredBootEnabled,
                                IsMemoryEncryptionEnabled:                platformConfig.AmdMilanBmPlatformConfig.IsMemoryEncryptionEnabled,
                                IsSymmetricMultiThreadingEnabled:         platformConfig.AmdMilanBmPlatformConfig.IsSymmetricMultiThreadingEnabled,
                                IsAccessControlServiceEnabled:            platformConfig.AmdMilanBmPlatformConfig.IsAccessControlServiceEnabled,
                                AreVirtualInstructionsEnabled:            platformConfig.AmdMilanBmPlatformConfig.AreVirtualInstructionsEnabled,
                                IsInputOutputMemoryManagementUnitEnabled: platformConfig.AmdMilanBmPlatformConfig.IsInputOutputMemoryManagementUnitEnabled,
                                PercentageOfCoresEnabled:                 platformConfig.AmdMilanBmPlatformConfig.PercentageOfCoresEnabled,
                                NumaNodesPerSocket:                       numaNodesPerSocket,
                        }</span>
                default:<span class="cov0" title="0"></span>
                }
        }
        <span class="cov8" title="1">return nil</span>
}

func (m *MachineScope) getLaunchVolumeAttachments() []core.LaunchAttachVolumeDetails <span class="cov8" title="1">{
        volumeAttachmentsInSpec := m.OCIMachine.Spec.LaunchVolumeAttachment
        if len(volumeAttachmentsInSpec) &lt; 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">var volumes []core.LaunchAttachVolumeDetails

        for _, attachment := range volumeAttachmentsInSpec </span><span class="cov8" title="1">{
                if attachment.Type == infrastructurev1beta2.IscsiType </span><span class="cov8" title="1">{
                        volumes = append(volumes, getIscsiVolumeAttachment(attachment.IscsiAttachment))
                }</span> else<span class="cov8" title="1"> if attachment.Type == infrastructurev1beta2.ParavirtualizedType </span><span class="cov8" title="1">{
                        volumes = append(volumes, getParavirtualizedVolumeAttachment(attachment.ParavirtualizedAttachment))
                }</span> else<span class="cov0" title="0"> {
                        m.Logger.Info("Unknown attachment type not supported")
                }</span>
        }
        <span class="cov8" title="1">return volumes</span>
}

func getIscsiVolumeAttachment(attachment infrastructurev1beta2.LaunchIscsiVolumeAttachment) core.LaunchAttachVolumeDetails <span class="cov8" title="1">{
        volumeDetails := core.LaunchAttachIScsiVolumeDetails{
                Device:                       attachment.Device,
                DisplayName:                  attachment.DisplayName,
                IsShareable:                  attachment.IsShareable,
                IsReadOnly:                   attachment.IsReadOnly,
                VolumeId:                     attachment.VolumeId,
                UseChap:                      attachment.UseChap,
                IsAgentAutoIscsiLoginEnabled: attachment.IsAgentAutoIscsiLoginEnabled,
                EncryptionInTransitType:      getEncryptionType(attachment.EncryptionInTransitType),
                LaunchCreateVolumeDetails:    getLaunchCreateVolumeDetails(attachment.LaunchCreateVolumeFromAttributes),
        }
        return volumeDetails
}</span>

func getParavirtualizedVolumeAttachment(attachment infrastructurev1beta2.LaunchParavirtualizedVolumeAttachment) core.LaunchAttachVolumeDetails <span class="cov8" title="1">{
        volumeDetails := core.LaunchAttachParavirtualizedVolumeDetails{
                Device:                         attachment.Device,
                DisplayName:                    attachment.DisplayName,
                IsShareable:                    attachment.IsShareable,
                IsReadOnly:                     attachment.IsReadOnly,
                VolumeId:                       attachment.VolumeId,
                IsPvEncryptionInTransitEnabled: attachment.IsPvEncryptionInTransitEnabled,
                LaunchCreateVolumeDetails:      getLaunchCreateVolumeDetails(attachment.LaunchCreateVolumeFromAttributes),
        }
        return volumeDetails
}</span>

func getLaunchCreateVolumeDetails(attributes infrastructurev1beta2.LaunchCreateVolumeFromAttributes) core.LaunchCreateVolumeFromAttributes <span class="cov8" title="1">{
        return core.LaunchCreateVolumeFromAttributes{
                SizeInGBs:     attributes.SizeInGBs,
                DisplayName:   attributes.DisplayName,
                CompartmentId: attributes.CompartmentId,
                KmsKeyId:      attributes.KmsKeyId,
                VpusPerGB:     attributes.VpusPerGB,
        }
}</span>

func getEncryptionType(transitType infrastructurev1beta2.EncryptionInTransitTypeEnum) core.EncryptionInTransitTypeEnum <span class="cov8" title="1">{
        if transitType == "" </span><span class="cov8" title="1">{
                return ""
        }</span>
        <span class="cov0" title="0">switch transitType </span>{
        case infrastructurev1beta2.EncryptionInTransitTypeNone:<span class="cov0" title="0">
                return core.EncryptionInTransitTypeNone</span>
        case infrastructurev1beta2.EncryptionInTransitTypeBmEncryptionInTransit:<span class="cov0" title="0">
                return core.EncryptionInTransitTypeBmEncryptionInTransit</span>
        }
        <span class="cov0" title="0">return ""</span>
}
</pre>
		
		<pre class="file" id="file46" style="display: none">/*
 Copyright (c) 2022 Oracle and/or its affiliates.

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

      https://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
*/

package scope

import (
        "context"
        "encoding/base64"
        "fmt"
        "reflect"
        "strconv"
        "strings"

        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"

        "github.com/go-logr/logr"
        infrastructurev1beta2 "github.com/oracle/cluster-api-provider-oci/api/v1beta2"
        "github.com/oracle/cluster-api-provider-oci/cloud/ociutil"
        "github.com/oracle/cluster-api-provider-oci/cloud/ociutil/ptr"
        "github.com/oracle/cluster-api-provider-oci/cloud/services/computemanagement"
        expinfra1 "github.com/oracle/cluster-api-provider-oci/exp/api/v1beta2"
        infrav2exp "github.com/oracle/cluster-api-provider-oci/exp/api/v1beta2"
        "github.com/oracle/oci-go-sdk/v65/common"
        "github.com/oracle/oci-go-sdk/v65/core"
        "github.com/pkg/errors"
        corev1 "k8s.io/api/core/v1"
        "k8s.io/apimachinery/pkg/types"
        "k8s.io/klog/v2/klogr"
        "k8s.io/utils/pointer"
        clusterv1 "sigs.k8s.io/cluster-api/api/core/v1beta1"
        expclusterv1 "sigs.k8s.io/cluster-api/api/core/v1beta1"
        "sigs.k8s.io/cluster-api/util/deprecated/v1beta1/conditions"
        "sigs.k8s.io/cluster-api/util/patch"
        "sigs.k8s.io/controller-runtime/pkg/client"
)

const OCIMachinePoolKind = "OCIMachinePool"

// MachinePoolScopeParams defines the params need to create a new MachineScope
type MachinePoolScopeParams struct {
        Logger                  *logr.Logger
        Cluster                 *clusterv1.Cluster
        MachinePool             *expclusterv1.MachinePool
        Client                  client.Client
        ComputeManagementClient computemanagement.Client
        OCIClusterAccessor      OCIClusterAccessor
        OCIMachinePool          *expinfra1.OCIMachinePool
}

type MachinePoolScope struct {
        *logr.Logger
        Client                  client.Client
        patchHelper             *patch.Helper
        Cluster                 *clusterv1.Cluster
        MachinePool             *expclusterv1.MachinePool
        ComputeManagementClient computemanagement.Client
        OCIClusterAccesor       OCIClusterAccessor
        OCIMachinePool          *expinfra1.OCIMachinePool
}

// NewMachinePoolScope creates a MachinePoolScope given the MachinePoolScopeParams
func NewMachinePoolScope(params MachinePoolScopeParams) (*MachinePoolScope, error) <span class="cov8" title="1">{
        if params.MachinePool == nil </span><span class="cov0" title="0">{
                return nil, errors.New("failed to generate new scope from nil MachinePool")
        }</span>
        <span class="cov8" title="1">if params.OCIClusterAccessor == nil </span><span class="cov0" title="0">{
                return nil, errors.New("failed to generate new scope from nil OCICluster")
        }</span>

        <span class="cov8" title="1">if params.Logger == nil </span><span class="cov8" title="1">{
                log := klogr.New()
                params.Logger = &amp;log
        }</span>
        <span class="cov8" title="1">helper, err := patch.NewHelper(params.OCIMachinePool, params.Client)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "failed to init patch helper")
        }</span>
        <span class="cov8" title="1">params.OCIMachinePool.Status.InfrastructureMachineKind = "OCIMachinePoolMachine"
        return &amp;MachinePoolScope{
                Logger:                  params.Logger,
                Client:                  params.Client,
                ComputeManagementClient: params.ComputeManagementClient,
                Cluster:                 params.Cluster,
                OCIClusterAccesor:       params.OCIClusterAccessor,
                patchHelper:             helper,
                MachinePool:             params.MachinePool,
                OCIMachinePool:          params.OCIMachinePool,
        }, nil</span>
}

// PatchObject persists the cluster configuration and status.
func (m *MachinePoolScope) PatchObject(ctx context.Context) error <span class="cov8" title="1">{
        return m.patchHelper.Patch(ctx, m.OCIMachinePool)
}</span>

// Close closes the current scope persisting the cluster configuration and status.
func (m *MachinePoolScope) Close(ctx context.Context) error <span class="cov0" title="0">{
        return m.PatchObject(ctx)
}</span>

// HasFailed returns true when the OCIMachinePool's Failure reason or Failure message is populated.
func (m *MachinePoolScope) HasFailed() bool <span class="cov0" title="0">{
        return m.OCIMachinePool.Status.FailureReason != nil || m.OCIMachinePool.Status.FailureMessage != nil
}</span>

// GetInstanceConfigurationId returns the MachinePoolScope instance configuration id.
func (m *MachinePoolScope) GetInstanceConfigurationId() *string <span class="cov8" title="1">{
        return m.OCIMachinePool.Spec.InstanceConfiguration.InstanceConfigurationId
}</span>

// SetInstanceConfigurationIdStatus sets the MachinePool InstanceConfigurationId status.
func (m *MachinePoolScope) SetInstanceConfigurationIdStatus(id string) <span class="cov8" title="1">{
        m.OCIMachinePool.Spec.InstanceConfiguration.InstanceConfigurationId = &amp;id
}</span>

// SetFailureMessage sets the OCIMachine status error message.
func (m *MachinePoolScope) SetFailureMessage(v error) <span class="cov0" title="0">{
        m.OCIMachinePool.Status.FailureMessage = pointer.StringPtr(v.Error())
}</span>

// SetFailureReason sets the OCIMachine status error reason.
func (m *MachinePoolScope) SetFailureReason(v string) <span class="cov0" title="0">{
        m.OCIMachinePool.Status.FailureReason = &amp;v
}</span>

// SetReady sets the OCIMachine Ready Status.
func (m *MachinePoolScope) SetReady() <span class="cov0" title="0">{
        m.OCIMachinePool.Status.Ready = true
}</span>

func (m *MachinePoolScope) SetReplicaCount(count int32) <span class="cov0" title="0">{
        m.OCIMachinePool.Status.Replicas = count
}</span>

// GetWorkerMachineSubnet returns the WorkerRole core.Subnet id for the cluster
func (m *MachinePoolScope) GetWorkerMachineSubnet() *string <span class="cov8" title="1">{
        for _, subnet := range ptr.ToSubnetSlice(m.OCIClusterAccesor.GetNetworkSpec().Vcn.Subnets) </span><span class="cov8" title="1">{
                if subnet.Role == infrastructurev1beta2.WorkerRole </span><span class="cov8" title="1">{
                        return subnet.ID
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// ListMachinePoolInstances returns the list of instances belonging to an instance pool
func (m *MachinePoolScope) ListMachinePoolInstances(ctx context.Context) ([]core.InstanceSummary, error) <span class="cov0" title="0">{
        poolOcid := m.OCIMachinePool.Spec.OCID
        if poolOcid == nil </span><span class="cov0" title="0">{
                return nil, errors.New("OCIMachinePool OCID can't be empty")
        }</span>

        <span class="cov0" title="0">req := core.ListInstancePoolInstancesRequest{
                CompartmentId:  common.String(m.OCIClusterAccesor.GetCompartmentId()),
                InstancePoolId: poolOcid,
        }

        var instanceSummaries []core.InstanceSummary
        listPoolInstances := func(ctx context.Context, request core.ListInstancePoolInstancesRequest) (core.ListInstancePoolInstancesResponse, error) </span><span class="cov0" title="0">{
                return m.ComputeManagementClient.ListInstancePoolInstances(ctx, request)
        }</span>
        <span class="cov0" title="0">for resp, err := listPoolInstances(ctx, req); ; resp, err = listPoolInstances(ctx, req) </span><span class="cov0" title="0">{
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">instanceSummaries = append(instanceSummaries, resp.Items...)

                if resp.OpcNextPage == nil </span><span class="cov0" title="0">{
                        break</span>
                } else<span class="cov0" title="0"> {
                        req.Page = resp.OpcNextPage
                }</span>
        }

        <span class="cov0" title="0">return instanceSummaries, nil</span>
}

// SetListandSetMachinePoolInstances retrieves a machine pools instances and sets them in the ProviderIDList
func (m *MachinePoolScope) SetListandSetMachinePoolInstances(ctx context.Context) ([]infrav2exp.OCIMachinePoolMachine, error) <span class="cov0" title="0">{
        poolInstanceSummaries, err := m.ListMachinePoolInstances(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">machines := make([]infrav2exp.OCIMachinePoolMachine, 0)

        for _, instance := range poolInstanceSummaries </span><span class="cov0" title="0">{
                // deleted nodes should not be considered
                if strings.EqualFold(*instance.State, "TERMINATED") </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">ready := false
                if strings.EqualFold(*instance.State, "RUNNING") </span><span class="cov0" title="0">{
                        ready = true
                }</span>
                <span class="cov0" title="0">machines = append(machines, infrav2exp.OCIMachinePoolMachine{
                        ObjectMeta: metav1.ObjectMeta{
                                Name: *instance.DisplayName,
                        },
                        Spec: infrav2exp.OCIMachinePoolMachineSpec{
                                OCID:         instance.Id,
                                ProviderID:   common.String(m.OCIClusterAccesor.GetProviderID(*instance.Id)),
                                InstanceName: instance.DisplayName,
                                MachineType:  infrav2exp.SelfManaged,
                        },
                        Status: infrav2exp.OCIMachinePoolMachineStatus{
                                Ready: ready,
                        },
                })</span>
        }
        <span class="cov0" title="0">return machines, nil</span>
}

// GetBootstrapData returns the bootstrap data from the secret in the Machine's bootstrap.dataSecretName.
func (m *MachinePoolScope) GetBootstrapData() (string, error) <span class="cov8" title="1">{
        if m.MachinePool.Spec.Template.Spec.Bootstrap.DataSecretName == nil </span><span class="cov0" title="0">{
                return "", errors.New("error retrieving bootstrap data: linked MachinePool's bootstrap.dataSecretName is nil")
        }</span>

        <span class="cov8" title="1">secret := &amp;corev1.Secret{}
        key := types.NamespacedName{Namespace: m.MachinePool.Namespace, Name: *m.MachinePool.Spec.Template.Spec.Bootstrap.DataSecretName}
        if err := m.Client.Get(context.TODO(), key, secret); err != nil </span><span class="cov0" title="0">{
                return "", errors.Wrapf(err, "failed to retrieve bootstrap data secret for OCIMachinePool %s/%s", m.MachinePool.Namespace, m.MachinePool.Name)
        }</span>

        <span class="cov8" title="1">value, ok := secret.Data["value"]
        if !ok </span><span class="cov0" title="0">{
                return "", errors.New("error retrieving bootstrap data: secret value key is missing")
        }</span>
        <span class="cov8" title="1">return string(value), nil</span>
}

// GetWorkerMachineNSG returns the worker role core.NetworkSecurityGroup id for the cluster
func (m *MachinePoolScope) GetWorkerMachineNSG() *string <span class="cov0" title="0">{
        for _, nsg := range ptr.ToNSGSlice(m.OCIClusterAccesor.GetNetworkSpec().Vcn.NetworkSecurityGroup.List) </span><span class="cov0" title="0">{
                if nsg.Role == infrastructurev1beta2.WorkerRole </span><span class="cov0" title="0">{
                        return nsg.ID
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (m *MachinePoolScope) buildInstanceConfigurationShapeConfig() (core.InstanceConfigurationLaunchInstanceShapeConfigDetails, error) <span class="cov8" title="1">{
        shapeConfig := core.InstanceConfigurationLaunchInstanceShapeConfigDetails{}
        shapeConfigSpec := m.OCIMachinePool.Spec.InstanceConfiguration.ShapeConfig
        if shapeConfigSpec != nil </span><span class="cov8" title="1">{
                if shapeConfigSpec.Ocpus != nil </span><span class="cov8" title="1">{
                        ocpus, err := strconv.ParseFloat(*shapeConfigSpec.Ocpus, 32)
                        if err != nil </span><span class="cov0" title="0">{
                                return core.InstanceConfigurationLaunchInstanceShapeConfigDetails{}, errors.New(fmt.Sprintf("ocpus provided %s is not a valid floating point",
                                        *shapeConfigSpec.Ocpus))
                        }</span>
                        <span class="cov8" title="1">shapeConfig.Ocpus = common.Float32(float32(ocpus))</span>
                }

                <span class="cov8" title="1">if shapeConfigSpec.MemoryInGBs != nil </span><span class="cov8" title="1">{
                        memoryInGBs, err := strconv.ParseFloat(*shapeConfigSpec.MemoryInGBs, 32)
                        if err != nil </span><span class="cov0" title="0">{
                                return core.InstanceConfigurationLaunchInstanceShapeConfigDetails{}, errors.New(fmt.Sprintf("memoryInGBs provided %s is not a valid floating point",
                                        *shapeConfigSpec.MemoryInGBs))
                        }</span>
                        <span class="cov8" title="1">shapeConfig.MemoryInGBs = common.Float32(float32(memoryInGBs))</span>
                }
                <span class="cov8" title="1">baselineOcpuOptString := shapeConfigSpec.BaselineOcpuUtilization
                if baselineOcpuOptString != "" </span><span class="cov8" title="1">{
                        value, err := ociutil.GetInstanceConfigBaseLineOcpuOptimizationEnum(baselineOcpuOptString)
                        if err != nil </span><span class="cov0" title="0">{
                                return core.InstanceConfigurationLaunchInstanceShapeConfigDetails{}, err
                        }</span>
                        <span class="cov8" title="1">shapeConfig.BaselineOcpuUtilization = value</span>
                }
                <span class="cov8" title="1">shapeConfig.Nvmes = shapeConfigSpec.Nvmes</span>
        }

        <span class="cov8" title="1">return shapeConfig, nil</span>
}

func (s *MachinePoolScope) BuildInstancePoolPlacement() ([]core.CreateInstancePoolPlacementConfigurationDetails, error) <span class="cov8" title="1">{
        var placements []core.CreateInstancePoolPlacementConfigurationDetails

        ads := s.OCIClusterAccesor.GetAvailabilityDomains()

        specPlacementDetails := s.OCIMachinePool.Spec.PlacementDetails

        // make sure user doesn't specify 3 ads when there is only one available
        if len(specPlacementDetails) &gt; len(ads) </span><span class="cov0" title="0">{
                errMsg := fmt.Sprintf("Cluster has %d ADs specified and the machine pools spec has %d", len(ads), len(specPlacementDetails))
                return nil, errors.New(errMsg)
        }</span>

        // build placements from the user spec
        <span class="cov8" title="1">for _, ad := range ads </span><span class="cov8" title="1">{
                for _, specPlacment := range specPlacementDetails </span><span class="cov0" title="0">{
                        if strings.HasSuffix(ad.Name, strconv.Itoa(specPlacment.AvailabilityDomain)) </span><span class="cov0" title="0">{
                                placement := core.CreateInstancePoolPlacementConfigurationDetails{
                                        AvailabilityDomain: common.String(ad.Name),
                                        PrimarySubnetId:    s.GetWorkerMachineSubnet(),
                                        FaultDomains:       ad.FaultDomains,
                                }
                                s.Info("Adding machine placement for AD", "AD", ad.Name)
                                placements = append(placements, placement)
                        }</span>
                }
        }

        // build placements if the user hasn't specified any
        <span class="cov8" title="1">if len(placements) &lt;= 0 </span><span class="cov8" title="1">{
                for _, ad := range ads </span><span class="cov8" title="1">{
                        placement := core.CreateInstancePoolPlacementConfigurationDetails{
                                AvailabilityDomain: common.String(ad.Name),
                                PrimarySubnetId:    s.GetWorkerMachineSubnet(),
                                FaultDomains:       ad.FaultDomains,
                        }
                        placements = append(placements, placement)
                }</span>
        }

        <span class="cov8" title="1">return placements, nil</span>
}

// IsResourceCreatedByClusterAPI determines if the instance was created by the cluster using the
// tags created at instance launch.
func (s *MachinePoolScope) IsResourceCreatedByClusterAPI(resourceFreeFormTags map[string]string) bool <span class="cov0" title="0">{
        tagsAddedByClusterAPI := ociutil.BuildClusterTags(string(s.OCIClusterAccesor.GetOCIResourceIdentifier()))
        for k, v := range tagsAddedByClusterAPI </span><span class="cov0" title="0">{
                if resourceFreeFormTags[k] != v </span><span class="cov0" title="0">{
                        return false
                }</span>
        }
        <span class="cov0" title="0">return true</span>
}

// GetFreeFormTags gets the free form tags for the MachinePoolScope cluster and returns them
func (m *MachinePoolScope) GetFreeFormTags() map[string]string <span class="cov8" title="1">{
        tags := ociutil.BuildClusterTags(m.OCIClusterAccesor.GetOCIResourceIdentifier())
        if m.OCIClusterAccesor.GetFreeformTags() != nil </span><span class="cov0" title="0">{
                for k, v := range m.OCIClusterAccesor.GetFreeformTags() </span><span class="cov0" title="0">{
                        tags[k] = v
                }</span>
        }

        <span class="cov8" title="1">return tags</span>
}

// ReconcileInstanceConfiguration works to try to reconcile the state of the instance configuration for the cluster
func (m *MachinePoolScope) ReconcileInstanceConfiguration(ctx context.Context) error <span class="cov8" title="1">{
        var instanceConfiguration *core.InstanceConfiguration
        instanceConfiguration, err := m.GetInstanceConfiguration(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">freeFormTags := m.GetFreeFormTags()
        definedTags := make(map[string]map[string]interface{})
        if m.OCIClusterAccesor.GetDefinedTags() != nil </span><span class="cov8" title="1">{
                for ns, mapNs := range m.OCIClusterAccesor.GetDefinedTags() </span><span class="cov8" title="1">{
                        mapValues := make(map[string]interface{})
                        for k, v := range mapNs </span><span class="cov8" title="1">{
                                mapValues[k] = v
                        }</span>
                        <span class="cov8" title="1">definedTags[ns] = mapValues</span>
                }
        }
        <span class="cov8" title="1">instanceConfigurationSpec := m.OCIMachinePool.Spec.InstanceConfiguration
        if instanceConfiguration == nil </span><span class="cov8" title="1">{
                m.Info("Create new instance configuration")

                launchDetails, err := m.getLaunchInstanceDetails(instanceConfigurationSpec, freeFormTags, definedTags)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">err = m.createInstanceConfiguration(ctx, launchDetails, freeFormTags, definedTags)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">return m.PatchObject(ctx)</span>
        } else<span class="cov8" title="1"> {
                computeDetails, ok := instanceConfiguration.InstanceDetails.(core.ComputeInstanceDetails)
                if ok </span><span class="cov8" title="1">{
                        launchDetailsActual := computeDetails.LaunchDetails
                        launchDetailsSpec, err := m.getLaunchInstanceDetails(instanceConfigurationSpec, freeFormTags, definedTags)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        // do not compare defined tags
                        <span class="cov8" title="1">launchDetailsSpec.DefinedTags = nil
                        launchDetailsActual.DefinedTags = nil

                        if launchDetailsSpec.CreateVnicDetails != nil </span><span class="cov8" title="1">{
                                launchDetailsSpec.CreateVnicDetails.DefinedTags = nil
                        }</span>
                        <span class="cov8" title="1">if launchDetailsActual.CreateVnicDetails != nil </span><span class="cov8" title="1">{
                                launchDetailsActual.CreateVnicDetails.DefinedTags = nil
                        }</span>
                        <span class="cov8" title="1">launchDetailsActual.DisplayName = nil
                        launchDetailsSpec.DisplayName = nil
                        if !reflect.DeepEqual(launchDetailsSpec, launchDetailsActual) </span><span class="cov8" title="1">{
                                m.Logger.Info("Machine pool", "spec", launchDetailsSpec)
                                m.Logger.Info("Machine pool", "actual", launchDetailsActual)
                                // created the launch details pec again as we may have removed certain fields for comparison purposes
                                launchDetailsSpec, err := m.getLaunchInstanceDetails(instanceConfigurationSpec, freeFormTags, definedTags)
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                                <span class="cov8" title="1">err = m.createInstanceConfiguration(ctx, launchDetailsSpec, freeFormTags, definedTags)
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                                <span class="cov8" title="1">return m.PatchObject(ctx)</span>
                        }
                } else<span class="cov0" title="0"> {
                        m.Logger.Info("Could not read the instance details as ComputeInstanceDetails, please create a github " +
                                "ticket in CAPOCI repository")
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (m *MachinePoolScope) createInstanceConfiguration(ctx context.Context, launchDetails *core.InstanceConfigurationLaunchInstanceDetails, freeFormTags map[string]string, definedTags map[string]map[string]interface{}) error <span class="cov8" title="1">{
        launchInstanceDetails := core.ComputeInstanceDetails{
                LaunchDetails: launchDetails,
        }
        req := core.CreateInstanceConfigurationRequest{
                CreateInstanceConfiguration: core.CreateInstanceConfigurationDetails{
                        CompartmentId:   common.String(m.OCIClusterAccesor.GetCompartmentId()),
                        DisplayName:     common.String(fmt.Sprintf("%s-%s", m.OCIMachinePool.GetName(), m.OCIMachinePool.ResourceVersion)),
                        FreeformTags:    freeFormTags,
                        DefinedTags:     definedTags,
                        InstanceDetails: launchInstanceDetails,
                },
        }

        resp, err := m.ComputeManagementClient.CreateInstanceConfiguration(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                conditions.MarkFalse(m.MachinePool, infrav2exp.LaunchTemplateReadyCondition, infrav2exp.LaunchTemplateCreateFailedReason, clusterv1.ConditionSeverityError, "%s", err.Error())
                m.Info("failed to create instance configuration")
                return err
        }</span>

        <span class="cov8" title="1">m.SetInstanceConfigurationIdStatus(*resp.Id)
        return nil</span>
}

func (m *MachinePoolScope) getLaunchInstanceDetails(instanceConfigurationSpec infrav2exp.InstanceConfiguration, freeFormTags map[string]string, definedTags map[string]map[string]interface{}) (*core.InstanceConfigurationLaunchInstanceDetails, error) <span class="cov8" title="1">{
        metadata := instanceConfigurationSpec.Metadata
        if metadata == nil </span><span class="cov8" title="1">{
                metadata = make(map[string]string)
        }</span>
        <span class="cov8" title="1">cloudInitData, err := m.GetBootstrapData()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">metadata["user_data"] = base64.StdEncoding.EncodeToString([]byte(cloudInitData))

        launchDetails := &amp;core.InstanceConfigurationLaunchInstanceDetails{
                CompartmentId:     common.String(m.OCIClusterAccesor.GetCompartmentId()),
                DisplayName:       common.String(m.OCIMachinePool.GetName()),
                Shape:             common.String(*m.OCIMachinePool.Spec.InstanceConfiguration.Shape),
                Metadata:          metadata,
                DedicatedVmHostId: instanceConfigurationSpec.DedicatedVmHostId,
                FreeformTags:      freeFormTags,
                DefinedTags:       definedTags,
        }

        if instanceConfigurationSpec.CapacityReservationId != nil </span><span class="cov0" title="0">{
                launchDetails.CapacityReservationId = instanceConfigurationSpec.CapacityReservationId
        }</span>
        <span class="cov8" title="1">launchDetails.CreateVnicDetails = m.getVnicDetails(instanceConfigurationSpec, freeFormTags, definedTags)
        launchDetails.SourceDetails = m.getInstanceConfigurationInstanceSourceViaImageDetail()
        launchDetails.AgentConfig = m.getAgentConfig()
        launchDetails.LaunchOptions = m.getLaunchOptions()
        launchDetails.InstanceOptions = m.getInstanceOptions()
        launchDetails.AvailabilityConfig = m.getAvailabilityConfig()
        launchDetails.PreemptibleInstanceConfig = m.getPreemptibleInstanceConfig()
        launchDetails.PlatformConfig = m.getPlatformConfig()

        shapeConfig, err := m.buildInstanceConfigurationShapeConfig()
        if err != nil </span><span class="cov0" title="0">{
                conditions.MarkFalse(m.MachinePool, infrav2exp.LaunchTemplateReadyCondition, infrav2exp.LaunchTemplateCreateFailedReason, clusterv1.ConditionSeverityError, "%s", err.Error())
                m.Info("failed to create instance configuration due to shape config")
                return nil, err
        }</span>
        <span class="cov8" title="1">if (shapeConfig != core.InstanceConfigurationLaunchInstanceShapeConfigDetails{}) </span><span class="cov8" title="1">{
                launchDetails.ShapeConfig = &amp;shapeConfig
        }</span>
        <span class="cov8" title="1">return launchDetails, nil</span>
}

// ListInstancePoolSummaries list the core.InstancePoolSummary for the given core.ListInstancePoolsRequest
func (m *MachinePoolScope) ListInstancePoolSummaries(ctx context.Context, req core.ListInstancePoolsRequest) ([]core.InstancePoolSummary, error) <span class="cov0" title="0">{
        listInstancePools := func(ctx context.Context, request core.ListInstancePoolsRequest) (core.ListInstancePoolsResponse, error) </span><span class="cov0" title="0">{
                return m.ComputeManagementClient.ListInstancePools(ctx, request)
        }</span>

        <span class="cov0" title="0">var instancePoolSummaries []core.InstancePoolSummary
        for resp, err := listInstancePools(ctx, req); ; resp, err = listInstancePools(ctx, req) </span><span class="cov0" title="0">{
                if err != nil </span><span class="cov0" title="0">{
                        return instancePoolSummaries, errors.Wrapf(err, "failed to query OCIMachinePool by name")
                }</span>

                <span class="cov0" title="0">instancePoolSummaries = append(instancePoolSummaries, resp.Items...)

                if resp.OpcNextPage == nil </span><span class="cov0" title="0">{
                        // no more pages
                        break</span>
                } else<span class="cov0" title="0"> {
                        req.Page = resp.OpcNextPage
                }</span>
        }

        <span class="cov0" title="0">return instancePoolSummaries, nil</span>
}

// FindInstancePool attempts to find the instance pool by name and checks to make sure
// the instance pool was created by the cluster before returning the correct pool
// nolint:nilnil
func (m *MachinePoolScope) FindInstancePool(ctx context.Context) (*core.InstancePool, error) <span class="cov0" title="0">{
        if m.OCIMachinePool.Spec.OCID != nil </span><span class="cov0" title="0">{
                response, err := m.ComputeManagementClient.GetInstancePool(ctx, core.GetInstancePoolRequest{
                        InstancePoolId: m.OCIMachinePool.Spec.OCID,
                })
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return &amp;response.InstancePool, nil</span>
        }

        // We have to first list the pools to get the instance pool.
        // List returns InstancePoolSummary which lacks some details of InstancePool
        <span class="cov0" title="0">reqList := core.ListInstancePoolsRequest{
                CompartmentId: common.String(m.OCIClusterAccesor.GetCompartmentId()),
                DisplayName:   common.String(m.OCIMachinePool.GetName()),
        }

        instancePoolSummaries, err := m.ListInstancePoolSummaries(ctx, reqList)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var instancePoolSummary *core.InstancePoolSummary
        for i, summary := range instancePoolSummaries </span><span class="cov0" title="0">{
                if m.IsResourceCreatedByClusterAPI(summary.FreeformTags) </span><span class="cov0" title="0">{
                        instancePoolSummary = &amp;instancePoolSummaries[i]
                        break</span>
                }
        }
        <span class="cov0" title="0">if instancePoolSummary == nil </span><span class="cov0" title="0">{
                m.Info("No machine pool found created by this cluster", "machinepool-name", m.OCIMachinePool.GetName())
                return nil, nil
        }</span>

        <span class="cov0" title="0">reqGet := core.GetInstancePoolRequest{
                InstancePoolId: instancePoolSummary.Id,
        }
        respGet, err := m.ComputeManagementClient.GetInstancePool(ctx, reqGet)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrapf(err, "failed to query OCIMachinePool with id %s", *instancePoolSummary.Id)
        }</span>

        <span class="cov0" title="0">if !m.IsResourceCreatedByClusterAPI(respGet.InstancePool.FreeformTags) </span><span class="cov0" title="0">{
                return nil, errors.Wrapf(err, "failed to query OCIMachinePool not created by this cluster.")
        }</span>

        <span class="cov0" title="0">m.Info("Found existing instance pool", "id", instancePoolSummary.Id, "machinepool-name", m.OCIMachinePool.GetName())

        return &amp;respGet.InstancePool, nil</span>
}

// CreateInstancePool attempts to create an instance pool
func (m *MachinePoolScope) CreateInstancePool(ctx context.Context) (*core.InstancePool, error) <span class="cov8" title="1">{
        if m.GetInstanceConfigurationId() == nil </span><span class="cov8" title="1">{
                return nil, errors.New("OCIMachinePool has no InstanceConfigurationId")
        }</span>

        <span class="cov8" title="1">tags := m.GetFreeFormTags()

        // build placements
        placements, err := m.BuildInstancePoolPlacement()
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrapf(err, "unable to build instance pool placements")
        }</span>

        <span class="cov8" title="1">replicas := int(1)
        if m.MachinePool.Spec.Replicas != nil </span><span class="cov8" title="1">{
                replicas = int(*m.MachinePool.Spec.Replicas)
        }</span>

        <span class="cov8" title="1">m.Info("Creating Instance Pool")
        req := core.CreateInstancePoolRequest{
                CreateInstancePoolDetails: core.CreateInstancePoolDetails{
                        CompartmentId:           common.String(m.OCIClusterAccesor.GetCompartmentId()),
                        InstanceConfigurationId: m.GetInstanceConfigurationId(),
                        Size:                    common.Int(replicas),
                        DisplayName:             common.String(m.OCIMachinePool.GetName()),

                        PlacementConfigurations: placements,
                        FreeformTags:            tags,
                },
        }
        instancePool, err := m.ComputeManagementClient.CreateInstancePool(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrapf(err, "failed to create OCIMachinePool")
        }</span>
        <span class="cov8" title="1">m.Info("Created Instance Pool", "id", instancePool.Id)

        return &amp;instancePool.InstancePool, nil</span>
}

// UpdatePool attempts to update the instance pool
func (m *MachinePoolScope) UpdatePool(ctx context.Context, instancePool *core.InstancePool) (*core.InstancePool, error) <span class="cov8" title="1">{
        if instancePoolNeedsUpdates(m, instancePool) </span><span class="cov8" title="1">{
                m.Info("Updating instance pool")
                replicas := 0
                if m.MachinePool.Spec.Replicas != nil </span><span class="cov8" title="1">{
                        replicas = int(*m.MachinePool.Spec.Replicas)
                }</span>
                <span class="cov8" title="1">req := core.UpdateInstancePoolRequest{InstancePoolId: instancePool.Id,
                        UpdateInstancePoolDetails: core.UpdateInstancePoolDetails{
                                Size:                    common.Int(replicas),
                                InstanceConfigurationId: m.OCIMachinePool.Spec.InstanceConfiguration.InstanceConfigurationId,
                        },
                }
                resp, err := m.ComputeManagementClient.UpdateInstancePool(ctx, req)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errors.Wrap(err, "unable to update instance pool")
                }</span>
                <span class="cov8" title="1">m.Info("Successfully updated instance pool")
                return &amp;resp.InstancePool, nil</span>
        }
        <span class="cov8" title="1">return instancePool, nil</span>
}

func (m *MachinePoolScope) TerminateInstancePool(ctx context.Context, instancePool *core.InstancePool) error <span class="cov0" title="0">{
        m.Info("Terminating instance pool", "id", instancePool.Id, "lifecycleState", instancePool.LifecycleState)
        req := core.TerminateInstancePoolRequest{InstancePoolId: instancePool.Id}
        if _, err := m.ComputeManagementClient.TerminateInstancePool(ctx, req); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// instancePoolNeedsUpdates compares incoming OCIMachinePool and compares against existing instance pool.
func instancePoolNeedsUpdates(machinePoolScope *MachinePoolScope, instancePool *core.InstancePool) bool <span class="cov8" title="1">{
        instanePoolSize := 0
        machinePoolReplicas := 0
        if machinePoolScope.MachinePool.Spec.Replicas != nil </span><span class="cov8" title="1">{
                machinePoolReplicas = int(*machinePoolScope.MachinePool.Spec.Replicas)
        }</span>

        <span class="cov8" title="1">if instancePool.Size != nil </span><span class="cov8" title="1">{
                instanePoolSize = *instancePool.Size
        }</span>
        <span class="cov8" title="1">if machinePoolReplicas != instanePoolSize </span><span class="cov0" title="0">{
                return true
        }</span> else<span class="cov8" title="1"> if !(reflect.DeepEqual(machinePoolScope.OCIMachinePool.Spec.InstanceConfiguration.InstanceConfigurationId, instancePool.InstanceConfigurationId)) </span><span class="cov8" title="1">{
                return true
        }</span>
        <span class="cov8" title="1">return false</span>
}

func (m *MachinePoolScope) getAgentConfig() *core.InstanceConfigurationLaunchInstanceAgentConfigDetails <span class="cov8" title="1">{
        agentConfigSpec := m.OCIMachinePool.Spec.InstanceConfiguration.AgentConfig
        if agentConfigSpec != nil </span><span class="cov8" title="1">{
                agentConfig := &amp;core.InstanceConfigurationLaunchInstanceAgentConfigDetails{
                        IsMonitoringDisabled:  agentConfigSpec.IsMonitoringDisabled,
                        IsManagementDisabled:  agentConfigSpec.IsManagementDisabled,
                        AreAllPluginsDisabled: agentConfigSpec.AreAllPluginsDisabled,
                }
                if len(agentConfigSpec.PluginsConfig) &gt; 0 </span><span class="cov8" title="1">{
                        pluginConfigList := make([]core.InstanceAgentPluginConfigDetails, len(agentConfigSpec.PluginsConfig))
                        for i, pluginConfigSpec := range agentConfigSpec.PluginsConfig </span><span class="cov8" title="1">{
                                pluginConfigRequest := core.InstanceAgentPluginConfigDetails{
                                        Name: pluginConfigSpec.Name,
                                }
                                desiredState, ok := core.GetMappingInstanceAgentPluginConfigDetailsDesiredStateEnum(string(pluginConfigSpec.DesiredState))
                                if ok </span><span class="cov8" title="1">{
                                        pluginConfigRequest.DesiredState = desiredState
                                }</span>
                                <span class="cov8" title="1">pluginConfigList[i] = pluginConfigRequest</span>
                        }
                        <span class="cov8" title="1">agentConfig.PluginsConfig = pluginConfigList</span>
                }
                <span class="cov8" title="1">return agentConfig</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (m *MachinePoolScope) getLaunchOptions() *core.InstanceConfigurationLaunchOptions <span class="cov8" title="1">{
        launcOptionsSpec := m.OCIMachinePool.Spec.InstanceConfiguration.LaunchOptions
        if launcOptionsSpec != nil </span><span class="cov0" title="0">{
                launchOptions := &amp;core.InstanceConfigurationLaunchOptions{
                        IsConsistentVolumeNamingEnabled: launcOptionsSpec.IsConsistentVolumeNamingEnabled,
                }
                if launcOptionsSpec.BootVolumeType != "" </span><span class="cov0" title="0">{
                        bootVolume, _ := core.GetMappingInstanceConfigurationLaunchOptionsBootVolumeTypeEnum(string(launcOptionsSpec.BootVolumeType))
                        launchOptions.BootVolumeType = bootVolume
                }</span>
                <span class="cov0" title="0">if launcOptionsSpec.Firmware != "" </span><span class="cov0" title="0">{
                        firmware, _ := core.GetMappingInstanceConfigurationLaunchOptionsFirmwareEnum(string(launcOptionsSpec.Firmware))
                        launchOptions.Firmware = firmware
                }</span>
                <span class="cov0" title="0">if launcOptionsSpec.NetworkType != "" </span><span class="cov0" title="0">{
                        networkType, _ := core.GetMappingInstanceConfigurationLaunchOptionsNetworkTypeEnum(string(launcOptionsSpec.NetworkType))
                        launchOptions.NetworkType = networkType
                }</span>
                <span class="cov0" title="0">if launcOptionsSpec.RemoteDataVolumeType != "" </span><span class="cov0" title="0">{
                        remoteVolumeType, _ := core.GetMappingInstanceConfigurationLaunchOptionsRemoteDataVolumeTypeEnum(string(launcOptionsSpec.RemoteDataVolumeType))
                        launchOptions.RemoteDataVolumeType = remoteVolumeType
                }</span>
                <span class="cov0" title="0">return launchOptions</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (m *MachinePoolScope) getInstanceOptions() *core.InstanceConfigurationInstanceOptions <span class="cov8" title="1">{
        instanceOptionsSpec := m.OCIMachinePool.Spec.InstanceConfiguration.InstanceOptions
        if instanceOptionsSpec != nil </span><span class="cov0" title="0">{
                return &amp;core.InstanceConfigurationInstanceOptions{
                        AreLegacyImdsEndpointsDisabled: instanceOptionsSpec.AreLegacyImdsEndpointsDisabled,
                }
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (m *MachinePoolScope) getInstanceConfigurationInstanceSourceViaImageDetail() core.InstanceConfigurationInstanceSourceViaImageDetails <span class="cov8" title="1">{
        sourceConfig := m.OCIMachinePool.Spec.InstanceConfiguration.InstanceSourceViaImageDetails
        if sourceConfig != nil </span><span class="cov0" title="0">{
                return core.InstanceConfigurationInstanceSourceViaImageDetails{
                        ImageId:             sourceConfig.ImageId,
                        BootVolumeVpusPerGB: sourceConfig.BootVolumeVpusPerGB,
                        BootVolumeSizeInGBs: sourceConfig.BootVolumeSizeInGBs,
                }
        }</span>
        <span class="cov8" title="1">return core.InstanceConfigurationInstanceSourceViaImageDetails{}</span>
}

func (m *MachinePoolScope) getAvailabilityConfig() *core.InstanceConfigurationAvailabilityConfig <span class="cov8" title="1">{
        avalabilityConfigSpec := m.OCIMachinePool.Spec.InstanceConfiguration.AvailabilityConfig
        if avalabilityConfigSpec != nil </span><span class="cov0" title="0">{
                recoveryAction, _ := core.GetMappingInstanceConfigurationAvailabilityConfigRecoveryActionEnum(string(avalabilityConfigSpec.RecoveryAction))
                return &amp;core.InstanceConfigurationAvailabilityConfig{
                        RecoveryAction: recoveryAction,
                }
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (m *MachinePoolScope) getPreemptibleInstanceConfig() *core.PreemptibleInstanceConfigDetails <span class="cov8" title="1">{
        preEmptibleInstanceConfigSpec := m.OCIMachinePool.Spec.InstanceConfiguration.PreemptibleInstanceConfig
        if preEmptibleInstanceConfigSpec != nil </span><span class="cov0" title="0">{
                preemptibleInstanceConfig := &amp;core.PreemptibleInstanceConfigDetails{}
                if preEmptibleInstanceConfigSpec.TerminatePreemptionAction != nil </span><span class="cov0" title="0">{
                        preemptibleInstanceConfig.PreemptionAction = core.TerminatePreemptionAction{
                                PreserveBootVolume: preEmptibleInstanceConfigSpec.TerminatePreemptionAction.PreserveBootVolume,
                        }
                }</span>
                <span class="cov0" title="0">return preemptibleInstanceConfig</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (m *MachinePoolScope) getPlatformConfig() core.PlatformConfig <span class="cov8" title="1">{
        platformConfig := m.OCIMachinePool.Spec.InstanceConfiguration.PlatformConfig
        if platformConfig != nil </span><span class="cov8" title="1">{
                switch platformConfig.PlatformConfigType </span>{
                case infrastructurev1beta2.PlatformConfigTypeAmdRomeBmGpu:<span class="cov0" title="0">
                        numaNodesPerSocket, _ := core.GetMappingAmdRomeBmGpuPlatformConfigNumaNodesPerSocketEnum(string(platformConfig.AmdRomeBmGpuPlatformConfig.NumaNodesPerSocket))
                        return core.AmdRomeBmGpuPlatformConfig{
                                IsSecureBootEnabled:                      platformConfig.AmdRomeBmGpuPlatformConfig.IsSecureBootEnabled,
                                IsTrustedPlatformModuleEnabled:           platformConfig.AmdRomeBmGpuPlatformConfig.IsTrustedPlatformModuleEnabled,
                                IsMeasuredBootEnabled:                    platformConfig.AmdRomeBmGpuPlatformConfig.IsMeasuredBootEnabled,
                                IsMemoryEncryptionEnabled:                platformConfig.AmdRomeBmGpuPlatformConfig.IsMemoryEncryptionEnabled,
                                IsSymmetricMultiThreadingEnabled:         platformConfig.AmdRomeBmGpuPlatformConfig.IsSymmetricMultiThreadingEnabled,
                                IsAccessControlServiceEnabled:            platformConfig.AmdRomeBmGpuPlatformConfig.IsAccessControlServiceEnabled,
                                AreVirtualInstructionsEnabled:            platformConfig.AmdRomeBmGpuPlatformConfig.AreVirtualInstructionsEnabled,
                                IsInputOutputMemoryManagementUnitEnabled: platformConfig.AmdRomeBmGpuPlatformConfig.IsInputOutputMemoryManagementUnitEnabled,
                                NumaNodesPerSocket:                       numaNodesPerSocket,
                        }</span>
                case infrastructurev1beta2.PlatformConfigTypeAmdRomeBm:<span class="cov0" title="0">
                        numaNodesPerSocket, _ := core.GetMappingAmdRomeBmPlatformConfigNumaNodesPerSocketEnum(string(platformConfig.AmdRomeBmPlatformConfig.NumaNodesPerSocket))
                        return core.AmdRomeBmPlatformConfig{
                                IsSecureBootEnabled:                      platformConfig.AmdRomeBmPlatformConfig.IsSecureBootEnabled,
                                IsTrustedPlatformModuleEnabled:           platformConfig.AmdRomeBmPlatformConfig.IsTrustedPlatformModuleEnabled,
                                IsMeasuredBootEnabled:                    platformConfig.AmdRomeBmPlatformConfig.IsMeasuredBootEnabled,
                                IsMemoryEncryptionEnabled:                platformConfig.AmdRomeBmPlatformConfig.IsMemoryEncryptionEnabled,
                                IsSymmetricMultiThreadingEnabled:         platformConfig.AmdRomeBmPlatformConfig.IsSymmetricMultiThreadingEnabled,
                                IsAccessControlServiceEnabled:            platformConfig.AmdRomeBmPlatformConfig.IsAccessControlServiceEnabled,
                                AreVirtualInstructionsEnabled:            platformConfig.AmdRomeBmPlatformConfig.AreVirtualInstructionsEnabled,
                                IsInputOutputMemoryManagementUnitEnabled: platformConfig.AmdRomeBmPlatformConfig.IsInputOutputMemoryManagementUnitEnabled,
                                PercentageOfCoresEnabled:                 platformConfig.AmdRomeBmPlatformConfig.PercentageOfCoresEnabled,
                                NumaNodesPerSocket:                       numaNodesPerSocket,
                        }</span>
                case infrastructurev1beta2.PlatformConfigTypeIntelIcelakeBm:<span class="cov0" title="0">
                        numaNodesPerSocket, _ := core.GetMappingIntelIcelakeBmPlatformConfigNumaNodesPerSocketEnum(string(platformConfig.IntelIcelakeBmPlatformConfig.NumaNodesPerSocket))
                        return core.IntelIcelakeBmPlatformConfig{
                                IsSecureBootEnabled:                      platformConfig.IntelIcelakeBmPlatformConfig.IsSecureBootEnabled,
                                IsTrustedPlatformModuleEnabled:           platformConfig.IntelIcelakeBmPlatformConfig.IsTrustedPlatformModuleEnabled,
                                IsMeasuredBootEnabled:                    platformConfig.IntelIcelakeBmPlatformConfig.IsMeasuredBootEnabled,
                                IsMemoryEncryptionEnabled:                platformConfig.IntelIcelakeBmPlatformConfig.IsMemoryEncryptionEnabled,
                                IsSymmetricMultiThreadingEnabled:         platformConfig.IntelIcelakeBmPlatformConfig.IsSymmetricMultiThreadingEnabled,
                                PercentageOfCoresEnabled:                 platformConfig.IntelIcelakeBmPlatformConfig.PercentageOfCoresEnabled,
                                IsInputOutputMemoryManagementUnitEnabled: platformConfig.IntelIcelakeBmPlatformConfig.IsInputOutputMemoryManagementUnitEnabled,
                                NumaNodesPerSocket:                       numaNodesPerSocket,
                        }</span>
                case infrastructurev1beta2.PlatformConfigTypeAmdvm:<span class="cov8" title="1">
                        return core.AmdVmPlatformConfig{
                                IsSecureBootEnabled:            platformConfig.AmdVmPlatformConfig.IsSecureBootEnabled,
                                IsTrustedPlatformModuleEnabled: platformConfig.AmdVmPlatformConfig.IsTrustedPlatformModuleEnabled,
                                IsMeasuredBootEnabled:          platformConfig.AmdVmPlatformConfig.IsMeasuredBootEnabled,
                                IsMemoryEncryptionEnabled:      platformConfig.AmdVmPlatformConfig.IsMemoryEncryptionEnabled,
                        }</span>
                case infrastructurev1beta2.PlatformConfigTypeIntelVm:<span class="cov0" title="0">
                        return core.IntelVmPlatformConfig{
                                IsSecureBootEnabled:            platformConfig.IntelVmPlatformConfig.IsSecureBootEnabled,
                                IsTrustedPlatformModuleEnabled: platformConfig.IntelVmPlatformConfig.IsTrustedPlatformModuleEnabled,
                                IsMeasuredBootEnabled:          platformConfig.IntelVmPlatformConfig.IsMeasuredBootEnabled,
                                IsMemoryEncryptionEnabled:      platformConfig.IntelVmPlatformConfig.IsMemoryEncryptionEnabled,
                        }</span>
                case infrastructurev1beta2.PlatformConfigTypeIntelSkylakeBm:<span class="cov0" title="0">
                        return core.IntelSkylakeBmPlatformConfig{
                                IsSecureBootEnabled:            platformConfig.IntelSkylakeBmPlatformConfig.IsSecureBootEnabled,
                                IsTrustedPlatformModuleEnabled: platformConfig.IntelSkylakeBmPlatformConfig.IsTrustedPlatformModuleEnabled,
                                IsMeasuredBootEnabled:          platformConfig.IntelSkylakeBmPlatformConfig.IsMeasuredBootEnabled,
                                IsMemoryEncryptionEnabled:      platformConfig.IntelSkylakeBmPlatformConfig.IsMemoryEncryptionEnabled,
                        }</span>
                case infrastructurev1beta2.PlatformConfigTypeAmdMilanBm:<span class="cov0" title="0">
                        numaNodesPerSocket, _ := core.GetMappingAmdMilanBmPlatformConfigNumaNodesPerSocketEnum(string(platformConfig.AmdMilanBmPlatformConfig.NumaNodesPerSocket))
                        return core.AmdMilanBmPlatformConfig{
                                IsSecureBootEnabled:                      platformConfig.AmdMilanBmPlatformConfig.IsSecureBootEnabled,
                                IsTrustedPlatformModuleEnabled:           platformConfig.AmdMilanBmPlatformConfig.IsTrustedPlatformModuleEnabled,
                                IsMeasuredBootEnabled:                    platformConfig.AmdMilanBmPlatformConfig.IsMeasuredBootEnabled,
                                IsMemoryEncryptionEnabled:                platformConfig.AmdMilanBmPlatformConfig.IsMemoryEncryptionEnabled,
                                IsSymmetricMultiThreadingEnabled:         platformConfig.AmdMilanBmPlatformConfig.IsSymmetricMultiThreadingEnabled,
                                IsAccessControlServiceEnabled:            platformConfig.AmdMilanBmPlatformConfig.IsAccessControlServiceEnabled,
                                AreVirtualInstructionsEnabled:            platformConfig.AmdMilanBmPlatformConfig.AreVirtualInstructionsEnabled,
                                IsInputOutputMemoryManagementUnitEnabled: platformConfig.AmdMilanBmPlatformConfig.IsInputOutputMemoryManagementUnitEnabled,
                                PercentageOfCoresEnabled:                 platformConfig.AmdMilanBmPlatformConfig.PercentageOfCoresEnabled,
                                NumaNodesPerSocket:                       numaNodesPerSocket,
                        }</span>
                default:<span class="cov0" title="0"></span>
                }
        }
        <span class="cov8" title="1">return nil</span>
}

func (m *MachinePoolScope) getWorkerMachineNSGs() []string <span class="cov8" title="1">{
        instanceVnicConfiguration := m.OCIMachinePool.Spec.InstanceConfiguration.InstanceVnicConfiguration
        if instanceVnicConfiguration != nil &amp;&amp; len(instanceVnicConfiguration.NsgNames) &gt; 0 </span><span class="cov8" title="1">{
                nsgs := make([]string, 0)
                for _, nsgName := range instanceVnicConfiguration.NsgNames </span><span class="cov8" title="1">{
                        for _, nsg := range ptr.ToNSGSlice(m.OCIClusterAccesor.GetNetworkSpec().Vcn.NetworkSecurityGroup.List) </span><span class="cov8" title="1">{
                                if nsg.Name == nsgName </span><span class="cov8" title="1">{
                                        nsgs = append(nsgs, ptr.ToString(nsg.ID))
                                }</span>
                        }
                }
                <span class="cov8" title="1">return nsgs</span>
        } else<span class="cov8" title="1"> {
                nsgs := make([]string, 0)
                for _, nsg := range ptr.ToNSGSlice(m.OCIClusterAccesor.GetNetworkSpec().Vcn.NetworkSecurityGroup.List) </span><span class="cov8" title="1">{
                        if nsg.Role == infrastructurev1beta2.WorkerRole </span><span class="cov8" title="1">{
                                nsgs = append(nsgs, ptr.ToString(nsg.ID))
                        }</span>
                }
                <span class="cov8" title="1">return nsgs</span>
        }
}

// GetInstanceConfiguration returns the instance configuration associated with the instance pool
// nolint:nilnil
func (m *MachinePoolScope) GetInstanceConfiguration(ctx context.Context) (*core.InstanceConfiguration, error) <span class="cov8" title="1">{
        instanceConfigurationId := m.GetInstanceConfigurationId()
        if instanceConfigurationId != nil </span><span class="cov8" title="1">{
                return m.getInstanceConfigurationFromOCID(ctx, instanceConfigurationId)
        }</span>

        <span class="cov8" title="1">ids, err := m.getInstanceConfigurationsFromDisplayNameSortedTimeCreateDescending(ctx, m.OCIMachinePool.GetName())
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if len(ids) &gt; 0 </span><span class="cov0" title="0">{
                return m.getInstanceConfigurationFromOCID(ctx, ids[0])
        }</span>
        <span class="cov8" title="1">return nil, nil</span>
}

func (m *MachinePoolScope) CleanupInstanceConfiguration(ctx context.Context, instancePool *core.InstancePool) error <span class="cov0" title="0">{
        m.Info("Cleaning up unused instance configurations")
        ids, err := m.getInstanceConfigurationsFromDisplayNameSortedTimeCreateDescending(ctx, m.OCIMachinePool.GetName())
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if len(ids) &gt; 0 </span><span class="cov0" title="0">{
                m.Info(fmt.Sprintf("Number of instance configurations found are %d", len(ids)))
                for _, id := range ids </span><span class="cov0" title="0">{
                        // if instance pool is nil, delete all configurations associated with the pool
                        if instancePool == nil || !reflect.DeepEqual(id, instancePool.InstanceConfigurationId) </span><span class="cov0" title="0">{
                                req := core.DeleteInstanceConfigurationRequest{InstanceConfigurationId: id}
                                if _, err := m.ComputeManagementClient.DeleteInstanceConfiguration(ctx, req); err != nil </span><span class="cov0" title="0">{
                                        return errors.Wrap(err, "failed to delete expired instance configuration")
                                }</span>
                        }
                }
        }
        <span class="cov0" title="0">return nil</span>
}

func (m *MachinePoolScope) getInstanceConfigurationFromOCID(ctx context.Context, instanceConfigurationId *string) (*core.InstanceConfiguration, error) <span class="cov8" title="1">{
        req := core.GetInstanceConfigurationRequest{InstanceConfigurationId: instanceConfigurationId}
        instanceConfiguration, err := m.ComputeManagementClient.GetInstanceConfiguration(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return &amp;instanceConfiguration.InstanceConfiguration, nil</span>
}

func (m *MachinePoolScope) getInstanceConfigurationsFromDisplayNameSortedTimeCreateDescending(ctx context.Context, displayName string) ([]*string, error) <span class="cov8" title="1">{
        listInstanceConfiguration := func(ctx context.Context, request core.ListInstanceConfigurationsRequest) (core.ListInstanceConfigurationsResponse, error) </span><span class="cov8" title="1">{
                return m.ComputeManagementClient.ListInstanceConfigurations(ctx, request)
        }</span>

        <span class="cov8" title="1">req := core.ListInstanceConfigurationsRequest{
                CompartmentId: common.String(m.OCIClusterAccesor.GetCompartmentId()),
                SortBy:        core.ListInstanceConfigurationsSortByTimecreated,
                SortOrder:     core.ListInstanceConfigurationsSortOrderDesc,
        }
        ids := make([]*string, 0)
        for </span><span class="cov8" title="1">{
                resp, err := listInstanceConfiguration(ctx, req)

                if err != nil </span><span class="cov0" title="0">{
                        return nil, errors.Wrapf(err, "failed to query InstanceConfiguration by name")
                }</span>

                <span class="cov8" title="1">for _, instanceConfiguration := range resp.Items </span><span class="cov0" title="0">{
                        if strings.HasPrefix(*instanceConfiguration.DisplayName, displayName) &amp;&amp;
                                m.IsResourceCreatedByClusterAPI(instanceConfiguration.FreeformTags) </span><span class="cov0" title="0">{
                                ids = append(ids, instanceConfiguration.Id)
                        }</span>
                }
                <span class="cov8" title="1">if resp.OpcNextPage == nil </span><span class="cov8" title="1">{
                        // no more pages
                        break</span>
                } else<span class="cov0" title="0"> {
                        req.Page = resp.OpcNextPage
                }</span>
        }

        <span class="cov8" title="1">return ids, nil</span>
}

func (m *MachinePoolScope) getVnicDetails(instanceConfigurationSpec infrav2exp.InstanceConfiguration, freeFormTags map[string]string, definedTags map[string]map[string]interface{}) *core.InstanceConfigurationCreateVnicDetails <span class="cov8" title="1">{
        subnetId := m.GetWorkerMachineSubnet()
        createVnicDetails := core.InstanceConfigurationCreateVnicDetails{
                SubnetId:     subnetId,
                FreeformTags: freeFormTags,
                DefinedTags:  definedTags,
                NsgIds:       m.getWorkerMachineNSGs(),
        }
        if instanceConfigurationSpec.InstanceVnicConfiguration != nil </span><span class="cov8" title="1">{
                createVnicDetails.AssignPublicIp = &amp;instanceConfigurationSpec.InstanceVnicConfiguration.AssignPublicIp
                createVnicDetails.HostnameLabel = instanceConfigurationSpec.InstanceVnicConfiguration.HostnameLabel
                createVnicDetails.SkipSourceDestCheck = instanceConfigurationSpec.InstanceVnicConfiguration.SkipSourceDestCheck
                createVnicDetails.AssignPrivateDnsRecord = instanceConfigurationSpec.InstanceVnicConfiguration.AssignPrivateDnsRecord
                createVnicDetails.DisplayName = instanceConfigurationSpec.InstanceVnicConfiguration.DisplayName
        }</span>
        <span class="cov8" title="1">return &amp;createVnicDetails</span>
}
</pre>
		
		<pre class="file" id="file47" style="display: none">/*
Copyright (c) 2021, 2022 Oracle and/or its affiliates.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package scope

import (
        "context"
        "encoding/base64"
        "fmt"
        "io"
        "reflect"
        "strings"

        "github.com/go-logr/logr"
        "github.com/google/go-cmp/cmp"
        "github.com/google/go-cmp/cmp/cmpopts"
        infrastructurev1beta2 "github.com/oracle/cluster-api-provider-oci/api/v1beta2"
        "github.com/oracle/cluster-api-provider-oci/cloud/ociutil"
        "github.com/oracle/cluster-api-provider-oci/cloud/ociutil/ptr"
        baseclient "github.com/oracle/cluster-api-provider-oci/cloud/services/base"
        "github.com/oracle/cluster-api-provider-oci/cloud/services/containerengine"
        "github.com/oracle/oci-go-sdk/v65/common"
        oke "github.com/oracle/oci-go-sdk/v65/containerengine"
        "github.com/pkg/errors"
        corev1 "k8s.io/api/core/v1"
        apierrors "k8s.io/apimachinery/pkg/api/errors"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/types"
        "k8s.io/client-go/tools/clientcmd"
        "k8s.io/client-go/tools/clientcmd/api"
        "k8s.io/klog/v2/klogr"
        clusterv1 "sigs.k8s.io/cluster-api/api/core/v1beta1"
        "sigs.k8s.io/cluster-api/util/kubeconfig"
        "sigs.k8s.io/cluster-api/util/patch"
        "sigs.k8s.io/cluster-api/util/secret"
        "sigs.k8s.io/controller-runtime/pkg/client"
)

const (
        // OKEInitScript is the cloud init script of OKE slef managed node:
        // Reference : https://docs.oracle.com/en-us/iaas/Content/ContEng/Tasks/contengcloudinitforselfmanagednodes.htm
        OKEInitScript = "#!/usr/bin/env bash\nbash /etc/oke/oke-install.sh \\\n  --apiserver-endpoint \"CLUSTER_ENDPOINT\" \\\n  --kubelet-ca-cert \"BASE_64_CA\""
)

// ManagedControlPlaneScopeParams defines the params need to create a new ManagedControlPlaneScope
type ManagedControlPlaneScopeParams struct {
        Logger                 *logr.Logger
        Client                 client.Client
        Cluster                *clusterv1.Cluster
        ContainerEngineClient  containerengine.Client
        BaseClient             baseclient.BaseClient
        ClientProvider         *ClientProvider
        OCIManagedControlPlane *infrastructurev1beta2.OCIManagedControlPlane
        OCIClusterAccessor     OCIClusterAccessor
        RegionIdentifier       string
}

type ManagedControlPlaneScope struct {
        *logr.Logger
        client                 client.Client
        Cluster                *clusterv1.Cluster
        ContainerEngineClient  containerengine.Client
        BaseClient             baseclient.BaseClient
        ClientProvider         *ClientProvider
        OCIManagedControlPlane *infrastructurev1beta2.OCIManagedControlPlane
        OCIClusterAccessor     OCIClusterAccessor
        RegionIdentifier       string
        patchHelper            *patch.Helper
}

// NewManagedControlPlaneScope creates a ManagedControlPlaneScope given the ManagedControlPlaneScopeParams
func NewManagedControlPlaneScope(params ManagedControlPlaneScopeParams) (*ManagedControlPlaneScope, error) <span class="cov8" title="1">{
        if params.Cluster == nil </span><span class="cov0" title="0">{
                return nil, errors.New("failed to generate new scope from nil Cluster")
        }</span>
        <span class="cov8" title="1">if params.OCIClusterAccessor == nil </span><span class="cov0" title="0">{
                return nil, errors.New("failed to generate new scope from nil OCIClusterAccessor")
        }</span>

        <span class="cov8" title="1">if params.Logger == nil </span><span class="cov8" title="1">{
                log := klogr.New()
                params.Logger = &amp;log
        }</span>

        <span class="cov8" title="1">return &amp;ManagedControlPlaneScope{
                Logger:                 params.Logger,
                client:                 params.Client,
                Cluster:                params.Cluster,
                ContainerEngineClient:  params.ContainerEngineClient,
                RegionIdentifier:       params.RegionIdentifier,
                ClientProvider:         params.ClientProvider,
                OCIClusterAccessor:     params.OCIClusterAccessor,
                OCIManagedControlPlane: params.OCIManagedControlPlane,
                BaseClient:             params.BaseClient,
        }, nil</span>
}

// GetOrCreateControlPlane tries to lookup a control plane(OKE cluster) based on ID/Name and returns the
// cluster if it exists, else creates an OKE cluster with the provided parameters in spec.
func (s *ManagedControlPlaneScope) GetOrCreateControlPlane(ctx context.Context) (*oke.Cluster, error) <span class="cov8" title="1">{
        cluster, err := s.GetOKECluster(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if cluster != nil </span><span class="cov8" title="1">{
                s.Logger.Info("Found an existing control plane")
                s.OCIManagedControlPlane.Spec.ID = cluster.Id
                return cluster, nil
        }</span>
        <span class="cov8" title="1">endpointConfig := &amp;oke.CreateClusterEndpointConfigDetails{
                SubnetId:          s.getControlPlaneEndpointSubnet(),
                NsgIds:            s.getControlPlaneEndpointNSGList(),
                IsPublicIpEnabled: common.Bool(s.IsControlPlaneEndpointSubnetPublic()),
        }
        controlPlaneSpec := s.OCIManagedControlPlane.Spec
        podNetworks := make([]oke.ClusterPodNetworkOptionDetails, 0)
        if len(controlPlaneSpec.ClusterPodNetworkOptions) &gt; 0 </span><span class="cov8" title="1">{
                for _, cniOption := range controlPlaneSpec.ClusterPodNetworkOptions </span><span class="cov8" title="1">{
                        if cniOption.CniType == infrastructurev1beta2.FlannelCNI </span><span class="cov8" title="1">{
                                podNetworks = append(podNetworks, oke.FlannelOverlayClusterPodNetworkOptionDetails{})
                        }</span> else<span class="cov8" title="1"> if cniOption.CniType == infrastructurev1beta2.VCNNativeCNI </span><span class="cov8" title="1">{
                                podNetworks = append(podNetworks, oke.OciVcnIpNativeClusterPodNetworkOptionDetails{})
                        }</span>
                }
        }
        <span class="cov8" title="1">createOptions := oke.ClusterCreateOptions{
                ServiceLbSubnetIds: s.getServiceLbSubnets(),
                PersistentVolumeConfig: &amp;oke.PersistentVolumeConfigDetails{
                        FreeformTags: s.getFreeFormTags(),
                        DefinedTags:  s.getDefinedTags(),
                },
                ServiceLbConfig: &amp;oke.ServiceLbConfigDetails{
                        FreeformTags: s.getFreeFormTags(),
                        DefinedTags:  s.getDefinedTags(),
                },
        }
        if s.Cluster.Spec.ClusterNetwork != nil </span><span class="cov8" title="1">{
                networkConfig := oke.KubernetesNetworkConfig{}
                if s.Cluster.Spec.ClusterNetwork.Pods != nil </span><span class="cov8" title="1">{
                        if len(s.Cluster.Spec.ClusterNetwork.Pods.CIDRBlocks) &gt; 0 </span><span class="cov8" title="1">{
                                networkConfig.PodsCidr = common.String(s.Cluster.Spec.ClusterNetwork.Pods.CIDRBlocks[0])
                        }</span>
                }
                <span class="cov8" title="1">if s.Cluster.Spec.ClusterNetwork.Services != nil </span><span class="cov8" title="1">{
                        if len(s.Cluster.Spec.ClusterNetwork.Services.CIDRBlocks) &gt; 0 </span><span class="cov8" title="1">{
                                networkConfig.ServicesCidr = common.String(s.Cluster.Spec.ClusterNetwork.Services.CIDRBlocks[0])
                        }</span>
                }
                <span class="cov8" title="1">createOptions.KubernetesNetworkConfig = &amp;networkConfig</span>
        }

        <span class="cov8" title="1">if controlPlaneSpec.ClusterOption.OpenIdConnectDiscovery != nil </span><span class="cov0" title="0">{
                createOptions.OpenIdConnectDiscovery = &amp;oke.OpenIdConnectDiscovery{
                        IsOpenIdConnectDiscoveryEnabled: controlPlaneSpec.ClusterOption.OpenIdConnectDiscovery.IsOpenIdConnectDiscoveryEnabled,
                }
        }</span>

        <span class="cov8" title="1">if controlPlaneSpec.ClusterOption.OpenIdConnectTokenAuthenticationConfig != nil </span><span class="cov0" title="0">{
                oidcConfig := controlPlaneSpec.ClusterOption.OpenIdConnectTokenAuthenticationConfig
                createOptions.OpenIdConnectTokenAuthenticationConfig = &amp;oke.OpenIdConnectTokenAuthenticationConfig{
                        IsOpenIdConnectAuthEnabled: &amp;oidcConfig.IsOpenIdConnectAuthEnabled,
                }

                if oidcConfig.IssuerUrl != nil </span><span class="cov0" title="0">{
                        createOptions.OpenIdConnectTokenAuthenticationConfig.IssuerUrl = oidcConfig.IssuerUrl
                }</span>
                <span class="cov0" title="0">if oidcConfig.ClientId != nil </span><span class="cov0" title="0">{
                        createOptions.OpenIdConnectTokenAuthenticationConfig.ClientId = oidcConfig.ClientId
                }</span>
                <span class="cov0" title="0">if oidcConfig.UsernameClaim != nil </span><span class="cov0" title="0">{
                        createOptions.OpenIdConnectTokenAuthenticationConfig.UsernameClaim = oidcConfig.UsernameClaim
                }</span>
                <span class="cov0" title="0">if oidcConfig.UsernamePrefix != nil </span><span class="cov0" title="0">{
                        createOptions.OpenIdConnectTokenAuthenticationConfig.UsernamePrefix = oidcConfig.UsernamePrefix
                }</span>
                <span class="cov0" title="0">if oidcConfig.GroupsClaim != nil </span><span class="cov0" title="0">{
                        createOptions.OpenIdConnectTokenAuthenticationConfig.GroupsClaim = oidcConfig.GroupsClaim
                }</span>
                <span class="cov0" title="0">if oidcConfig.GroupsPrefix != nil </span><span class="cov0" title="0">{
                        createOptions.OpenIdConnectTokenAuthenticationConfig.GroupsPrefix = oidcConfig.GroupsPrefix
                }</span>
                <span class="cov0" title="0">if oidcConfig.RequiredClaims != nil </span><span class="cov0" title="0">{
                        // Convert []infrastructurev1beta2.KeyValue to []containerengine.KeyValue
                        requiredClaims := make([]oke.KeyValue, len(oidcConfig.RequiredClaims))
                        for i, rc := range oidcConfig.RequiredClaims </span><span class="cov0" title="0">{
                                requiredClaims[i] = oke.KeyValue(rc)
                        }</span>
                        <span class="cov0" title="0">createOptions.OpenIdConnectTokenAuthenticationConfig.RequiredClaims = requiredClaims</span>
                }
                <span class="cov0" title="0">if oidcConfig.CaCertificate != nil </span><span class="cov0" title="0">{
                        createOptions.OpenIdConnectTokenAuthenticationConfig.CaCertificate = oidcConfig.CaCertificate
                }</span>
                <span class="cov0" title="0">if oidcConfig.SigningAlgorithms != nil </span><span class="cov0" title="0">{
                        createOptions.OpenIdConnectTokenAuthenticationConfig.SigningAlgorithms = oidcConfig.SigningAlgorithms
                }</span>
        }

        <span class="cov8" title="1">if controlPlaneSpec.ClusterOption.AddOnOptions != nil </span><span class="cov8" title="1">{
                createOptions.AddOns = &amp;oke.AddOnOptions{
                        IsKubernetesDashboardEnabled: controlPlaneSpec.ClusterOption.AddOnOptions.IsKubernetesDashboardEnabled,
                        IsTillerEnabled:              controlPlaneSpec.ClusterOption.AddOnOptions.IsTillerEnabled,
                }
        }</span>

        <span class="cov8" title="1">if controlPlaneSpec.ClusterOption.AdmissionControllerOptions != nil </span><span class="cov8" title="1">{
                createOptions.AdmissionControllerOptions = &amp;oke.AdmissionControllerOptions{
                        IsPodSecurityPolicyEnabled: controlPlaneSpec.ClusterOption.AdmissionControllerOptions.IsPodSecurityPolicyEnabled,
                }
        }</span>

        <span class="cov8" title="1">clusterType := getOKEClusterTypeFromSpecType(controlPlaneSpec)

        details := oke.CreateClusterDetails{
                Name:                     common.String(s.GetClusterName()),
                CompartmentId:            common.String(s.OCIClusterAccessor.GetCompartmentId()),
                VcnId:                    s.OCIClusterAccessor.GetNetworkSpec().Vcn.ID,
                KubernetesVersion:        controlPlaneSpec.Version,
                FreeformTags:             s.getFreeFormTags(),
                DefinedTags:              s.getDefinedTags(),
                Options:                  &amp;createOptions,
                EndpointConfig:           endpointConfig,
                ClusterPodNetworkOptions: podNetworks,
                KmsKeyId:                 controlPlaneSpec.KmsKeyId,
                Type:                     clusterType,
        }

        if controlPlaneSpec.ImagePolicyConfig != nil </span><span class="cov8" title="1">{
                details.ImagePolicyConfig = &amp;oke.CreateImagePolicyConfigDetails{
                        IsPolicyEnabled: s.OCIManagedControlPlane.Spec.ImagePolicyConfig.IsPolicyEnabled,
                        KeyDetails:      s.getKeyDetails(),
                }
        }</span>

        <span class="cov8" title="1">createClusterRequest := oke.CreateClusterRequest{
                CreateClusterDetails: details,
                OpcRetryToken:        ociutil.GetOPCRetryToken("%s-%s", "create-oke", string(s.OCIClusterAccessor.GetOCIResourceIdentifier())),
        }
        response, err := s.ContainerEngineClient.CreateCluster(ctx, createClusterRequest)

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">wrResponse, err := s.ContainerEngineClient.GetWorkRequest(ctx, oke.GetWorkRequestRequest{
                WorkRequestId: response.OpcWorkRequestId,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">var clusterId *string
        for _, resource := range wrResponse.Resources </span><span class="cov8" title="1">{
                if *resource.EntityType == "cluster" </span><span class="cov8" title="1">{
                        clusterId = resource.Identifier
                }</span>
        }
        <span class="cov8" title="1">if clusterId == nil </span><span class="cov0" title="0">{
                return nil, errors.New(fmt.Sprintf("oke cluster ws not created with the request, please create a "+
                        "support ticket with opc-request-id %s", *wrResponse.OpcRequestId))
        }</span>
        <span class="cov8" title="1">s.OCIManagedControlPlane.Spec.ID = clusterId
        return s.getOKEClusterFromOCID(ctx, clusterId)</span>
}

func getOKEClusterTypeFromSpecType(controlPlaneSpec infrastructurev1beta2.OCIManagedControlPlaneSpec) oke.ClusterTypeEnum <span class="cov8" title="1">{
        if controlPlaneSpec.ClusterType != "" </span><span class="cov0" title="0">{
                switch controlPlaneSpec.ClusterType </span>{
                case infrastructurev1beta2.BasicClusterType:<span class="cov0" title="0">
                        return oke.ClusterTypeBasicCluster</span>
                case infrastructurev1beta2.EnhancedClusterType:<span class="cov0" title="0">
                        return oke.ClusterTypeEnhancedCluster</span>
                default:<span class="cov0" title="0">
                        break</span>
                }
        }
        <span class="cov8" title="1">return ""</span>
}

// GetOKECluster tries to lookup a control plane(OKE cluster) based on ID/Name and returns the
// cluster if it exists,
func (s *ManagedControlPlaneScope) GetOKECluster(ctx context.Context) (*oke.Cluster, error) <span class="cov8" title="1">{
        okeClusterID := s.OCIManagedControlPlane.Spec.ID
        if okeClusterID != nil </span><span class="cov8" title="1">{
                return s.getOKEClusterFromOCID(ctx, okeClusterID)
        }</span>
        <span class="cov8" title="1">instance, err := s.getOKEClusterByDisplayName(ctx, s.GetClusterName())
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return instance, err</span>
}

func (s *ManagedControlPlaneScope) getOKEClusterFromOCID(ctx context.Context, clusterID *string) (*oke.Cluster, error) <span class="cov8" title="1">{
        req := oke.GetClusterRequest{ClusterId: clusterID}

        // Send the request using the service client
        resp, err := s.ContainerEngineClient.GetCluster(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return &amp;resp.Cluster, nil</span>
}

// nolint:nilnil
func (s *ManagedControlPlaneScope) getOKEClusterByDisplayName(ctx context.Context, name string) (*oke.Cluster, error) <span class="cov8" title="1">{
        var page *string
        for </span><span class="cov8" title="1">{
                req := oke.ListClustersRequest{
                        Name:          common.String(name),
                        CompartmentId: common.String(s.OCIClusterAccessor.GetCompartmentId()),
                        Page:          page,
                }
                resp, err := s.ContainerEngineClient.ListClusters(ctx, req)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">if len(resp.Items) == 0 </span><span class="cov8" title="1">{
                        return nil, nil
                }</span>
                <span class="cov8" title="1">for _, cluster := range resp.Items </span><span class="cov8" title="1">{
                        if s.isResourceCreatedByClusterAPI(cluster.FreeformTags) </span><span class="cov8" title="1">{
                                return s.getOKEClusterFromOCID(ctx, cluster.Id)
                        }</span>
                }
                <span class="cov0" title="0">if resp.OpcNextPage == nil </span><span class="cov0" title="0">{
                        break</span>
                } else<span class="cov0" title="0"> {
                        page = resp.OpcNextPage
                }</span>
        }
        <span class="cov0" title="0">return nil, nil</span>
}

func (s *ManagedControlPlaneScope) isResourceCreatedByClusterAPI(resourceFreeFormTags map[string]string) bool <span class="cov8" title="1">{
        tagsAddedByClusterAPI := ociutil.BuildClusterTags(s.OCIClusterAccessor.GetOCIResourceIdentifier())
        for k, v := range tagsAddedByClusterAPI </span><span class="cov8" title="1">{
                if resourceFreeFormTags[k] != v </span><span class="cov0" title="0">{
                        return false
                }</span>
        }
        <span class="cov8" title="1">return true</span>
}

// GetClusterName returns the name of the cluster
func (s *ManagedControlPlaneScope) GetClusterName() string <span class="cov8" title="1">{
        return s.OCIManagedControlPlane.Name
}</span>

func (s *ManagedControlPlaneScope) getDefinedTags() map[string]map[string]interface{} <span class="cov8" title="1">{
        tags := s.OCIClusterAccessor.GetDefinedTags()
        if tags == nil </span><span class="cov0" title="0">{
                return make(map[string]map[string]interface{})
        }</span>
        <span class="cov8" title="1">definedTags := make(map[string]map[string]interface{})
        for ns, mapNs := range tags </span><span class="cov8" title="1">{
                mapValues := make(map[string]interface{})
                for k, v := range mapNs </span><span class="cov8" title="1">{
                        mapValues[k] = v
                }</span>
                <span class="cov8" title="1">definedTags[ns] = mapValues</span>
        }
        <span class="cov8" title="1">return definedTags</span>
}
func (s *ManagedControlPlaneScope) getFreeFormTags() map[string]string <span class="cov8" title="1">{
        tags := s.OCIClusterAccessor.GetFreeformTags()
        if tags == nil </span><span class="cov8" title="1">{
                tags = make(map[string]string)
        }</span>
        <span class="cov8" title="1">tagsAddedByClusterAPI := ociutil.BuildClusterTags(s.OCIClusterAccessor.GetOCIResourceIdentifier())
        for k, v := range tagsAddedByClusterAPI </span><span class="cov8" title="1">{
                tags[k] = v
        }</span>
        <span class="cov8" title="1">return tags</span>
}

func (s *ManagedControlPlaneScope) getServiceLbSubnets() []string <span class="cov8" title="1">{
        subnets := make([]string, 0)
        for _, subnet := range ptr.ToSubnetSlice(s.OCIClusterAccessor.GetNetworkSpec().Vcn.Subnets) </span><span class="cov8" title="1">{
                if subnet.Role == infrastructurev1beta2.ServiceLoadBalancerRole </span><span class="cov8" title="1">{
                        subnets = append(subnets, ptr.ToString(subnet.ID))
                }</span>
        }
        <span class="cov8" title="1">return subnets</span>
}

func (s *ManagedControlPlaneScope) getControlPlaneEndpointSubnet() *string <span class="cov8" title="1">{
        for _, subnet := range ptr.ToSubnetSlice(s.OCIClusterAccessor.GetNetworkSpec().Vcn.Subnets) </span><span class="cov8" title="1">{
                if subnet.Role == infrastructurev1beta2.ControlPlaneEndpointRole </span><span class="cov8" title="1">{
                        return subnet.ID
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (s *ManagedControlPlaneScope) getControlPlaneEndpointNSGList() []string <span class="cov8" title="1">{
        nsgs := make([]string, 0)
        for _, nsg := range ptr.ToNSGSlice(s.OCIClusterAccessor.GetNetworkSpec().Vcn.NetworkSecurityGroup.List) </span><span class="cov8" title="1">{
                if nsg.Role == infrastructurev1beta2.ControlPlaneEndpointRole </span><span class="cov8" title="1">{
                        nsgs = append(nsgs, *nsg.ID)
                }</span>
        }
        <span class="cov8" title="1">return nsgs</span>
}

// IsControlPlaneEndpointSubnetPublic returns true if the control plane endpoint subnet is public
func (s *ManagedControlPlaneScope) IsControlPlaneEndpointSubnetPublic() bool <span class="cov8" title="1">{
        for _, subnet := range ptr.ToSubnetSlice(s.OCIClusterAccessor.GetNetworkSpec().Vcn.Subnets) </span><span class="cov8" title="1">{
                if subnet.Role == infrastructurev1beta2.ControlPlaneEndpointRole &amp;&amp; subnet.Type == infrastructurev1beta2.Public </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

// DeleteOKECluster deletes an OKE cluster
func (s *ManagedControlPlaneScope) DeleteOKECluster(ctx context.Context, cluster *oke.Cluster) error <span class="cov0" title="0">{
        req := oke.DeleteClusterRequest{ClusterId: cluster.Id}
        _, err := s.ContainerEngineClient.DeleteCluster(ctx, req)
        return err
}</span>

func (s *ManagedControlPlaneScope) createCAPIKubeconfigSecret(ctx context.Context, okeCluster *oke.Cluster, clusterRef types.NamespacedName) error <span class="cov8" title="1">{
        controllerOwnerRef := *metav1.NewControllerRef(s.OCIManagedControlPlane, infrastructurev1beta2.GroupVersion.WithKind("OCIManagedControlPlane"))
        req := oke.CreateKubeconfigRequest{ClusterId: okeCluster.Id}
        response, err := s.ContainerEngineClient.CreateKubeconfig(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">body, err := io.ReadAll(response.Content)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">config, err := clientcmd.NewClientConfigFromBytes(body)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">rawConfig, err := config.RawConfig()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if reflect.DeepEqual(rawConfig, api.Config{}) </span><span class="cov0" title="0">{
                return errors.Wrap(err, "failed to create kubeconfig")
        }</span>
        <span class="cov8" title="1">userName := getKubeConfigUserName(*okeCluster.Name, false)
        currentContext := rawConfig.Contexts[rawConfig.CurrentContext]
        if currentContext == nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "failed to create context")
        }</span>
        <span class="cov8" title="1">currentCluster := rawConfig.Clusters[currentContext.Cluster]
        if currentCluster == nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "failed to create cluster")
        }</span>
        <span class="cov8" title="1">cfg, err := createBaseKubeConfig(userName, currentCluster, currentContext.Cluster, rawConfig.CurrentContext)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">token, err := s.BaseClient.GenerateToken(ctx, *okeCluster.Id)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("generating presigned token: %w", err)
        }</span>
        <span class="cov8" title="1">cfg.AuthInfos = map[string]*api.AuthInfo{
                userName: {
                        Token: token,
                },
        }
        out, err := clientcmd.Write(*cfg)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "failed to serialize config to yaml")
        }</span>
        <span class="cov8" title="1">kubeconfigSecret := kubeconfig.GenerateSecretWithOwner(clusterRef, out, controllerOwnerRef)
        if err := s.client.Create(ctx, kubeconfigSecret); err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "failed to create kubeconfig secret")
        }</span>
        <span class="cov8" title="1">return err</span>

}

func createBaseKubeConfig(userName string, kubeconfigCluster *api.Cluster, clusterName string, contextName string) (*api.Config, error) <span class="cov8" title="1">{

        cfg := &amp;api.Config{
                APIVersion: api.SchemeGroupVersion.Version,
                Clusters: map[string]*api.Cluster{
                        clusterName: {
                                Server:                   kubeconfigCluster.Server,
                                CertificateAuthorityData: kubeconfigCluster.CertificateAuthorityData,
                        },
                },
                Contexts: map[string]*api.Context{
                        contextName: {
                                Cluster:  clusterName,
                                AuthInfo: userName,
                        },
                },
                CurrentContext: contextName,
        }

        return cfg, nil
}</span>

// ReconcileKubeconfig reconciles the kubeconfig secret which will be used by core CAPI components to talk to
// the OKE cluster
func (s *ManagedControlPlaneScope) ReconcileKubeconfig(ctx context.Context, okeCluster *oke.Cluster) error <span class="cov8" title="1">{
        clusterRef := types.NamespacedName{
                Name:      s.Cluster.Name,
                Namespace: s.Cluster.Namespace,
        }

        // Create the kubeconfig used by CAPI
        configSecret, err := secret.GetFromNamespacedName(ctx, s.client, clusterRef, secret.Kubeconfig)
        if err != nil </span><span class="cov8" title="1">{
                if !apierrors.IsNotFound(err) </span><span class="cov0" title="0">{
                        return errors.Wrap(err, "failed to get kubeconfig secret")
                }</span>

                <span class="cov8" title="1">if createErr := s.createCAPIKubeconfigSecret(
                        ctx,
                        okeCluster,
                        clusterRef,
                ); createErr != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("creating kubeconfig secret: %w", createErr)
                }</span>
        } else<span class="cov8" title="1"> if updateErr := s.updateCAPIKubeconfigSecret(ctx, configSecret, okeCluster); updateErr != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("updating kubeconfig secret: %w", updateErr)
        }</span>

        // Set initialized to true to indicate the kubconfig has been created
        <span class="cov8" title="1">s.OCIManagedControlPlane.Status.Initialized = true

        return nil</span>
}

// ReconcileBootstrapSecret reconciles the bootsrap secret which will be used by self managed nodes
func (s *ManagedControlPlaneScope) ReconcileBootstrapSecret(ctx context.Context, okeCluster *oke.Cluster) error <span class="cov0" title="0">{
        controllerOwnerRef := *metav1.NewControllerRef(s.OCIManagedControlPlane, infrastructurev1beta2.GroupVersion.WithKind("OCIManagedControlPlane"))
        secretName := fmt.Sprintf("%s-self-managed", s.Cluster.Name)
        secretKey := client.ObjectKey{
                Namespace: s.Cluster.Namespace,
                Name:      secretName,
        }
        err := s.client.Get(ctx, secretKey, &amp;corev1.Secret{})
        if err != nil </span><span class="cov0" title="0">{
                if !apierrors.IsNotFound(err) </span><span class="cov0" title="0">{
                        return errors.Wrap(err, "failed to get kubeconfig secret")
                }</span>

                <span class="cov0" title="0">req := oke.CreateKubeconfigRequest{ClusterId: okeCluster.Id}
                response, err := s.ContainerEngineClient.CreateKubeconfig(ctx, req)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">body, err := io.ReadAll(response.Content)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">config, err := clientcmd.NewClientConfigFromBytes(body)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">rawConfig, err := config.RawConfig()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if reflect.DeepEqual(rawConfig, api.Config{}) </span><span class="cov0" title="0">{
                        return errors.Wrap(err, "failed to create kubeconfig")
                }</span>
                <span class="cov0" title="0">currentContext := rawConfig.Contexts[rawConfig.CurrentContext]
                if currentContext == nil </span><span class="cov0" title="0">{
                        return errors.Wrap(err, "failed to create context")
                }</span>
                <span class="cov0" title="0">currentCluster := rawConfig.Clusters[currentContext.Cluster]
                if currentCluster == nil </span><span class="cov0" title="0">{
                        return errors.Wrap(err, "failed to create cluster")
                }</span>
                <span class="cov0" title="0">certData := base64.StdEncoding.EncodeToString(currentCluster.CertificateAuthorityData)

                endpoint := strings.Split(*okeCluster.Endpoints.PrivateEndpoint, ":")[0]
                initStr := strings.Replace(OKEInitScript, "BASE_64_CA", certData, 1)
                initStr = strings.Replace(initStr, "CLUSTER_ENDPOINT", endpoint, 1)

                cluster := s.Cluster
                secret := &amp;corev1.Secret{
                        ObjectMeta: metav1.ObjectMeta{
                                Name:      secretName,
                                Namespace: cluster.Namespace,
                                Labels: map[string]string{
                                        clusterv1.ClusterNameLabel: cluster.Name,
                                },
                                OwnerReferences: []metav1.OwnerReference{
                                        controllerOwnerRef,
                                },
                        },
                        Data: map[string][]byte{
                                secret.KubeconfigDataName: []byte(initStr),
                        },
                }

                if err := s.client.Create(ctx, secret); err != nil </span><span class="cov0" title="0">{
                        return errors.Wrap(err, "failed to create kubeconfig secret")
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (s *ManagedControlPlaneScope) updateCAPIKubeconfigSecret(ctx context.Context, configSecret *corev1.Secret, okeCluster *oke.Cluster) error <span class="cov8" title="1">{
        data, ok := configSecret.Data[secret.KubeconfigDataName]
        if !ok </span><span class="cov0" title="0">{
                return errors.Errorf("missing key %q in secret data", secret.KubeconfigDataName)
        }</span>

        <span class="cov8" title="1">config, err := clientcmd.Load(data)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "failed to convert kubeconfig Secret into a clientcmdapi.Config")
        }</span>

        <span class="cov8" title="1">token, err := s.BaseClient.GenerateToken(ctx, *okeCluster.Id)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("generating presigned token: %w", err)
        }</span>

        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("generating presigned token: %w", err)
        }</span>

        <span class="cov8" title="1">userName := getKubeConfigUserName(*okeCluster.Name, false)
        if authInfo := config.AuthInfos[userName]; authInfo != nil </span><span class="cov8" title="1">{
                authInfo.Token = token
        }</span> else<span class="cov0" title="0"> {
                return fmt.Errorf("user %s not found in config", userName)
        }</span>

        <span class="cov8" title="1">out, err := clientcmd.Write(*config)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "failed to serialize config to yaml")
        }</span>

        <span class="cov8" title="1">configSecret.Data[secret.KubeconfigDataName] = out

        err = s.client.Update(ctx, configSecret)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("updating kubeconfig secret: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (s *ManagedControlPlaneScope) getKeyDetails() []oke.KeyDetails <span class="cov8" title="1">{
        if len(s.OCIManagedControlPlane.Spec.ImagePolicyConfig.KeyDetails) &gt; 0 </span><span class="cov8" title="1">{
                keys := make([]oke.KeyDetails, 0)
                for _, key := range s.OCIManagedControlPlane.Spec.ImagePolicyConfig.KeyDetails </span><span class="cov8" title="1">{
                        keys = append(keys, oke.KeyDetails{
                                KmsKeyId: key.KmsKeyId,
                        })
                }</span>
                <span class="cov8" title="1">return keys</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// UpdateControlPlane updates the control plane(OKE cluster) if necessary based on spec changes
func (s *ManagedControlPlaneScope) UpdateControlPlane(ctx context.Context, okeCluster *oke.Cluster) (bool, error) <span class="cov8" title="1">{
        spec := s.OCIManagedControlPlane.Spec.DeepCopy()
        setControlPlaneSpecDefaults(spec)

        actual := s.getSpecFromActual(okeCluster)

        // Check for tag-only changes (tags live on OCIManagedCluster, not in control plane spec)
        tagsChanged := s.hasClusterTagChanges(okeCluster)

        // Log the actual and desired specs
        if tagsChanged || !s.compareSpecs(spec, actual) </span><span class="cov8" title="1">{
                controlPlaneSpec := s.OCIManagedControlPlane.Spec
                updateOptions := oke.UpdateClusterOptionsDetails{}
                if controlPlaneSpec.ClusterOption.AdmissionControllerOptions != nil </span><span class="cov8" title="1">{
                        updateOptions.AdmissionControllerOptions = &amp;oke.AdmissionControllerOptions{
                                IsPodSecurityPolicyEnabled: controlPlaneSpec.ClusterOption.AdmissionControllerOptions.IsPodSecurityPolicyEnabled,
                        }
                }</span>
                <span class="cov8" title="1">if controlPlaneSpec.ClusterOption.OpenIdConnectDiscovery != nil </span><span class="cov0" title="0">{
                        updateOptions.OpenIdConnectDiscovery = &amp;oke.OpenIdConnectDiscovery{
                                IsOpenIdConnectDiscoveryEnabled: controlPlaneSpec.ClusterOption.OpenIdConnectDiscovery.IsOpenIdConnectDiscoveryEnabled,
                        }
                }</span>
                <span class="cov8" title="1">if controlPlaneSpec.ClusterOption.OpenIdConnectTokenAuthenticationConfig != nil </span><span class="cov0" title="0">{
                        s.Logger.Info("Updating OIDC Connect Token config")
                        oidcConfig := controlPlaneSpec.ClusterOption.OpenIdConnectTokenAuthenticationConfig
                        updateOptions.OpenIdConnectTokenAuthenticationConfig = &amp;oke.OpenIdConnectTokenAuthenticationConfig{
                                IsOpenIdConnectAuthEnabled: &amp;oidcConfig.IsOpenIdConnectAuthEnabled,
                        }

                        if oidcConfig.IssuerUrl != nil </span><span class="cov0" title="0">{
                                updateOptions.OpenIdConnectTokenAuthenticationConfig.IssuerUrl = oidcConfig.IssuerUrl
                        }</span>
                        <span class="cov0" title="0">if oidcConfig.ClientId != nil </span><span class="cov0" title="0">{
                                updateOptions.OpenIdConnectTokenAuthenticationConfig.ClientId = oidcConfig.ClientId
                        }</span>
                        <span class="cov0" title="0">if oidcConfig.UsernameClaim != nil </span><span class="cov0" title="0">{
                                updateOptions.OpenIdConnectTokenAuthenticationConfig.UsernameClaim = oidcConfig.UsernameClaim
                        }</span>
                        <span class="cov0" title="0">if oidcConfig.UsernamePrefix != nil </span><span class="cov0" title="0">{
                                updateOptions.OpenIdConnectTokenAuthenticationConfig.UsernamePrefix = oidcConfig.UsernamePrefix
                        }</span>
                        <span class="cov0" title="0">if oidcConfig.GroupsClaim != nil </span><span class="cov0" title="0">{
                                updateOptions.OpenIdConnectTokenAuthenticationConfig.GroupsClaim = oidcConfig.GroupsClaim
                        }</span>
                        <span class="cov0" title="0">if oidcConfig.GroupsPrefix != nil </span><span class="cov0" title="0">{
                                updateOptions.OpenIdConnectTokenAuthenticationConfig.GroupsPrefix = oidcConfig.GroupsPrefix
                        }</span>
                        <span class="cov0" title="0">if oidcConfig.RequiredClaims != nil </span><span class="cov0" title="0">{
                                // Convert []infrastructurev1beta2.KeyValue to []containerengine.KeyValue
                                requiredClaims := make([]oke.KeyValue, len(oidcConfig.RequiredClaims))
                                for i, rc := range oidcConfig.RequiredClaims </span><span class="cov0" title="0">{
                                        requiredClaims[i] = oke.KeyValue(rc)
                                }</span>
                                <span class="cov0" title="0">updateOptions.OpenIdConnectTokenAuthenticationConfig.RequiredClaims = requiredClaims</span>
                        }
                        <span class="cov0" title="0">if oidcConfig.CaCertificate != nil </span><span class="cov0" title="0">{
                                updateOptions.OpenIdConnectTokenAuthenticationConfig.CaCertificate = oidcConfig.CaCertificate
                        }</span>
                        <span class="cov0" title="0">if oidcConfig.SigningAlgorithms != nil </span><span class="cov0" title="0">{
                                updateOptions.OpenIdConnectTokenAuthenticationConfig.SigningAlgorithms = oidcConfig.SigningAlgorithms
                        }</span>

                        <span class="cov0" title="0">s.Logger.Info("Updated OIDC Connect Token config", "config", updateOptions.OpenIdConnectTokenAuthenticationConfig)</span>
                }
                <span class="cov8" title="1">details := oke.UpdateClusterDetails{
                        Name:              common.String(s.GetClusterName()),
                        KubernetesVersion: controlPlaneSpec.Version,
                        Options:           &amp;updateOptions,
                        FreeformTags:      s.getFreeFormTags(),
                        DefinedTags:       s.getDefinedTags(),
                }
                if controlPlaneSpec.ImagePolicyConfig != nil </span><span class="cov8" title="1">{
                        details.ImagePolicyConfig = &amp;oke.UpdateImagePolicyConfigDetails{
                                IsPolicyEnabled: s.OCIManagedControlPlane.Spec.ImagePolicyConfig.IsPolicyEnabled,
                                KeyDetails:      s.getKeyDetails(),
                        }
                }</span>
                <span class="cov8" title="1">clusterType := getOKEClusterTypeFromSpecType(controlPlaneSpec)
                details.Type = clusterType
                updateClusterRequest := oke.UpdateClusterRequest{
                        ClusterId:            okeCluster.Id,
                        UpdateClusterDetails: details,
                }
                _, err := s.ContainerEngineClient.UpdateCluster(ctx, updateClusterRequest)
                if err != nil </span><span class="cov0" title="0">{
                        return false, errors.Wrapf(err, "failed to update cluster")
                }</span>

                <span class="cov8" title="1">s.Info("Updated control plane")
                return true, nil</span>
        } else<span class="cov8" title="1"> {
                s.Info("No reconciliation needed for control plane")
        }</span>
        <span class="cov8" title="1">return false, nil</span>
}

// compareSpecs compares two OCIManagedControlPlaneSpec objects for equality
func (s *ManagedControlPlaneScope) compareSpecs(spec1, spec2 *infrastructurev1beta2.OCIManagedControlPlaneSpec) bool <span class="cov8" title="1">{
        if spec1 == nil || spec2 == nil </span><span class="cov8" title="1">{
                return spec1 == spec2
        }</span>

        // Use go-cmp to compare the specs
        <span class="cov8" title="1">equal := cmp.Equal(spec1, spec2, cmpopts.EquateEmpty())
        if !equal </span><span class="cov8" title="1">{
                diff := cmp.Diff(spec1, spec2, cmpopts.EquateEmpty())
                s.Logger.Info("Specs are different", "diff", diff)
        }</span>
        <span class="cov8" title="1">return equal</span>
}

// setControlPlaneSpecDefaults sets the defaults in the spec as returned by OKE API. We need to set defaults here rather than webhook as well as
// there is a chance user will edit the cluster
func setControlPlaneSpecDefaults(spec *infrastructurev1beta2.OCIManagedControlPlaneSpec) <span class="cov8" title="1">{
        spec.ControlPlaneEndpoint = clusterv1.APIEndpoint{}
        if spec.ClusterType == "" </span><span class="cov8" title="1">{
                spec.ClusterType = infrastructurev1beta2.BasicClusterType
        }</span>
        <span class="cov8" title="1">spec.Addons = nil
        if spec.ImagePolicyConfig == nil </span><span class="cov0" title="0">{
                spec.ImagePolicyConfig = &amp;infrastructurev1beta2.ImagePolicyConfig{
                        IsPolicyEnabled: common.Bool(false),
                        KeyDetails:      make([]infrastructurev1beta2.KeyDetails, 0),
                }
        }</span>
        <span class="cov8" title="1">if spec.ClusterOption.AdmissionControllerOptions == nil </span><span class="cov0" title="0">{
                spec.ClusterOption.AdmissionControllerOptions = &amp;infrastructurev1beta2.AdmissionControllerOptions{
                        IsPodSecurityPolicyEnabled: common.Bool(false),
                }
        }</span>
        <span class="cov8" title="1">if spec.ClusterOption.AddOnOptions == nil </span><span class="cov0" title="0">{
                spec.ClusterOption.AddOnOptions = &amp;infrastructurev1beta2.AddOnOptions{
                        IsTillerEnabled:              common.Bool(false),
                        IsKubernetesDashboardEnabled: common.Bool(false),
                }
        }</span>
}

func (s *ManagedControlPlaneScope) getSpecFromActual(cluster *oke.Cluster) *infrastructurev1beta2.OCIManagedControlPlaneSpec <span class="cov8" title="1">{
        spec := infrastructurev1beta2.OCIManagedControlPlaneSpec{
                Version:  cluster.KubernetesVersion,
                KmsKeyId: cluster.KmsKeyId,
                ID:       cluster.Id,
                Addons:   nil,
        }
        if cluster.ImagePolicyConfig != nil </span><span class="cov8" title="1">{
                keys := make([]infrastructurev1beta2.KeyDetails, 0)
                for _, key := range cluster.ImagePolicyConfig.KeyDetails </span><span class="cov8" title="1">{
                        keys = append(keys, infrastructurev1beta2.KeyDetails{
                                KmsKeyId: key.KmsKeyId,
                        })
                }</span>
                <span class="cov8" title="1">spec.ImagePolicyConfig = &amp;infrastructurev1beta2.ImagePolicyConfig{
                        IsPolicyEnabled: cluster.ImagePolicyConfig.IsPolicyEnabled,
                        KeyDetails:      keys,
                }</span>
        }
        <span class="cov8" title="1">if len(cluster.ClusterPodNetworkOptions) &gt; 0 </span><span class="cov8" title="1">{
                podNetworks := make([]infrastructurev1beta2.ClusterPodNetworkOptions, 0)
                for _, cniOption := range cluster.ClusterPodNetworkOptions </span><span class="cov8" title="1">{
                        _, ok := cniOption.(oke.OciVcnIpNativeClusterPodNetworkOptionDetails)
                        if ok </span><span class="cov8" title="1">{
                                podNetworks = append(podNetworks, infrastructurev1beta2.ClusterPodNetworkOptions{
                                        CniType: infrastructurev1beta2.VCNNativeCNI,
                                })
                        }</span> else<span class="cov8" title="1"> {
                                podNetworks = append(podNetworks, infrastructurev1beta2.ClusterPodNetworkOptions{
                                        CniType: infrastructurev1beta2.FlannelCNI,
                                })
                        }</span>
                }
                <span class="cov8" title="1">spec.ClusterPodNetworkOptions = podNetworks</span>
        }
        <span class="cov8" title="1">if cluster.Options != nil </span><span class="cov8" title="1">{
                if cluster.Options.AdmissionControllerOptions != nil </span><span class="cov8" title="1">{
                        spec.ClusterOption.AdmissionControllerOptions = &amp;infrastructurev1beta2.AdmissionControllerOptions{
                                IsPodSecurityPolicyEnabled: cluster.Options.AdmissionControllerOptions.IsPodSecurityPolicyEnabled,
                        }
                }</span>
                <span class="cov8" title="1">if cluster.Options.AddOns != nil </span><span class="cov8" title="1">{
                        spec.ClusterOption.AddOnOptions = &amp;infrastructurev1beta2.AddOnOptions{
                                IsTillerEnabled:              cluster.Options.AddOns.IsTillerEnabled,
                                IsKubernetesDashboardEnabled: cluster.Options.AddOns.IsKubernetesDashboardEnabled,
                        }
                }</span>
                <span class="cov8" title="1">if cluster.Options.OpenIdConnectDiscovery != nil </span><span class="cov0" title="0">{
                        spec.ClusterOption.OpenIdConnectDiscovery = &amp;infrastructurev1beta2.OpenIDConnectDiscovery{
                                IsOpenIdConnectDiscoveryEnabled: cluster.Options.OpenIdConnectDiscovery.IsOpenIdConnectDiscoveryEnabled,
                        }
                }</span>
                <span class="cov8" title="1">if cluster.Options.OpenIdConnectTokenAuthenticationConfig != nil </span><span class="cov0" title="0">{
                        oidcConfig := cluster.Options.OpenIdConnectTokenAuthenticationConfig
                        requiredClaims := make([]infrastructurev1beta2.KeyValue, len(oidcConfig.RequiredClaims))
                        for i, rc := range oidcConfig.RequiredClaims </span><span class="cov0" title="0">{
                                requiredClaims[i] = infrastructurev1beta2.KeyValue(rc)
                        }</span>
                        <span class="cov0" title="0">spec.ClusterOption.OpenIdConnectTokenAuthenticationConfig = &amp;infrastructurev1beta2.OpenIDConnectTokenAuthenticationConfig{
                                IsOpenIdConnectAuthEnabled: *oidcConfig.IsOpenIdConnectAuthEnabled,
                                IssuerUrl:                  oidcConfig.IssuerUrl,
                                ClientId:                   oidcConfig.ClientId,
                                UsernameClaim:              oidcConfig.UsernameClaim,
                                UsernamePrefix:             oidcConfig.UsernamePrefix,
                                GroupsClaim:                oidcConfig.GroupsClaim,
                                GroupsPrefix:               oidcConfig.GroupsPrefix,
                                RequiredClaims:             requiredClaims,
                                CaCertificate:              oidcConfig.CaCertificate,
                                SigningAlgorithms:          oidcConfig.SigningAlgorithms,
                        }</span>
                }
        }
        <span class="cov8" title="1">if cluster.Type != "" </span><span class="cov8" title="1">{
                switch cluster.Type </span>{
                case oke.ClusterTypeBasicCluster:<span class="cov8" title="1">
                        spec.ClusterType = infrastructurev1beta2.BasicClusterType
                        break</span>
                case oke.ClusterTypeEnhancedCluster:<span class="cov0" title="0">
                        spec.ClusterType = infrastructurev1beta2.EnhancedClusterType
                        break</span>
                default:<span class="cov0" title="0">
                        spec.ClusterType = infrastructurev1beta2.BasicClusterType
                        break</span>
                }
        }
        <span class="cov8" title="1">return &amp;spec</span>
}

func (s *ManagedControlPlaneScope) hasClusterTagChanges(okeCluster *oke.Cluster) bool <span class="cov8" title="1">{
        desiredFF := s.getFreeFormTags()
        desiredDT := s.getDefinedTags()
        actualFF := okeCluster.FreeformTags
        actualDT := map[string]map[string]interface{}{}
        if okeCluster.DefinedTags != nil </span><span class="cov8" title="1">{
                actualDT = okeCluster.DefinedTags
        }</span>
        <span class="cov8" title="1">tagsChanged := !cmp.Equal(desiredFF, actualFF, cmpopts.EquateEmpty()) || !cmp.Equal(desiredDT, actualDT, cmpopts.EquateEmpty())
        return tagsChanged</span>
}

// ReconcileAddons reconciles addons which have been specified in the spec on the OKE cluster
func (s *ManagedControlPlaneScope) ReconcileAddons(ctx context.Context, okeCluster *oke.Cluster) error <span class="cov8" title="1">{
        addonSpec := s.OCIManagedControlPlane.Spec.Addons
        // go through the list of addons present in the spec and reconcile them, reconcile can be 2 ways, either
        // install the addon if it has not been installed till now, or update the addon
        for _, addon := range addonSpec </span><span class="cov8" title="1">{
                resp, err := s.ContainerEngineClient.GetAddon(ctx, oke.GetAddonRequest{
                        ClusterId: okeCluster.Id,
                        AddonName: addon.Name,
                })
                if err != nil </span><span class="cov8" title="1">{
                        // addon is not present, hence install it
                        if ociutil.IsNotFound(err) </span><span class="cov8" title="1">{
                                s.Info(fmt.Sprintf("Install addon %s", *addon.Name))
                                _, err = s.ContainerEngineClient.InstallAddon(ctx, oke.InstallAddonRequest{
                                        ClusterId: okeCluster.Id,
                                        InstallAddonDetails: oke.InstallAddonDetails{
                                                Version:        addon.Version,
                                                Configurations: getAddonConfigurations(addon.Configurations),
                                                AddonName:      addon.Name,
                                        },
                                })
                                if err != nil </span><span class="cov8" title="1">{
                                        return err
                                }</span>
                                // add it to status, details will be reconciled in next loop
                                <span class="cov8" title="1">status := infrastructurev1beta2.AddonStatus{
                                        LifecycleState: common.String(string(oke.AddonLifecycleStateCreating)),
                                }
                                s.OCIManagedControlPlane.SetAddonStatus(*addon.Name, status)</span>
                        } else<span class="cov0" title="0"> {
                                return err
                        }</span>
                } else<span class="cov8" title="1"> {
                        s.OCIManagedControlPlane.SetAddonStatus(*addon.Name, s.getStatus(resp.Addon))
                        // addon present, update it
                        err = s.handleExistingAddon(ctx, okeCluster, resp.Addon, addon)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }
        // for addons which are present in the status object but not in the spec, the possibility
        // is that user deleted it from the spec. Hence disable the addon
        <span class="cov8" title="1">for k, _ := range s.OCIManagedControlPlane.Status.AddonStatus </span><span class="cov8" title="1">{
                // present in status but not in spec
                if getAddon(addonSpec, k) == nil </span><span class="cov8" title="1">{
                        err := s.handleDeletedAddon(ctx, okeCluster, k)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }
        <span class="cov8" title="1">return nil</span>
}

func (s *ManagedControlPlaneScope) getStatus(addon oke.Addon) infrastructurev1beta2.AddonStatus <span class="cov8" title="1">{
        // update status of the addon
        status := infrastructurev1beta2.AddonStatus{
                LifecycleState:            common.String(string(addon.LifecycleState)),
                CurrentlyInstalledVersion: addon.CurrentInstalledVersion,
        }
        if addon.AddonError != nil </span><span class="cov8" title="1">{
                status.AddonError = &amp;infrastructurev1beta2.AddonError{
                        Status:  addon.AddonError.Status,
                        Code:    addon.AddonError.Code,
                        Message: addon.AddonError.Message,
                }
        }</span>
        <span class="cov8" title="1">return status</span>
}

func (s *ManagedControlPlaneScope) handleExistingAddon(ctx context.Context, okeCluster *oke.Cluster, addon oke.Addon, addonInSpec infrastructurev1beta2.Addon) error <span class="cov8" title="1">{
        // if the addon can be updated do so
        // if the addon is already in updating state, or in failed state, do not update
        s.Info(fmt.Sprintf("Reconciling addon %s with lifecycle state %s", *addon.Name, string(addon.LifecycleState)))
        if !(addon.LifecycleState == oke.AddonLifecycleStateUpdating ||
                addon.LifecycleState == oke.AddonLifecycleStateFailed) </span><span class="cov8" title="1">{
                addonConfigurationsActual := getActualAddonConfigurations(addon.Configurations)
                // if the version changed or the configuration changed, update the addon
                // if the lifecycle state is needs attention, try to update
                if addon.LifecycleState == oke.AddonLifecycleStateNeedsAttention ||
                        !reflect.DeepEqual(addonInSpec.Version, addon.Version) ||
                        !reflect.DeepEqual(addonConfigurationsActual, addonInSpec.Configurations) </span><span class="cov8" title="1">{
                        s.Info(fmt.Sprintf("Updating addon %s", *addon.Name))
                        _, err := s.ContainerEngineClient.UpdateAddon(ctx, oke.UpdateAddonRequest{
                                ClusterId: okeCluster.Id,
                                AddonName: addon.Name,
                                UpdateAddonDetails: oke.UpdateAddonDetails{
                                        Version:        addonInSpec.Version,
                                        Configurations: getAddonConfigurations(addonInSpec.Configurations),
                                },
                        })
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }
        <span class="cov8" title="1">return nil</span>
}

func (s *ManagedControlPlaneScope) handleDeletedAddon(ctx context.Context, okeCluster *oke.Cluster, addonName string) error <span class="cov8" title="1">{
        resp, err := s.ContainerEngineClient.GetAddon(ctx, oke.GetAddonRequest{
                ClusterId: okeCluster.Id,
                AddonName: common.String(addonName),
        })
        if err != nil </span><span class="cov8" title="1">{
                if ociutil.IsNotFound(err) </span><span class="cov8" title="1">{
                        s.OCIManagedControlPlane.RemoveAddonStatus(addonName)
                        return nil
                }</span> else<span class="cov0" title="0"> {
                        return err
                }</span>
        }
        <span class="cov8" title="1">addonState := resp.LifecycleState
        switch addonState </span>{
        // nothing to do if addon is in deleting state
        case oke.AddonLifecycleStateDeleting:<span class="cov8" title="1">
                s.Info(fmt.Sprintf("Addon %s is in deleting state", addonName))
                break</span>
        case oke.AddonLifecycleStateDeleted:<span class="cov0" title="0">
                // delete addon from status if addon has been deleted
                s.Info(fmt.Sprintf("Addon %s is in deleted state", addonName))
                s.OCIManagedControlPlane.RemoveAddonStatus(addonName)
                break</span>
        default:<span class="cov8" title="1">
                // else delete the addon
                // delete addon is called disable addon with remove flag turned on
                _, err := s.ContainerEngineClient.DisableAddon(ctx, oke.DisableAddonRequest{
                        ClusterId:             okeCluster.Id,
                        AddonName:             common.String(addonName),
                        IsRemoveExistingAddOn: common.Bool(true),
                })
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func getAddonConfigurations(configurations []infrastructurev1beta2.AddonConfiguration) []oke.AddonConfiguration <span class="cov8" title="1">{
        if len(configurations) == 0 </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">config := make([]oke.AddonConfiguration, len(configurations))
        for i, c := range configurations </span><span class="cov8" title="1">{
                config[i] = oke.AddonConfiguration{
                        Key:   c.Key,
                        Value: c.Value,
                }
        }</span>
        <span class="cov8" title="1">return config</span>
}

func getActualAddonConfigurations(addonConfigurations []oke.AddonConfiguration) []infrastructurev1beta2.AddonConfiguration <span class="cov8" title="1">{
        if len(addonConfigurations) == 0 </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov0" title="0">config := make([]infrastructurev1beta2.AddonConfiguration, len(addonConfigurations))
        for i, c := range addonConfigurations </span><span class="cov0" title="0">{
                config[i] = infrastructurev1beta2.AddonConfiguration{
                        Key:   c.Key,
                        Value: c.Value,
                }
        }</span>
        <span class="cov0" title="0">return config</span>
}

func getAddon(addons []infrastructurev1beta2.Addon, name string) *infrastructurev1beta2.Addon <span class="cov8" title="1">{
        for i, addon := range addons </span><span class="cov8" title="1">{
                if *addon.Name == name </span><span class="cov8" title="1">{
                        return &amp;addons[i]
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func getKubeConfigUserName(clusterName string, isUser bool) string <span class="cov8" title="1">{
        if isUser </span><span class="cov0" title="0">{
                return fmt.Sprintf("%s-user", clusterName)
        }</span>

        <span class="cov8" title="1">return fmt.Sprintf("%s-capi-admin", clusterName)</span>
}
</pre>
		
		<pre class="file" id="file48" style="display: none">/*
 Copyright (c) 2022 Oracle and/or its affiliates.

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

      https://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
*/

package scope

import (
        "context"
        "encoding/json"
        "fmt"
        "reflect"
        "sort"
        "strconv"
        "strings"

        "github.com/go-logr/logr"
        infrastructurev1beta2 "github.com/oracle/cluster-api-provider-oci/api/v1beta2"
        "github.com/oracle/cluster-api-provider-oci/cloud/ociutil"
        "github.com/oracle/cluster-api-provider-oci/cloud/ociutil/ptr"
        "github.com/oracle/cluster-api-provider-oci/cloud/services/computemanagement"
        "github.com/oracle/cluster-api-provider-oci/cloud/services/containerengine"
        expinfra1 "github.com/oracle/cluster-api-provider-oci/exp/api/v1beta2"
        infrav2exp "github.com/oracle/cluster-api-provider-oci/exp/api/v1beta2"
        "github.com/oracle/oci-go-sdk/v65/common"
        oke "github.com/oracle/oci-go-sdk/v65/containerengine"
        "github.com/pkg/errors"
        "k8s.io/klog/v2/klogr"
        clusterv1 "sigs.k8s.io/cluster-api/api/core/v1beta1"
        expclusterv1 "sigs.k8s.io/cluster-api/api/core/v1beta1"
        "sigs.k8s.io/cluster-api/util/annotations"
        "sigs.k8s.io/cluster-api/util/patch"
        "sigs.k8s.io/controller-runtime/pkg/client"
)

const (
        OCIManagedMachinePoolKind = "OCIManagedMachinePool"
)

// ManagedMachinePoolScopeParams defines the params need to create a new ManagedMachinePoolScope
type ManagedMachinePoolScopeParams struct {
        Logger                  *logr.Logger
        Cluster                 *clusterv1.Cluster
        MachinePool             *expclusterv1.MachinePool
        Client                  client.Client
        ComputeManagementClient computemanagement.Client
        OCIManagedCluster       *infrastructurev1beta2.OCIManagedCluster
        OCIManagedControlPlane  *infrastructurev1beta2.OCIManagedControlPlane
        OCIManagedMachinePool   *expinfra1.OCIManagedMachinePool
        ContainerEngineClient   containerengine.Client
}

type ManagedMachinePoolScope struct {
        *logr.Logger
        Client                  client.Client
        patchHelper             *patch.Helper
        Cluster                 *clusterv1.Cluster
        MachinePool             *expclusterv1.MachinePool
        ComputeManagementClient computemanagement.Client
        OCIManagedCluster       *infrastructurev1beta2.OCIManagedCluster
        OCIManagedMachinePool   *expinfra1.OCIManagedMachinePool
        ContainerEngineClient   containerengine.Client
        OCIManagedControlPlane  *infrastructurev1beta2.OCIManagedControlPlane
}

// NewManagedMachinePoolScope creates a ManagedMachinePoolScope given the ManagedMachinePoolScopeParams
func NewManagedMachinePoolScope(params ManagedMachinePoolScopeParams) (*ManagedMachinePoolScope, error) <span class="cov8" title="1">{
        if params.MachinePool == nil </span><span class="cov0" title="0">{
                return nil, errors.New("failed to generate new scope from nil MachinePool")
        }</span>
        <span class="cov8" title="1">if params.OCIManagedCluster == nil </span><span class="cov0" title="0">{
                return nil, errors.New("failed to generate new scope from nil OCIManagedCluster")
        }</span>

        <span class="cov8" title="1">if params.Logger == nil </span><span class="cov8" title="1">{
                log := klogr.New()
                params.Logger = &amp;log
        }</span>
        <span class="cov8" title="1">helper, err := patch.NewHelper(params.OCIManagedMachinePool, params.Client)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "failed to init patch helper")
        }</span>
        <span class="cov8" title="1">params.OCIManagedMachinePool.Status.InfrastructureMachineKind = "OCIMachinePoolMachine"

        return &amp;ManagedMachinePoolScope{
                Logger:                  params.Logger,
                Client:                  params.Client,
                ComputeManagementClient: params.ComputeManagementClient,
                Cluster:                 params.Cluster,
                OCIManagedCluster:       params.OCIManagedCluster,
                patchHelper:             helper,
                MachinePool:             params.MachinePool,
                OCIManagedMachinePool:   params.OCIManagedMachinePool,
                ContainerEngineClient:   params.ContainerEngineClient,
                OCIManagedControlPlane:  params.OCIManagedControlPlane,
        }, nil</span>
}

// PatchObject persists the cluster configuration and status.
func (m *ManagedMachinePoolScope) PatchObject(ctx context.Context) error <span class="cov0" title="0">{
        return m.patchHelper.Patch(ctx, m.OCIManagedMachinePool)
}</span>

// Close closes the current scope persisting the cluster configuration and status.
func (m *ManagedMachinePoolScope) Close(ctx context.Context) error <span class="cov0" title="0">{
        return m.PatchObject(ctx)
}</span>

// SetFailureReason sets the OCIMachine status error reason.
func (m *ManagedMachinePoolScope) SetFailureReason(v string) <span class="cov0" title="0">{
        m.OCIManagedMachinePool.Status.FailureReason = &amp;v
}</span>

func (m *ManagedMachinePoolScope) SetReplicaCount(count int32) <span class="cov0" title="0">{
        m.OCIManagedMachinePool.Status.Replicas = count
}</span>

// GetWorkerMachineSubnet returns the WorkerRole core.Subnet id for the cluster
func (m *ManagedMachinePoolScope) GetWorkerMachineSubnet() *string <span class="cov0" title="0">{
        for _, subnet := range ptr.ToSubnetSlice(m.OCIManagedCluster.Spec.NetworkSpec.Vcn.Subnets) </span><span class="cov0" title="0">{
                if subnet.Role == infrastructurev1beta2.WorkerRole </span><span class="cov0" title="0">{
                        return subnet.ID
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// SetListandSetMachinePoolInstances retrieves a machine pools instances and sets them in the ProviderIDList
func (m *ManagedMachinePoolScope) SetListandSetMachinePoolInstances(ctx context.Context, nodePool *oke.NodePool) (int32, error) <span class="cov0" title="0">{
        providerIDList := make([]string, 0)
        for _, instance := range nodePool.Nodes </span><span class="cov0" title="0">{
                if instance.Id != nil &amp;&amp; instance.LifecycleState == oke.NodeLifecycleStateActive </span><span class="cov0" title="0">{
                        providerIDList = append(providerIDList, *instance.Id)
                }</span>
        }
        <span class="cov0" title="0">m.OCIManagedMachinePool.Spec.ProviderIDList = providerIDList
        return int32(len(providerIDList)), nil</span>
}

// IsResourceCreatedByClusterAPI determines if the instance was created by the cluster using the
// tags created at instance launch.
func (m *ManagedMachinePoolScope) IsResourceCreatedByClusterAPI(resourceFreeFormTags map[string]string) bool <span class="cov0" title="0">{
        tagsAddedByClusterAPI := ociutil.BuildClusterTags(m.OCIManagedCluster.Spec.OCIResourceIdentifier)
        for k, v := range tagsAddedByClusterAPI </span><span class="cov0" title="0">{
                if resourceFreeFormTags[k] != v </span><span class="cov0" title="0">{
                        return false
                }</span>
        }
        <span class="cov0" title="0">return true</span>
}

// FindNodePool attempts to find the node pool by id if the id exists or by name. It checks to make sure
// the node pool was created by the cluster before returning the correct pool.
// nolint:nilnil
func (m *ManagedMachinePoolScope) FindNodePool(ctx context.Context) (*oke.NodePool, error) <span class="cov0" title="0">{
        if m.OCIManagedMachinePool.Spec.ID != nil </span><span class="cov0" title="0">{
                response, err := m.ContainerEngineClient.GetNodePool(ctx, oke.GetNodePoolRequest{
                        NodePoolId: m.OCIManagedMachinePool.Spec.ID,
                })
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">if m.IsResourceCreatedByClusterAPI(response.FreeformTags) </span><span class="cov0" title="0">{
                        return &amp;response.NodePool, nil
                }</span> else<span class="cov0" title="0"> {
                        return nil, errors.New("cluster api tags have been modified out of context")
                }</span>
        }

        <span class="cov0" title="0">var page *string
        for </span><span class="cov0" title="0">{
                reqList := oke.ListNodePoolsRequest{
                        CompartmentId: common.String(m.OCIManagedCluster.Spec.CompartmentId),
                        ClusterId:     m.OCIManagedControlPlane.Spec.ID,
                        Name:          common.String(m.getNodePoolName()),
                        Page:          page,
                }

                response, err := m.ContainerEngineClient.ListNodePools(ctx, reqList)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">for _, i := range response.Items </span><span class="cov0" title="0">{
                        if m.IsResourceCreatedByClusterAPI(i.FreeformTags) </span><span class="cov0" title="0">{
                                return m.getOKENodePoolFromOCID(ctx, i.Id)
                        }</span>
                }
                <span class="cov0" title="0">if response.OpcNextPage == nil </span><span class="cov0" title="0">{
                        break</span>
                } else<span class="cov0" title="0"> {
                        page = response.OpcNextPage
                }</span>
        }
        <span class="cov0" title="0">return nil, nil</span>
}

func (m *ManagedMachinePoolScope) getNodePoolName() string <span class="cov8" title="1">{
        return m.OCIManagedMachinePool.GetName()
}</span>

// CreateNodePool attempts to create a node pool
func (m *ManagedMachinePoolScope) CreateNodePool(ctx context.Context) (*oke.NodePool, error) <span class="cov8" title="1">{
        m.Info("Creating Node Pool")

        machinePool := m.OCIManagedMachinePool
        if machinePool.Spec.NodePoolNodeConfig == nil </span><span class="cov8" title="1">{
                m.OCIManagedMachinePool.Spec.NodePoolNodeConfig = &amp;expinfra1.NodePoolNodeConfig{}
        }</span>
        <span class="cov8" title="1">placementConfigs := m.OCIManagedMachinePool.Spec.NodePoolNodeConfig.PlacementConfigs
        if len(placementConfigs) == 0 </span><span class="cov8" title="1">{
                placementConfigs = make([]expinfra1.PlacementConfig, 0)
                workerSubnets := m.getWorkerMachineSubnets()
                if len(workerSubnets) == 0 </span><span class="cov8" title="1">{
                        return nil, errors.New("worker subnets are not specified")
                }</span>
                <span class="cov8" title="1">adMap := m.OCIManagedCluster.Spec.AvailabilityDomains
                for k, v := range adMap </span><span class="cov8" title="1">{
                        placementConfigs = append(placementConfigs, expinfra1.PlacementConfig{
                                AvailabilityDomain: common.String(k),
                                FaultDomains:       v.FaultDomains,
                                SubnetName:         common.String(workerSubnets[0]),
                        })
                }</span>
                <span class="cov8" title="1">m.OCIManagedMachinePool.Spec.NodePoolNodeConfig.PlacementConfigs = placementConfigs</span>
        }
        <span class="cov8" title="1">if len(m.OCIManagedMachinePool.Spec.NodePoolNodeConfig.NsgNames) == 0 </span><span class="cov8" title="1">{
                m.OCIManagedMachinePool.Spec.NodePoolNodeConfig.NsgNames = m.getWorkerMachineNSGList()
        }</span>
        <span class="cov8" title="1">placementConfig, err := m.buildPlacementConfig(placementConfigs)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">nodeConfigDetails := oke.CreateNodePoolNodeConfigDetails{
                Size:                           common.Int(int(*m.MachinePool.Spec.Replicas)),
                NsgIds:                         m.getWorkerMachineNSGs(),
                PlacementConfigs:               placementConfig,
                IsPvEncryptionInTransitEnabled: m.OCIManagedMachinePool.Spec.NodePoolNodeConfig.IsPvEncryptionInTransitEnabled,
                FreeformTags:                   m.getFreeFormTags(),
                DefinedTags:                    m.getDefinedTags(),
                KmsKeyId:                       m.OCIManagedMachinePool.Spec.NodePoolNodeConfig.KmsKeyId,
        }
        nodeShapeConfig := oke.CreateNodeShapeConfigDetails{}
        if machinePool.Spec.NodeShapeConfig != nil </span><span class="cov8" title="1">{
                ocpuString := m.OCIManagedMachinePool.Spec.NodeShapeConfig.Ocpus
                if ocpuString != nil </span><span class="cov8" title="1">{
                        ocpus, err := strconv.ParseFloat(*ocpuString, 32)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, errors.New(fmt.Sprintf("ocpus provided %s is not a valid floating point",
                                        *ocpuString))
                        }</span>
                        <span class="cov8" title="1">nodeShapeConfig.Ocpus = common.Float32(float32(ocpus))</span>
                }

                <span class="cov8" title="1">memoryInGBsString := m.OCIManagedMachinePool.Spec.NodeShapeConfig.MemoryInGBs
                if memoryInGBsString != nil </span><span class="cov8" title="1">{
                        memoryInGBs, err := strconv.ParseFloat(*memoryInGBsString, 32)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, errors.New(fmt.Sprintf("memoryInGBs provided %s is not a valid floating point",
                                        *memoryInGBsString))
                        }</span>
                        <span class="cov8" title="1">nodeShapeConfig.MemoryInGBs = common.Float32(float32(memoryInGBs))</span>
                }
        }
        <span class="cov8" title="1">err = m.setNodepoolImageId(ctx)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">sourceDetails := oke.NodeSourceViaImageDetails{
                ImageId:             machinePool.Spec.NodeSourceViaImage.ImageId,
                BootVolumeSizeInGBs: machinePool.Spec.NodeSourceViaImage.BootVolumeSizeInGBs,
        }
        podNetworkOptions := machinePool.Spec.NodePoolNodeConfig.NodePoolPodNetworkOptionDetails
        if podNetworkOptions != nil </span><span class="cov8" title="1">{
                if podNetworkOptions.CniType == infrastructurev1beta2.VCNNativeCNI </span><span class="cov8" title="1">{
                        npnDetails := oke.OciVcnIpNativeNodePoolPodNetworkOptionDetails{
                                PodSubnetIds: m.getPodSubnets(podNetworkOptions.VcnIpNativePodNetworkOptions.SubnetNames),
                                PodNsgIds:    m.getPodNSGs(podNetworkOptions.VcnIpNativePodNetworkOptions.NSGNames),
                        }
                        if podNetworkOptions.VcnIpNativePodNetworkOptions.MaxPodsPerNode != nil </span><span class="cov8" title="1">{
                                npnDetails.MaxPodsPerNode = podNetworkOptions.VcnIpNativePodNetworkOptions.MaxPodsPerNode
                        }</span>
                        <span class="cov8" title="1">nodeConfigDetails.NodePoolPodNetworkOptionDetails = npnDetails</span>
                } else<span class="cov0" title="0"> if podNetworkOptions.CniType == infrastructurev1beta2.FlannelCNI </span><span class="cov0" title="0">{
                        nodeConfigDetails.NodePoolPodNetworkOptionDetails = oke.FlannelOverlayNodePoolPodNetworkOptionDetails{}
                }</span>
        }
        <span class="cov8" title="1">nodePoolDetails := oke.CreateNodePoolDetails{
                CompartmentId:     common.String(m.OCIManagedCluster.Spec.CompartmentId),
                ClusterId:         m.OCIManagedControlPlane.Spec.ID,
                Name:              common.String(m.getNodePoolName()),
                KubernetesVersion: m.OCIManagedMachinePool.Spec.Version,
                NodeShape:         common.String(m.OCIManagedMachinePool.Spec.NodeShape),
                NodeShapeConfig:   &amp;nodeShapeConfig,
                NodeSourceDetails: &amp;sourceDetails,
                FreeformTags:      m.getFreeFormTags(),
                DefinedTags:       m.getDefinedTags(),
                SshPublicKey:      common.String(m.OCIManagedMachinePool.Spec.SshPublicKey),
                NodeConfigDetails: &amp;nodeConfigDetails,
                NodeMetadata:      m.OCIManagedMachinePool.Spec.NodeMetadata,
        }
        if m.OCIManagedMachinePool.Spec.NodeEvictionNodePoolSettings != nil </span><span class="cov8" title="1">{
                nodePoolDetails.NodeEvictionNodePoolSettings = &amp;oke.NodeEvictionNodePoolSettings{
                        EvictionGraceDuration:           m.OCIManagedMachinePool.Spec.NodeEvictionNodePoolSettings.EvictionGraceDuration,
                        IsForceDeleteAfterGraceDuration: m.OCIManagedMachinePool.Spec.NodeEvictionNodePoolSettings.IsForceDeleteAfterGraceDuration,
                }
        }</span>
        <span class="cov8" title="1">recycleConfig := m.OCIManagedMachinePool.Spec.NodePoolCyclingDetails
        if recycleConfig != nil </span><span class="cov0" title="0">{
                nodePoolDetails.NodePoolCyclingDetails = &amp;oke.NodePoolCyclingDetails{
                        IsNodeCyclingEnabled: recycleConfig.IsNodeCyclingEnabled,
                        MaximumSurge:         recycleConfig.MaximumSurge,
                        MaximumUnavailable:   recycleConfig.MaximumUnavailable,
                }
        }</span>
        <span class="cov8" title="1">nodePoolDetails.InitialNodeLabels = m.getInitialNodeKeyValuePairs()

        req := oke.CreateNodePoolRequest{
                CreateNodePoolDetails: nodePoolDetails,
        }
        response, err := m.ContainerEngineClient.CreateNodePool(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrapf(err, "failed to create OCIManagedMachinePool")
        }</span>

        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">wrResponse, err := m.ContainerEngineClient.GetWorkRequest(ctx, oke.GetWorkRequestRequest{
                WorkRequestId: response.OpcWorkRequestId,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">resources := wrResponse.Resources
        var nodePoolId *string
        for _, resource := range resources </span><span class="cov8" title="1">{
                if ptr.ToString(resource.EntityType) == "nodepool" </span><span class="cov8" title="1">{
                        nodePoolId = resource.Identifier
                }</span>
        }
        <span class="cov8" title="1">m.Logger.Info("Work request affected resources", "resources", resources)
        if nodePoolId == nil </span><span class="cov0" title="0">{
                return nil, errors.New(fmt.Sprintf("node pool ws not created with the request, please create a "+
                        "support ticket with opc-request-id %s", *wrResponse.OpcRequestId))
        }</span>
        <span class="cov8" title="1">m.OCIManagedMachinePool.Spec.ID = nodePoolId
        m.Info("Created Node Pool", "id", nodePoolId)
        return m.getOKENodePoolFromOCID(ctx, nodePoolId)</span>
}

func (m *ManagedMachinePoolScope) setNodepoolImageId(ctx context.Context) error <span class="cov8" title="1">{
        imageId := m.OCIManagedMachinePool.Spec.NodeSourceViaImage.ImageId
        if imageId != nil &amp;&amp; *imageId != "" </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">response, err := m.ContainerEngineClient.GetNodePoolOptions(ctx, oke.GetNodePoolOptionsRequest{
                NodePoolOptionId: common.String("all"),
                CompartmentId:    common.String(m.OCIManagedCluster.Spec.CompartmentId),
        })
        if err != nil </span><span class="cov0" title="0">{
                m.Logger.Error(err, "Could not lookup node pool options")
                return err
        }</span>
        // version in the capoci spec starts with v, wheres as in the node pool options API in OKE
        // the image name does not contain . For example
        //       {
        //        "image-id": "ocid1.image.oc1.iad.aaaaaaaafp7ysdbfl2bg67s4jzbpewxo3k772baixa3vwzecwogl474qecza",
        //        "source-name": "Oracle-Linux-8.6-aarch64-2022.12.15-0-OKE-1.25.4-543",
        //        "source-type": "IMAGE"
        //      },
        //      {
        //        "image-id": "ocid1.image.oc1.iad.aaaaaaaauwwokidwf5nfi34ucbvgnjsni3klnfmu6pz73ctdohb2byiw6ztq",
        //        "source-name": "Oracle-Linux-8.6-2022.12.15-0-OKE-1.23.4-543",
        //        "source-type": "IMAGE"
        //      },
        // we will only default to non gpu image

        // proper validation exists in webhook, this is to be fail-safe
        <span class="cov8" title="1">specVersion := m.OCIManagedMachinePool.Spec.Version
        if specVersion == nil || len(*specVersion) &lt; 1 </span><span class="cov0" title="0">{
                return errors.New(fmt.Sprintf("invalid/nil kubernetes version is set in OCIManagedMachinePool Spec"))
        }</span>
        <span class="cov8" title="1">k8sVersion := (*specVersion)[1:]
        shape := m.OCIManagedMachinePool.Spec.NodeShape
        isArmShape := strings.Contains(shape, "A1")
        for _, source := range response.Sources </span><span class="cov8" title="1">{
                image, ok := source.(oke.NodeSourceViaImageOption)
                if ok </span><span class="cov8" title="1">{
                        sourceName := *image.SourceName
                        if isValidImage(sourceName) </span><span class="cov8" title="1">{
                                // if source is an arm source and expectation is not an arm image, ignore
                                if strings.Contains(sourceName, "aarch64") &amp;&amp; !isArmShape </span><span class="cov8" title="1">{
                                        continue</span>
                                }
                                <span class="cov8" title="1">if strings.Contains(sourceName, k8sVersion) </span><span class="cov8" title="1">{
                                        m.Info("Image being used", "Name", sourceName, "OCID", *image.ImageId)
                                        m.OCIManagedMachinePool.Spec.NodeSourceViaImage.ImageId = image.ImageId
                                        return nil
                                }</span>
                        }
                }
        }
        <span class="cov8" title="1">sourceJson, err := json.Marshal(response.Sources)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">err = errors.New(fmt.Sprintf("could not lookup nodepool image id from nodepool options"))
        m.Logger.Error(err, "Could not lookup an image corresponding to the kubernetes version from OKE nodepool options",
                "oke-node-pool-image-sources", sourceJson)
        return err</span>
}

func isValidImage(sourceName string) bool <span class="cov8" title="1">{
        // invalidImageSources is the array of names of source images that should be ignored to be considered as defaults
        // for node pool images
        invalidImageSources := []string{"GPU"}
        for _, invalidImageSource := range invalidImageSources </span><span class="cov8" title="1">{
                if strings.Contains(sourceName, invalidImageSource) </span><span class="cov8" title="1">{
                        return false
                }</span>
        }
        <span class="cov8" title="1">return true</span>
}

func (m *ManagedMachinePoolScope) getOKENodePoolFromOCID(ctx context.Context, nodePoolId *string) (*oke.NodePool, error) <span class="cov8" title="1">{
        req := oke.GetNodePoolRequest{NodePoolId: nodePoolId}

        // Send the request using the service client
        resp, err := m.ContainerEngineClient.GetNodePool(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return &amp;resp.NodePool, nil</span>
}

// DeleteNodePool terminates a nodepool
func (m *ManagedMachinePoolScope) DeleteNodePool(ctx context.Context, nodePool *oke.NodePool) error <span class="cov0" title="0">{
        m.Info("Terminating node pool", "id", nodePool.Id)
        req := oke.DeleteNodePoolRequest{NodePoolId: nodePool.Id}
        if _, err := m.ContainerEngineClient.DeleteNodePool(ctx, req); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (m *ManagedMachinePoolScope) getDefinedTags() map[string]map[string]interface{} <span class="cov8" title="1">{
        tags := m.OCIManagedCluster.Spec.DefinedTags
        if tags == nil </span><span class="cov0" title="0">{
                return make(map[string]map[string]interface{})
        }</span>
        <span class="cov8" title="1">definedTags := make(map[string]map[string]interface{})
        for ns, mapNs := range tags </span><span class="cov8" title="1">{
                mapValues := make(map[string]interface{})
                for k, v := range mapNs </span><span class="cov8" title="1">{
                        mapValues[k] = v
                }</span>
                <span class="cov8" title="1">definedTags[ns] = mapValues</span>
        }
        <span class="cov8" title="1">return definedTags</span>
}

func (m *ManagedMachinePoolScope) getFreeFormTags() map[string]string <span class="cov8" title="1">{
        tags := ociutil.BuildClusterTags(m.OCIManagedCluster.Spec.OCIResourceIdentifier)
        if m.OCIManagedCluster.Spec.FreeformTags != nil </span><span class="cov0" title="0">{
                for k, v := range m.OCIManagedCluster.Spec.FreeformTags </span><span class="cov0" title="0">{
                        tags[k] = v
                }</span>
        }

        <span class="cov8" title="1">return tags</span>
}

func (m *ManagedMachinePoolScope) getWorkerMachineSubnets() []string <span class="cov8" title="1">{
        subnetList := make([]string, 0)
        for _, subnet := range ptr.ToSubnetSlice(m.OCIManagedCluster.Spec.NetworkSpec.Vcn.Subnets) </span><span class="cov8" title="1">{
                if subnet.Role == infrastructurev1beta2.WorkerRole </span><span class="cov8" title="1">{
                        subnetList = append(subnetList, subnet.Name)
                }</span>
        }
        <span class="cov8" title="1">return subnetList</span>
}

func (m *ManagedMachinePoolScope) getWorkerMachineNSGs() []string <span class="cov8" title="1">{
        nsgList := make([]string, 0)
        specNsgNames := m.OCIManagedMachinePool.Spec.NodePoolNodeConfig.NsgNames
        if len(specNsgNames) &gt; 0 </span><span class="cov8" title="1">{
                for _, nsgName := range specNsgNames </span><span class="cov8" title="1">{
                        for _, nsg := range ptr.ToNSGSlice(m.OCIManagedCluster.Spec.NetworkSpec.Vcn.NetworkSecurityGroup.List) </span><span class="cov8" title="1">{
                                if nsg.ID != nil &amp;&amp; nsg.Name == nsgName </span><span class="cov8" title="1">{
                                        nsgList = append(nsgList, *nsg.ID)
                                }</span>
                        }
                }
        } else<span class="cov0" title="0"> {
                for _, nsg := range ptr.ToNSGSlice(m.OCIManagedCluster.Spec.NetworkSpec.Vcn.NetworkSecurityGroup.List) </span><span class="cov0" title="0">{
                        if nsg.ID != nil &amp;&amp; nsg.Role == infrastructurev1beta2.WorkerRole </span><span class="cov0" title="0">{
                                nsgList = append(nsgList, *nsg.ID)
                        }</span>
                }
        }
        <span class="cov8" title="1">return nsgList</span>
}

func (m *ManagedMachinePoolScope) getWorkerMachineNSGList() []string <span class="cov8" title="1">{
        nsgList := make([]string, 0)
        for _, nsg := range ptr.ToNSGSlice(m.OCIManagedCluster.Spec.NetworkSpec.Vcn.NetworkSecurityGroup.List) </span><span class="cov8" title="1">{
                if nsg.Role == infrastructurev1beta2.WorkerRole </span><span class="cov8" title="1">{
                        nsgList = append(nsgList, nsg.Name)
                }</span>
        }
        <span class="cov8" title="1">return nsgList</span>
}

func (m *ManagedMachinePoolScope) getPodSubnets(subnets []string) []string <span class="cov8" title="1">{
        subnetList := make([]string, 0)
        if len(subnets) &gt; 0 </span><span class="cov8" title="1">{
                for _, subnetName := range subnets </span><span class="cov8" title="1">{
                        for _, subnet := range ptr.ToSubnetSlice(m.OCIManagedCluster.Spec.NetworkSpec.Vcn.Subnets) </span><span class="cov8" title="1">{
                                if subnet.Name == subnetName </span><span class="cov8" title="1">{
                                        subnetList = append(subnetList, ptr.ToString(subnet.ID))
                                }</span>
                        }
                }
        }
        <span class="cov8" title="1">return subnetList</span>
}

func (m *ManagedMachinePoolScope) getPodNSGs(nsgs []string) []string <span class="cov8" title="1">{
        nsgList := make([]string, 0)
        if len(nsgs) &gt; 0 </span><span class="cov8" title="1">{
                for _, nsgName := range nsgs </span><span class="cov8" title="1">{
                        for _, nsg := range ptr.ToNSGSlice(m.OCIManagedCluster.Spec.NetworkSpec.Vcn.NetworkSecurityGroup.List) </span><span class="cov8" title="1">{
                                if nsg.ID != nil &amp;&amp; nsg.Name == nsgName </span><span class="cov8" title="1">{
                                        nsgList = append(nsgList, *nsg.ID)
                                }</span>
                        }
                }
        }
        <span class="cov8" title="1">return nsgList</span>
}

func (m *ManagedMachinePoolScope) buildPlacementConfig(configs []expinfra1.PlacementConfig) ([]oke.NodePoolPlacementConfigDetails, error) <span class="cov8" title="1">{
        placementConfigs := make([]oke.NodePoolPlacementConfigDetails, 0)
        for _, config := range configs </span><span class="cov8" title="1">{
                subnetId := m.getWorkerMachineSubnet(config.SubnetName)
                if subnetId == nil </span><span class="cov8" title="1">{
                        return nil, errors.New(fmt.Sprintf("worker subnet %s is not present in placementConfigs spec",
                                ptr.ToString(config.SubnetName)))
                }</span>
                <span class="cov8" title="1">placementConfigs = append(placementConfigs, oke.NodePoolPlacementConfigDetails{
                        AvailabilityDomain:    config.AvailabilityDomain,
                        SubnetId:              subnetId,
                        FaultDomains:          config.FaultDomains,
                        CapacityReservationId: config.CapacityReservationId,
                })</span>
        }
        <span class="cov8" title="1">return placementConfigs, nil</span>
}

func (m *ManagedMachinePoolScope) getInitialNodeKeyValuePairs() []oke.KeyValue <span class="cov8" title="1">{
        keyValues := make([]oke.KeyValue, 0)
        for _, kv := range m.OCIManagedMachinePool.Spec.InitialNodeLabels </span><span class="cov8" title="1">{
                keyValues = append(keyValues, oke.KeyValue{
                        Key:   kv.Key,
                        Value: kv.Value,
                })
        }</span>
        <span class="cov8" title="1">return keyValues</span>
}

func (m *ManagedMachinePoolScope) getWorkerMachineSubnet(name *string) *string <span class="cov8" title="1">{
        for _, subnet := range ptr.ToSubnetSlice(m.OCIManagedCluster.Spec.NetworkSpec.Vcn.Subnets) </span><span class="cov8" title="1">{
                if subnet.ID != nil &amp;&amp; subnet.Name == ptr.ToString(name) </span><span class="cov8" title="1">{
                        return subnet.ID
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// UpdateNodePool updates a node pool, if needed, based on updated spec
func (m *ManagedMachinePoolScope) UpdateNodePool(ctx context.Context, pool *oke.NodePool) (bool, error) <span class="cov8" title="1">{
        spec := m.OCIManagedMachinePool.Spec.DeepCopy()
        setMachinePoolSpecDefaults(spec)
        nodePoolSizeUpdateRequired := false
        // if replicas is not managed by cluster autoscaler and if the number of nodes in the spec is not equal to number set in the node pool
        // update the node pool
        if !annotations.ReplicasManagedByExternalAutoscaler(m.MachinePool) &amp;&amp; (*m.MachinePool.Spec.Replicas != int32(*pool.NodeConfigDetails.Size)) </span><span class="cov8" title="1">{
                nodePoolSizeUpdateRequired = true
        }</span>
        <span class="cov8" title="1">actual := m.getSpecFromAPIObject(pool)
        if !reflect.DeepEqual(spec, actual) ||
                m.getNodePoolName() != *pool.Name || nodePoolSizeUpdateRequired </span><span class="cov8" title="1">{
                m.Logger.Info("Updating node pool")
                // printing json specs will help debug problems when there are spurious/unwanted updates
                jsonSpec, err := json.Marshal(*spec)
                if err != nil </span><span class="cov0" title="0">{
                        return false, err
                }</span>
                <span class="cov8" title="1">jsonActual, err := json.Marshal(*actual)
                if err != nil </span><span class="cov0" title="0">{
                        return false, err
                }</span>
                <span class="cov8" title="1">m.Logger.Info("Node pool", "spec", jsonSpec, "actual", jsonActual)

                nodeConfigDetails := oke.UpdateNodePoolNodeConfigDetails{
                        NsgIds:                         m.getWorkerMachineNSGs(),
                        IsPvEncryptionInTransitEnabled: spec.NodePoolNodeConfig.IsPvEncryptionInTransitEnabled,
                        KmsKeyId:                       spec.NodePoolNodeConfig.KmsKeyId,
                }
                // send placement config only if there is an actual change in placement
                // placement config and recycle config cannot be sent at the same time, and most use cases will
                // be to update kubernetes version in which case, placement config is not required to be sent
                if !reflect.DeepEqual(spec.NodePoolNodeConfig.PlacementConfigs, actual.NodePoolNodeConfig.PlacementConfigs) </span><span class="cov8" title="1">{
                        placementConfig, err := m.buildPlacementConfig(spec.NodePoolNodeConfig.PlacementConfigs)
                        if err != nil </span><span class="cov0" title="0">{
                                return false, err
                        }</span>
                        <span class="cov8" title="1">nodeConfigDetails.PlacementConfigs = placementConfig</span>
                }
                <span class="cov8" title="1">if nodePoolSizeUpdateRequired </span><span class="cov8" title="1">{
                        nodeConfigDetails.Size = common.Int(int(*m.MachinePool.Spec.Replicas))
                }</span>
                <span class="cov8" title="1">nodeShapeConfig := oke.UpdateNodeShapeConfigDetails{}
                if spec.NodeShapeConfig != nil </span><span class="cov8" title="1">{
                        ocpuString := spec.NodeShapeConfig.Ocpus
                        if ocpuString != nil </span><span class="cov8" title="1">{
                                ocpus, err := strconv.ParseFloat(*ocpuString, 32)
                                if err != nil </span><span class="cov0" title="0">{
                                        return false, errors.New(fmt.Sprintf("ocpus provided %s is not a valid floating point",
                                                *ocpuString))
                                }</span>
                                <span class="cov8" title="1">nodeShapeConfig.Ocpus = common.Float32(float32(ocpus))</span>
                        }

                        <span class="cov8" title="1">memoryInGBsString := spec.NodeShapeConfig.MemoryInGBs
                        if memoryInGBsString != nil </span><span class="cov8" title="1">{
                                memoryInGBs, err := strconv.ParseFloat(*memoryInGBsString, 32)
                                if err != nil </span><span class="cov0" title="0">{
                                        return false, errors.New(fmt.Sprintf("memoryInGBs provided %s is not a valid floating point",
                                                *memoryInGBsString))
                                }</span>
                                <span class="cov8" title="1">nodeShapeConfig.MemoryInGBs = common.Float32(float32(memoryInGBs))</span>
                        }
                }
                <span class="cov8" title="1">err = m.setNodepoolImageId(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        return false, err
                }</span>
                <span class="cov8" title="1">sourceDetails := oke.NodeSourceViaImageDetails{
                        // use image id from machinepool spec itself as the copy will not have the image set in the
                        // setNodepoolImageId method above
                        ImageId:             m.OCIManagedMachinePool.Spec.NodeSourceViaImage.ImageId,
                        BootVolumeSizeInGBs: spec.NodeSourceViaImage.BootVolumeSizeInGBs,
                }

                podNetworkOptions := spec.NodePoolNodeConfig.NodePoolPodNetworkOptionDetails
                if podNetworkOptions != nil </span><span class="cov8" title="1">{
                        if podNetworkOptions.CniType == infrastructurev1beta2.VCNNativeCNI </span><span class="cov8" title="1">{
                                npnDetails := oke.OciVcnIpNativeNodePoolPodNetworkOptionDetails{
                                        PodSubnetIds: m.getPodSubnets(podNetworkOptions.VcnIpNativePodNetworkOptions.SubnetNames),
                                        PodNsgIds:    m.getPodNSGs(podNetworkOptions.VcnIpNativePodNetworkOptions.NSGNames),
                                }
                                if podNetworkOptions.VcnIpNativePodNetworkOptions.MaxPodsPerNode != nil </span><span class="cov8" title="1">{
                                        npnDetails.MaxPodsPerNode = podNetworkOptions.VcnIpNativePodNetworkOptions.MaxPodsPerNode
                                }</span>
                                <span class="cov8" title="1">nodeConfigDetails.NodePoolPodNetworkOptionDetails = npnDetails</span>
                        } else<span class="cov0" title="0"> if podNetworkOptions.CniType == infrastructurev1beta2.FlannelCNI </span><span class="cov0" title="0">{
                                nodeConfigDetails.NodePoolPodNetworkOptionDetails = oke.FlannelOverlayNodePoolPodNetworkOptionDetails{}
                        }</span>
                }
                <span class="cov8" title="1">nodePoolDetails := oke.UpdateNodePoolDetails{
                        Name:              common.String(m.getNodePoolName()),
                        KubernetesVersion: m.OCIManagedMachinePool.Spec.Version,
                        NodeShape:         common.String(m.OCIManagedMachinePool.Spec.NodeShape),
                        NodeShapeConfig:   &amp;nodeShapeConfig,
                        NodeSourceDetails: &amp;sourceDetails,
                        SshPublicKey:      common.String(m.OCIManagedMachinePool.Spec.SshPublicKey),
                        NodeConfigDetails: &amp;nodeConfigDetails,
                        NodeMetadata:      spec.NodeMetadata,
                }
                recycleConfig := spec.NodePoolCyclingDetails
                // cannot send recycle config and placement config together
                if recycleConfig != nil &amp;&amp; len(nodeConfigDetails.PlacementConfigs) == 0 </span><span class="cov8" title="1">{
                        nodePoolDetails.NodePoolCyclingDetails = &amp;oke.NodePoolCyclingDetails{
                                IsNodeCyclingEnabled: recycleConfig.IsNodeCyclingEnabled,
                                MaximumSurge:         recycleConfig.MaximumSurge,
                                MaximumUnavailable:   recycleConfig.MaximumUnavailable,
                        }
                }</span>
                <span class="cov8" title="1">if recycleConfig != nil &amp;&amp; len(nodeConfigDetails.PlacementConfigs) != 0 </span><span class="cov0" title="0">{
                        m.Logger.V(LogLevelWarn).Info("Placement configuration has been changed in the update, " +
                                "hence node pool recycling configuration will not be sent with the update request")
                }</span>
                <span class="cov8" title="1">if spec.NodeEvictionNodePoolSettings != nil </span><span class="cov8" title="1">{
                        nodePoolDetails.NodeEvictionNodePoolSettings = &amp;oke.NodeEvictionNodePoolSettings{
                                EvictionGraceDuration:           spec.NodeEvictionNodePoolSettings.EvictionGraceDuration,
                                IsForceDeleteAfterGraceDuration: spec.NodeEvictionNodePoolSettings.IsForceDeleteAfterGraceDuration,
                        }
                }</span>
                <span class="cov8" title="1">nodePoolDetails.InitialNodeLabels = m.getInitialNodeKeyValuePairs()
                req := oke.UpdateNodePoolRequest{
                        NodePoolId:            pool.Id,
                        UpdateNodePoolDetails: nodePoolDetails,
                }
                _, err = m.ContainerEngineClient.UpdateNodePool(ctx, req)
                if err != nil </span><span class="cov0" title="0">{
                        return false, errors.Wrapf(err, "failed to update Node Pool")
                }</span>

                <span class="cov8" title="1">m.Info("Updated node pool")
                return true, nil</span>
        } else<span class="cov8" title="1"> {
                m.Info("No reconciliation needed for node pool")
        }</span>
        <span class="cov8" title="1">return false, nil</span>
}

// setMachinePoolSpecDefaults sets the defaults in the spec as returned by OKE API. We need to set defaults here rather than webhook as
// there is a chance user will edit the cluster
func setMachinePoolSpecDefaults(spec *infrav2exp.OCIManagedMachinePoolSpec) <span class="cov8" title="1">{
        spec.ProviderIDList = nil
        spec.ProviderID = nil

        if spec.NodePoolNodeConfig != nil </span><span class="cov8" title="1">{
                if spec.NodePoolNodeConfig.PlacementConfigs != nil </span><span class="cov8" title="1">{
                        configs := spec.NodePoolNodeConfig.PlacementConfigs
                        sort.Slice(configs, func(i, j int) bool </span><span class="cov0" title="0">{
                                return *configs[i].AvailabilityDomain &lt; *configs[j].AvailabilityDomain
                        }</span>)
                }
        }
        <span class="cov8" title="1">podNetworkOptions := spec.NodePoolNodeConfig.NodePoolPodNetworkOptionDetails
        if podNetworkOptions != nil </span><span class="cov8" title="1">{
                if podNetworkOptions.CniType == infrastructurev1beta2.VCNNativeCNI </span><span class="cov8" title="1">{
                        // 31 is the default max pods per node returned by OKE API
                        spec.NodePoolNodeConfig.NodePoolPodNetworkOptionDetails.VcnIpNativePodNetworkOptions.MaxPodsPerNode = common.Int(31)
                }</span>
        }
}

func (m *ManagedMachinePoolScope) getSpecFromAPIObject(pool *oke.NodePool) *expinfra1.OCIManagedMachinePoolSpec <span class="cov8" title="1">{
        nodePoolNodeConfig := expinfra1.NodePoolNodeConfig{}
        actualNodeConfigDetails := pool.NodeConfigDetails
        if actualNodeConfigDetails != nil </span><span class="cov8" title="1">{
                nodePoolNodeConfig.IsPvEncryptionInTransitEnabled = actualNodeConfigDetails.IsPvEncryptionInTransitEnabled
                nodePoolNodeConfig.KmsKeyId = actualNodeConfigDetails.KmsKeyId
                nodePoolNodeConfig.NsgNames = GetNsgNamesFromId(actualNodeConfigDetails.NsgIds, m.OCIManagedCluster.Spec.NetworkSpec.Vcn.NetworkSecurityGroup.List)
                configs := m.buildPlacementConfigFromActual(actualNodeConfigDetails.PlacementConfigs)
                sort.Slice(configs, func(i, j int) bool </span><span class="cov0" title="0">{
                        return *configs[i].AvailabilityDomain &lt; *configs[j].AvailabilityDomain
                }</span>)
                <span class="cov8" title="1">nodePoolNodeConfig.PlacementConfigs = configs
                podDetails, ok := actualNodeConfigDetails.NodePoolPodNetworkOptionDetails.(oke.OciVcnIpNativeNodePoolPodNetworkOptionDetails)
                if ok </span><span class="cov8" title="1">{
                        nodePoolNodeConfig.NodePoolPodNetworkOptionDetails = &amp;expinfra1.NodePoolPodNetworkOptionDetails{
                                CniType: infrastructurev1beta2.VCNNativeCNI,
                                VcnIpNativePodNetworkOptions: expinfra1.VcnIpNativePodNetworkOptions{
                                        MaxPodsPerNode: podDetails.MaxPodsPerNode,
                                        NSGNames:       GetNsgNamesFromId(podDetails.PodNsgIds, m.OCIManagedCluster.Spec.NetworkSpec.Vcn.NetworkSecurityGroup.List),
                                        SubnetNames:    GetSubnetNamesFromId(podDetails.PodSubnetIds, m.OCIManagedCluster.Spec.NetworkSpec.Vcn.Subnets),
                                },
                        }
                }</span> else<span class="cov0" title="0"> {
                        nodePoolNodeConfig.NodePoolPodNetworkOptionDetails = &amp;expinfra1.NodePoolPodNetworkOptionDetails{
                                CniType: infrastructurev1beta2.FlannelCNI,
                        }
                }</span>
        }
        <span class="cov8" title="1">spec := expinfra1.OCIManagedMachinePoolSpec{
                ID:                 pool.Id,
                NodePoolNodeConfig: &amp;nodePoolNodeConfig,
                InitialNodeLabels:  getInitialNodeLabels(pool.InitialNodeLabels),
                NodeShape:          *pool.NodeShape,
                NodeMetadata:       pool.NodeMetadata,
                Version:            pool.KubernetesVersion,
        }
        if pool.NodeEvictionNodePoolSettings != nil </span><span class="cov8" title="1">{
                spec.NodeEvictionNodePoolSettings = &amp;expinfra1.NodeEvictionNodePoolSettings{
                        EvictionGraceDuration:           pool.NodeEvictionNodePoolSettings.EvictionGraceDuration,
                        IsForceDeleteAfterGraceDuration: pool.NodeEvictionNodePoolSettings.IsForceDeleteAfterGraceDuration,
                }
        }</span>
        <span class="cov8" title="1">sourceDetails, ok := pool.NodeSourceDetails.(oke.NodeSourceViaImageDetails)
        if ok </span><span class="cov8" title="1">{
                spec.NodeSourceViaImage = &amp;expinfra1.NodeSourceViaImage{
                        ImageId:             sourceDetails.ImageId,
                        BootVolumeSizeInGBs: sourceDetails.BootVolumeSizeInGBs,
                }
        }</span>
        <span class="cov8" title="1">if pool.SshPublicKey != nil </span><span class="cov8" title="1">{
                spec.SshPublicKey = *pool.SshPublicKey
        }</span>
        <span class="cov8" title="1">if pool.NodeShapeConfig != nil </span><span class="cov8" title="1">{
                nodeShapeConfig := expinfra1.NodeShapeConfig{}
                if pool.NodeShapeConfig.MemoryInGBs != nil </span><span class="cov8" title="1">{
                        mem := strconv.FormatFloat(float64(*pool.NodeShapeConfig.MemoryInGBs), 'f', -1, 32)
                        nodeShapeConfig.MemoryInGBs = &amp;mem
                }</span>
                <span class="cov8" title="1">if pool.NodeShapeConfig.Ocpus != nil </span><span class="cov8" title="1">{
                        ocpu := strconv.FormatFloat(float64(*pool.NodeShapeConfig.Ocpus), 'f', -1, 32)
                        nodeShapeConfig.Ocpus = &amp;ocpu
                }</span>
                <span class="cov8" title="1">spec.NodeShapeConfig = &amp;nodeShapeConfig</span>
        }
        <span class="cov8" title="1">if pool.NodePoolCyclingDetails != nil </span><span class="cov0" title="0">{
                cyclingDetails := pool.NodePoolCyclingDetails
                spec.NodePoolCyclingDetails = &amp;expinfra1.NodePoolCyclingDetails{
                        IsNodeCyclingEnabled: cyclingDetails.IsNodeCyclingEnabled,
                        MaximumSurge:         cyclingDetails.MaximumSurge,
                        MaximumUnavailable:   cyclingDetails.MaximumUnavailable,
                }
        }</span>
        <span class="cov8" title="1">return &amp;spec</span>
}

func getInitialNodeLabels(labels []oke.KeyValue) []expinfra1.KeyValue <span class="cov8" title="1">{
        if len(labels) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">kv := make([]expinfra1.KeyValue, 0)
        for _, l := range labels </span><span class="cov8" title="1">{
                kv = append(kv, expinfra1.KeyValue{
                        Key:   l.Key,
                        Value: l.Value,
                })
        }</span>
        <span class="cov8" title="1">return kv</span>
}

func (m *ManagedMachinePoolScope) buildPlacementConfigFromActual(actualConfigs []oke.NodePoolPlacementConfigDetails) []expinfra1.PlacementConfig <span class="cov8" title="1">{
        configs := make([]expinfra1.PlacementConfig, 0)
        for _, config := range actualConfigs </span><span class="cov8" title="1">{
                configs = append(configs, expinfra1.PlacementConfig{
                        AvailabilityDomain:    config.AvailabilityDomain,
                        FaultDomains:          config.FaultDomains,
                        CapacityReservationId: config.CapacityReservationId,
                        SubnetName:            common.String(GetSubnetNameFromId(config.SubnetId, m.OCIManagedCluster.Spec.NetworkSpec.Vcn.Subnets)),
                })
        }</span>
        <span class="cov8" title="1">return configs</span>
}
</pre>
		
		<pre class="file" id="file49" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: cluster_client.go

// Package mock_scope is a generated GoMock package.
package mock_scope

import (
        context "context"
        reflect "reflect"

        gomock "github.com/golang/mock/gomock"
        scope "github.com/oracle/cluster-api-provider-oci/cloud/scope"
)

// MockClusterScopeClient is a mock of ClusterScopeClient interface.
type MockClusterScopeClient struct {
        ctrl     *gomock.Controller
        recorder *MockClusterScopeClientMockRecorder
}

// MockClusterScopeClientMockRecorder is the mock recorder for MockClusterScopeClient.
type MockClusterScopeClientMockRecorder struct {
        mock *MockClusterScopeClient
}

// NewMockClusterScopeClient creates a new mock instance.
func NewMockClusterScopeClient(ctrl *gomock.Controller) *MockClusterScopeClient <span class="cov0" title="0">{
        mock := &amp;MockClusterScopeClient{ctrl: ctrl}
        mock.recorder = &amp;MockClusterScopeClientMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockClusterScopeClient) EXPECT() *MockClusterScopeClientMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// DeleteApiServerLB mocks base method.
func (m *MockClusterScopeClient) DeleteApiServerLB(arg0 context.Context) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "DeleteApiServerLB", arg0)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// DeleteApiServerLB indicates an expected call of DeleteApiServerLB.
func (mr *MockClusterScopeClientMockRecorder) DeleteApiServerLB(arg0 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteApiServerLB", reflect.TypeOf((*MockClusterScopeClient)(nil).DeleteApiServerLB), arg0)
}</span>

// DeleteApiServerNLB mocks base method.
func (m *MockClusterScopeClient) DeleteApiServerNLB(arg0 context.Context) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "DeleteApiServerNLB", arg0)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// DeleteApiServerNLB indicates an expected call of DeleteApiServerNLB.
func (mr *MockClusterScopeClientMockRecorder) DeleteApiServerNLB(arg0 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteApiServerNLB", reflect.TypeOf((*MockClusterScopeClient)(nil).DeleteApiServerNLB), arg0)
}</span>

// DeleteDRG mocks base method.
func (m *MockClusterScopeClient) DeleteDRG(arg0 context.Context) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "DeleteDRG", arg0)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// DeleteDRG indicates an expected call of DeleteDRG.
func (mr *MockClusterScopeClientMockRecorder) DeleteDRG(arg0 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteDRG", reflect.TypeOf((*MockClusterScopeClient)(nil).DeleteDRG), arg0)
}</span>

// DeleteDRGRPCAttachment mocks base method.
func (m *MockClusterScopeClient) DeleteDRGRPCAttachment(arg0 context.Context) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "DeleteDRGRPCAttachment", arg0)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// DeleteDRGRPCAttachment indicates an expected call of DeleteDRGRPCAttachment.
func (mr *MockClusterScopeClientMockRecorder) DeleteDRGRPCAttachment(arg0 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteDRGRPCAttachment", reflect.TypeOf((*MockClusterScopeClient)(nil).DeleteDRGRPCAttachment), arg0)
}</span>

// DeleteDRGVCNAttachment mocks base method.
func (m *MockClusterScopeClient) DeleteDRGVCNAttachment(arg0 context.Context) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "DeleteDRGVCNAttachment", arg0)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// DeleteDRGVCNAttachment indicates an expected call of DeleteDRGVCNAttachment.
func (mr *MockClusterScopeClientMockRecorder) DeleteDRGVCNAttachment(arg0 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteDRGVCNAttachment", reflect.TypeOf((*MockClusterScopeClient)(nil).DeleteDRGVCNAttachment), arg0)
}</span>

// DeleteInternetGateway mocks base method.
func (m *MockClusterScopeClient) DeleteInternetGateway(arg0 context.Context) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "DeleteInternetGateway", arg0)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// DeleteInternetGateway indicates an expected call of DeleteInternetGateway.
func (mr *MockClusterScopeClientMockRecorder) DeleteInternetGateway(arg0 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteInternetGateway", reflect.TypeOf((*MockClusterScopeClient)(nil).DeleteInternetGateway), arg0)
}</span>

// DeleteNSGs mocks base method.
func (m *MockClusterScopeClient) DeleteNSGs(arg0 context.Context) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "DeleteNSGs", arg0)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// DeleteNSGs indicates an expected call of DeleteNSGs.
func (mr *MockClusterScopeClientMockRecorder) DeleteNSGs(arg0 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteNSGs", reflect.TypeOf((*MockClusterScopeClient)(nil).DeleteNSGs), arg0)
}</span>

// DeleteNatGateway mocks base method.
func (m *MockClusterScopeClient) DeleteNatGateway(arg0 context.Context) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "DeleteNatGateway", arg0)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// DeleteNatGateway indicates an expected call of DeleteNatGateway.
func (mr *MockClusterScopeClientMockRecorder) DeleteNatGateway(arg0 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteNatGateway", reflect.TypeOf((*MockClusterScopeClient)(nil).DeleteNatGateway), arg0)
}</span>

// DeleteRouteTables mocks base method.
func (m *MockClusterScopeClient) DeleteRouteTables(arg0 context.Context) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "DeleteRouteTables", arg0)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// DeleteRouteTables indicates an expected call of DeleteRouteTables.
func (mr *MockClusterScopeClientMockRecorder) DeleteRouteTables(arg0 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteRouteTables", reflect.TypeOf((*MockClusterScopeClient)(nil).DeleteRouteTables), arg0)
}</span>

// DeleteSecurityLists mocks base method.
func (m *MockClusterScopeClient) DeleteSecurityLists(arg0 context.Context) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "DeleteSecurityLists", arg0)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// DeleteSecurityLists indicates an expected call of DeleteSecurityLists.
func (mr *MockClusterScopeClientMockRecorder) DeleteSecurityLists(arg0 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteSecurityLists", reflect.TypeOf((*MockClusterScopeClient)(nil).DeleteSecurityLists), arg0)
}</span>

// DeleteServiceGateway mocks base method.
func (m *MockClusterScopeClient) DeleteServiceGateway(arg0 context.Context) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "DeleteServiceGateway", arg0)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// DeleteServiceGateway indicates an expected call of DeleteServiceGateway.
func (mr *MockClusterScopeClientMockRecorder) DeleteServiceGateway(arg0 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteServiceGateway", reflect.TypeOf((*MockClusterScopeClient)(nil).DeleteServiceGateway), arg0)
}</span>

// DeleteSubnets mocks base method.
func (m *MockClusterScopeClient) DeleteSubnets(arg0 context.Context) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "DeleteSubnets", arg0)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// DeleteSubnets indicates an expected call of DeleteSubnets.
func (mr *MockClusterScopeClientMockRecorder) DeleteSubnets(arg0 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteSubnets", reflect.TypeOf((*MockClusterScopeClient)(nil).DeleteSubnets), arg0)
}</span>

// DeleteVCN mocks base method.
func (m *MockClusterScopeClient) DeleteVCN(arg0 context.Context) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "DeleteVCN", arg0)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// DeleteVCN indicates an expected call of DeleteVCN.
func (mr *MockClusterScopeClientMockRecorder) DeleteVCN(arg0 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteVCN", reflect.TypeOf((*MockClusterScopeClient)(nil).DeleteVCN), arg0)
}</span>

// GetOCIClusterAccessor mocks base method.
func (m *MockClusterScopeClient) GetOCIClusterAccessor() scope.OCIClusterAccessor <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetOCIClusterAccessor")
        ret0, _ := ret[0].(scope.OCIClusterAccessor)
        return ret0
}</span>

// GetOCIClusterAccessor indicates an expected call of GetOCIClusterAccessor.
func (mr *MockClusterScopeClientMockRecorder) GetOCIClusterAccessor() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetOCIClusterAccessor", reflect.TypeOf((*MockClusterScopeClient)(nil).GetOCIClusterAccessor))
}</span>

// ReconcileApiServerLB mocks base method.
func (m *MockClusterScopeClient) ReconcileApiServerLB(arg0 context.Context) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "ReconcileApiServerLB", arg0)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// ReconcileApiServerLB indicates an expected call of ReconcileApiServerLB.
func (mr *MockClusterScopeClientMockRecorder) ReconcileApiServerLB(arg0 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReconcileApiServerLB", reflect.TypeOf((*MockClusterScopeClient)(nil).ReconcileApiServerLB), arg0)
}</span>

// ReconcileApiServerNLB mocks base method.
func (m *MockClusterScopeClient) ReconcileApiServerNLB(arg0 context.Context) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "ReconcileApiServerNLB", arg0)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// ReconcileApiServerNLB indicates an expected call of ReconcileApiServerNLB.
func (mr *MockClusterScopeClientMockRecorder) ReconcileApiServerNLB(arg0 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReconcileApiServerNLB", reflect.TypeOf((*MockClusterScopeClient)(nil).ReconcileApiServerNLB), arg0)
}</span>

// ReconcileDRG mocks base method.
func (m *MockClusterScopeClient) ReconcileDRG(arg0 context.Context) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "ReconcileDRG", arg0)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// ReconcileDRG indicates an expected call of ReconcileDRG.
func (mr *MockClusterScopeClientMockRecorder) ReconcileDRG(arg0 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReconcileDRG", reflect.TypeOf((*MockClusterScopeClient)(nil).ReconcileDRG), arg0)
}</span>

// ReconcileDRGRPCAttachment mocks base method.
func (m *MockClusterScopeClient) ReconcileDRGRPCAttachment(arg0 context.Context) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "ReconcileDRGRPCAttachment", arg0)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// ReconcileDRGRPCAttachment indicates an expected call of ReconcileDRGRPCAttachment.
func (mr *MockClusterScopeClientMockRecorder) ReconcileDRGRPCAttachment(arg0 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReconcileDRGRPCAttachment", reflect.TypeOf((*MockClusterScopeClient)(nil).ReconcileDRGRPCAttachment), arg0)
}</span>

// ReconcileDRGVCNAttachment mocks base method.
func (m *MockClusterScopeClient) ReconcileDRGVCNAttachment(arg0 context.Context) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "ReconcileDRGVCNAttachment", arg0)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// ReconcileDRGVCNAttachment indicates an expected call of ReconcileDRGVCNAttachment.
func (mr *MockClusterScopeClientMockRecorder) ReconcileDRGVCNAttachment(arg0 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReconcileDRGVCNAttachment", reflect.TypeOf((*MockClusterScopeClient)(nil).ReconcileDRGVCNAttachment), arg0)
}</span>

// ReconcileFailureDomains mocks base method.
func (m *MockClusterScopeClient) ReconcileFailureDomains(arg0 context.Context) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "ReconcileFailureDomains", arg0)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// ReconcileFailureDomains indicates an expected call of ReconcileFailureDomains.
func (mr *MockClusterScopeClientMockRecorder) ReconcileFailureDomains(arg0 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReconcileFailureDomains", reflect.TypeOf((*MockClusterScopeClient)(nil).ReconcileFailureDomains), arg0)
}</span>

// ReconcileInternetGateway mocks base method.
func (m *MockClusterScopeClient) ReconcileInternetGateway(arg0 context.Context) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "ReconcileInternetGateway", arg0)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// ReconcileInternetGateway indicates an expected call of ReconcileInternetGateway.
func (mr *MockClusterScopeClientMockRecorder) ReconcileInternetGateway(arg0 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReconcileInternetGateway", reflect.TypeOf((*MockClusterScopeClient)(nil).ReconcileInternetGateway), arg0)
}</span>

// ReconcileNSG mocks base method.
func (m *MockClusterScopeClient) ReconcileNSG(arg0 context.Context) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "ReconcileNSG", arg0)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// ReconcileNSG indicates an expected call of ReconcileNSG.
func (mr *MockClusterScopeClientMockRecorder) ReconcileNSG(arg0 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReconcileNSG", reflect.TypeOf((*MockClusterScopeClient)(nil).ReconcileNSG), arg0)
}</span>

// ReconcileNatGateway mocks base method.
func (m *MockClusterScopeClient) ReconcileNatGateway(arg0 context.Context) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "ReconcileNatGateway", arg0)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// ReconcileNatGateway indicates an expected call of ReconcileNatGateway.
func (mr *MockClusterScopeClientMockRecorder) ReconcileNatGateway(arg0 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReconcileNatGateway", reflect.TypeOf((*MockClusterScopeClient)(nil).ReconcileNatGateway), arg0)
}</span>

// ReconcileRouteTable mocks base method.
func (m *MockClusterScopeClient) ReconcileRouteTable(arg0 context.Context) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "ReconcileRouteTable", arg0)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// ReconcileRouteTable indicates an expected call of ReconcileRouteTable.
func (mr *MockClusterScopeClientMockRecorder) ReconcileRouteTable(arg0 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReconcileRouteTable", reflect.TypeOf((*MockClusterScopeClient)(nil).ReconcileRouteTable), arg0)
}</span>

// ReconcileServiceGateway mocks base method.
func (m *MockClusterScopeClient) ReconcileServiceGateway(arg0 context.Context) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "ReconcileServiceGateway", arg0)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// ReconcileServiceGateway indicates an expected call of ReconcileServiceGateway.
func (mr *MockClusterScopeClientMockRecorder) ReconcileServiceGateway(arg0 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReconcileServiceGateway", reflect.TypeOf((*MockClusterScopeClient)(nil).ReconcileServiceGateway), arg0)
}</span>

// ReconcileSubnet mocks base method.
func (m *MockClusterScopeClient) ReconcileSubnet(arg0 context.Context) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "ReconcileSubnet", arg0)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// ReconcileSubnet indicates an expected call of ReconcileSubnet.
func (mr *MockClusterScopeClientMockRecorder) ReconcileSubnet(arg0 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReconcileSubnet", reflect.TypeOf((*MockClusterScopeClient)(nil).ReconcileSubnet), arg0)
}</span>

// ReconcileVCN mocks base method.
func (m *MockClusterScopeClient) ReconcileVCN(arg0 context.Context) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "ReconcileVCN", arg0)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// ReconcileVCN indicates an expected call of ReconcileVCN.
func (mr *MockClusterScopeClientMockRecorder) ReconcileVCN(arg0 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReconcileVCN", reflect.TypeOf((*MockClusterScopeClient)(nil).ReconcileVCN), arg0)
}</span>

// SetRegionKey mocks base method.
func (m *MockClusterScopeClient) SetRegionKey(arg0 context.Context) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "SetRegionKey", arg0)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// SetRegionKey indicates an expected call of SetRegionKey.
func (mr *MockClusterScopeClientMockRecorder) SetRegionKey(arg0 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetRegionKey", reflect.TypeOf((*MockClusterScopeClient)(nil).SetRegionKey), arg0)
}</span>

// SetRegionCode indicates an expected call of SetRegionCode.
func (mr *MockClusterScopeClientMockRecorder) SetRegionCode(ctx interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetRegionKey", reflect.TypeOf((*MockClusterScopeClient)(nil).SetRegionKey), ctx)
}</span>
</pre>
		
		<pre class="file" id="file50" style="display: none">/*
 Copyright (c) 2021, 2022 Oracle and/or its affiliates.

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

      https://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
*/

package scope

import (
        "context"

        "github.com/oracle/cluster-api-provider-oci/cloud/ociutil"
        "github.com/oracle/oci-go-sdk/v65/common"
        "github.com/oracle/oci-go-sdk/v65/core"
        "github.com/pkg/errors"
)

// ReconcileNatGateway tries to move the NAT Gateway to the desired OCICluster Spec
func (s *ClusterScope) ReconcileNatGateway(ctx context.Context) error <span class="cov8" title="1">{
        if s.OCIClusterAccessor.GetNetworkSpec().Vcn.NATGateway.Skip </span><span class="cov8" title="1">{
                s.Logger.Info("Skipping NAT Gateway reconciliation as per spec")
                return nil
        }</span>
        <span class="cov8" title="1">if s.IsAllSubnetsPublic() </span><span class="cov8" title="1">{
                s.Logger.Info("All subnets are public, we don't need NAT gateway")
                return nil
        }</span>
        <span class="cov8" title="1">var err error
        ngw, err := s.GetNatGateway(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if ngw != nil </span><span class="cov8" title="1">{
                s.OCIClusterAccessor.GetNetworkSpec().Vcn.NATGateway.Id = ngw.Id
                s.Logger.Info("No Reconciliation Required for Nat Gateway", "nat_gateway", ngw.Id)
                return nil
        }</span>
        <span class="cov8" title="1">natGateway, err := s.CreateNatGateway(ctx)
        s.OCIClusterAccessor.GetNetworkSpec().Vcn.NATGateway.Id = natGateway
        return err</span>
}

// GetNatGateway retrieves the Cluster's core.NatGateway using the one of the following methods
//
// 1. the OCICluster's spec NatGatewayId
//
// 2. Listing the NAT Gateways for the Compartment (by ID), VCN and DisplayName and filtering by tag
// nolint:nilnil
func (s *ClusterScope) GetNatGateway(ctx context.Context) (*core.NatGateway, error) <span class="cov8" title="1">{
        ngwId := s.OCIClusterAccessor.GetNetworkSpec().Vcn.NATGateway.Id
        if ngwId != nil </span><span class="cov8" title="1">{
                resp, err := s.VCNClient.GetNatGateway(ctx, core.GetNatGatewayRequest{
                        NatGatewayId: ngwId,
                })
                if err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">ngw := resp.NatGateway
                if s.IsResourceCreatedByClusterAPI(ngw.FreeformTags) </span><span class="cov8" title="1">{
                        return &amp;ngw, err
                }</span> else<span class="cov0" title="0"> {
                        return nil, errors.New("cluster api tags have been modified out of context")
                }</span>
        }
        <span class="cov8" title="1">ngws, err := s.VCNClient.ListNatGateways(ctx, core.ListNatGatewaysRequest{
                CompartmentId: common.String(s.GetCompartmentId()),
                VcnId:         s.getVcnId(),
                DisplayName:   common.String(NatGatewayName),
        })
        if err != nil </span><span class="cov0" title="0">{
                s.Logger.Error(err, "Failed to list NAT gateways")
                return nil, errors.Wrap(err, "failed to list NAT gateways")
        }</span>
        <span class="cov8" title="1">for _, ngw := range ngws.Items </span><span class="cov8" title="1">{
                if s.IsResourceCreatedByClusterAPI(ngw.FreeformTags) </span><span class="cov8" title="1">{
                        return &amp;ngw, nil
                }</span>
        }
        <span class="cov8" title="1">return nil, nil</span>
}

// UpdateNatGateway updates the FreeFormTags and DefinedTags
func (s *ClusterScope) UpdateNatGateway(ctx context.Context) error <span class="cov0" title="0">{
        updateNGWDetails := core.UpdateNatGatewayDetails{
                FreeformTags: s.GetFreeFormTags(),
                DefinedTags:  s.GetDefinedTags(),
        }
        igwResponse, err := s.VCNClient.UpdateNatGateway(ctx, core.UpdateNatGatewayRequest{
                NatGatewayId:            s.OCIClusterAccessor.GetNetworkSpec().Vcn.NATGateway.Id,
                UpdateNatGatewayDetails: updateNGWDetails,
        })
        if err != nil </span><span class="cov0" title="0">{
                s.Logger.Error(err, "Failed to reconcile the nat gateway, failed to update")
                return errors.Wrap(err, "failed to reconcile the nat gateway, failed to update")
        }</span>
        <span class="cov0" title="0">s.Logger.Info("Successfully updated the nat gateway", "nat_gateway", *igwResponse.Id)
        return nil</span>
}

// CreateNatGateway creates the NAT Gateway for the cluster based on the ClusterScope
func (s *ClusterScope) CreateNatGateway(ctx context.Context) (*string, error) <span class="cov8" title="1">{
        ngwDetails := core.CreateNatGatewayDetails{
                CompartmentId: common.String(s.GetCompartmentId()),
                DisplayName:   common.String(NatGatewayName),
                VcnId:         s.getVcnId(),
                FreeformTags:  s.GetFreeFormTags(),
                DefinedTags:   s.GetDefinedTags(),
        }
        ngwResponse, err := s.VCNClient.CreateNatGateway(ctx, core.CreateNatGatewayRequest{
                CreateNatGatewayDetails: ngwDetails,
        })
        if err != nil </span><span class="cov8" title="1">{
                s.Logger.Error(err, "failed create nat gateway")
                return nil, errors.Wrap(err, "failed create nat gateway")
        }</span>
        <span class="cov8" title="1">s.Logger.Info("Successfully created the nat gateway", "ngw", *ngwResponse.Id)
        return ngwResponse.Id, nil</span>
}

// DeleteNatGateway retrieves and attempts to delete the NAT Gateway if found.
func (s *ClusterScope) DeleteNatGateway(ctx context.Context) error <span class="cov8" title="1">{
        if s.OCIClusterAccessor.GetNetworkSpec().Vcn.NATGateway.Skip </span><span class="cov0" title="0">{
                s.Logger.Info("Skipping NAT Gateway reconciliation as per spec")
                return nil
        }</span>
        <span class="cov8" title="1">ngw, err := s.GetNatGateway(ctx)
        if err != nil &amp;&amp; !ociutil.IsNotFound(err) </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">if ngw == nil </span><span class="cov8" title="1">{
                s.Logger.Info("NAT Gateway is already deleted")
                return nil
        }</span>
        <span class="cov8" title="1">_, err = s.VCNClient.DeleteNatGateway(ctx, core.DeleteNatGatewayRequest{
                NatGatewayId: ngw.Id,
        })
        if err != nil </span><span class="cov8" title="1">{
                s.Logger.Error(err, "failed to delete NatGateway")
                return errors.Wrap(err, "failed to delete NatGateway")
        }</span>
        <span class="cov8" title="1">s.Logger.Info("Successfully deleted NatGateway", "ngw", ngw.Id)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file51" style="display: none">/*
 Copyright (c) 2021, 2022 Oracle and/or its affiliates.

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

      https://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
*/

package scope

import (
        "context"
        "fmt"

        infrastructurev1beta2 "github.com/oracle/cluster-api-provider-oci/api/v1beta2"
        "github.com/oracle/cluster-api-provider-oci/cloud/ociutil"
        "github.com/oracle/cluster-api-provider-oci/cloud/ociutil/ptr"
        "github.com/oracle/oci-go-sdk/v65/common"
        "github.com/oracle/oci-go-sdk/v65/networkloadbalancer"
        "github.com/pkg/errors"
        clusterv1 "sigs.k8s.io/cluster-api/api/core/v1beta1"
)

// ReconcileApiServerNLB tries to move the Network Load Balancer to the desired OCICluster Spec
func (s *ClusterScope) ReconcileApiServerNLB(ctx context.Context) error <span class="cov8" title="1">{
        desiredApiServerNLB := s.NLBSpec()

        nlb, err := s.GetNetworkLoadBalancers(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if nlb != nil </span><span class="cov8" title="1">{
                if nlb.LifecycleState != networkloadbalancer.LifecycleStateActive </span><span class="cov8" title="1">{
                        return errors.New(fmt.Sprintf("network load balancer is in %s state. Waiting for ACTIVE state.", nlb.LifecycleState))
                }</span>
                <span class="cov8" title="1">lbIP, err := s.getNetworkLoadbalancerIp(*nlb)
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
                <span class="cov8" title="1">networkSpec := s.OCIClusterAccessor.GetNetworkSpec()
                networkSpec.APIServerLB.LoadBalancerId = nlb.Id
                s.OCIClusterAccessor.SetControlPlaneEndpoint(clusterv1.APIEndpoint{
                        Host: *lbIP,
                        Port: s.APIServerPort(),
                })
                if s.IsNLBEqual(nlb, desiredApiServerNLB) </span><span class="cov8" title="1">{
                        s.Logger.Info("No Reconciliation Required for ApiServerLB", "nlb", nlb.Id)
                        return nil
                }</span>
                <span class="cov8" title="1">s.Logger.Info("Reconciliation Required for ApiServerLB", "nlb", nlb.Id)
                return s.UpdateNLB(ctx, desiredApiServerNLB)</span>
        }
        <span class="cov8" title="1">nlbID, nlbIP, err := s.CreateNLB(ctx, desiredApiServerNLB)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">networkSpec := s.OCIClusterAccessor.GetNetworkSpec()
        networkSpec.APIServerLB.LoadBalancerId = nlbID
        s.OCIClusterAccessor.SetControlPlaneEndpoint(clusterv1.APIEndpoint{
                Host: *nlbIP,
                Port: s.APIServerPort(),
        })
        return err</span>
}

// DeleteApiServerNLB retrieves and attempts to delete the Network Load Balancer if found.
// It will await the Work Request completion before returning
func (s *ClusterScope) DeleteApiServerNLB(ctx context.Context) error <span class="cov8" title="1">{
        nlb, err := s.GetNetworkLoadBalancers(ctx)
        if err != nil &amp;&amp; !ociutil.IsNotFound(err) </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if nlb == nil </span><span class="cov8" title="1">{
                s.Logger.Info("network loadbalancer is already deleted")
                return nil
        }</span>
        <span class="cov8" title="1">lbResponse, err := s.NetworkLoadBalancerClient.DeleteNetworkLoadBalancer(ctx, networkloadbalancer.DeleteNetworkLoadBalancerRequest{
                NetworkLoadBalancerId: nlb.Id,
        })
        if err != nil </span><span class="cov8" title="1">{
                s.Logger.Error(err, "failed to delete apiserver nlb")
                return errors.Wrap(err, "failed to delete apiserver nlb")
        }</span>
        <span class="cov8" title="1">_, err = ociutil.AwaitNLBWorkRequest(ctx, s.NetworkLoadBalancerClient, lbResponse.OpcWorkRequestId)
        if err != nil </span><span class="cov8" title="1">{
                return errors.Wrap(err, "work request to delete nlb failed")
        }</span>
        <span class="cov8" title="1">s.Logger.Info("Successfully deleted apiserver nlb", "nlb", nlb.Id)
        return nil</span>
}

// NLBSpec builds the Network LoadBalancer from the ClusterScope and returns it
func (s *ClusterScope) NLBSpec() infrastructurev1beta2.LoadBalancer <span class="cov8" title="1">{
        nlbSpec := infrastructurev1beta2.LoadBalancer{
                Name:    s.GetControlPlaneLoadBalancerName(),
                NLBSpec: s.OCIClusterAccessor.GetNetworkSpec().APIServerLB.NLBSpec,
        }
        return nlbSpec
}</span>

// GetControlPlaneLoadBalancerName returns the user defined APIServerLB name from the spec or
// assigns the name based on the OCICluster's name
func (s *ClusterScope) GetControlPlaneLoadBalancerName() string <span class="cov8" title="1">{
        if s.OCIClusterAccessor.GetNetworkSpec().APIServerLB.Name != "" </span><span class="cov0" title="0">{
                return s.OCIClusterAccessor.GetNetworkSpec().APIServerLB.Name
        }</span>
        <span class="cov8" title="1">return fmt.Sprintf("%s-%s", s.OCIClusterAccessor.GetName(), "apiserver")</span>
}

// UpdateLB updates existing Load Balancer's DisplayName, FreeformTags and DefinedTags
func (s *ClusterScope) UpdateNLB(ctx context.Context, nlb infrastructurev1beta2.LoadBalancer) error <span class="cov8" title="1">{
        nlbId := s.OCIClusterAccessor.GetNetworkSpec().APIServerLB.LoadBalancerId
        updateLBDetails := networkloadbalancer.UpdateNetworkLoadBalancerDetails{
                DisplayName: common.String(nlb.Name),
        }
        nlbResponse, err := s.NetworkLoadBalancerClient.UpdateNetworkLoadBalancer(ctx, networkloadbalancer.UpdateNetworkLoadBalancerRequest{
                UpdateNetworkLoadBalancerDetails: updateLBDetails,
                NetworkLoadBalancerId:            nlbId,
        })
        if err != nil </span><span class="cov8" title="1">{
                s.Logger.Error(err, "failed to reconcile the apiserver NLB, failed to generate update nlb workrequest")
                return errors.Wrap(err, "failed to reconcile the apiserver NLB, failed to generate update nlb workrequest")
        }</span>
        <span class="cov8" title="1">_, err = ociutil.AwaitNLBWorkRequest(ctx, s.NetworkLoadBalancerClient, nlbResponse.OpcWorkRequestId)
        if err != nil </span><span class="cov8" title="1">{
                s.Logger.Error(err, "failed to reconcile the apiserver NLB, failed to update nlb")
                return errors.Wrap(err, "failed to reconcile the apiserver NLB, failed to update nlb")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// CreateNLB configures and creates the Network Load Balancer for the cluster based on the ClusterScope.
// This configures the LB Listeners and Backend Sets in order to create the Network Load Balancer.
// It will await the Work Request completion before returning
//
// See https://docs.oracle.com/en-us/iaas/Content/NetworkLoadBalancer/overview.htm for more details on the Network
// Load Balancer
func (s *ClusterScope) CreateNLB(ctx context.Context, lb infrastructurev1beta2.LoadBalancer) (*string, *string, error) <span class="cov8" title="1">{
        isPreserverSourceIp := lb.NLBSpec.BackendSetDetails.IsPreserveSource
        if isPreserverSourceIp == nil </span><span class="cov8" title="1">{
                isPreserverSourceIp = common.Bool(false)
        }</span>
        <span class="cov8" title="1">listenerDetails := make(map[string]networkloadbalancer.ListenerDetails)
        listenerDetails[APIServerLBListener] = networkloadbalancer.ListenerDetails{
                Protocol:              networkloadbalancer.ListenerProtocolsTcp,
                Port:                  common.Int(int(s.APIServerPort())),
                DefaultBackendSetName: common.String(APIServerLBBackendSetName),
                Name:                  common.String(APIServerLBListener),
        }

        backendSetDetails := make(map[string]networkloadbalancer.BackendSetDetails)
        healthCheckUrl := lb.NLBSpec.BackendSetDetails.HealthChecker.UrlPath
        if healthCheckUrl == nil </span><span class="cov8" title="1">{
                healthCheckUrl = common.String("/healthz")
        }</span>
        <span class="cov8" title="1">backendSetDetails[APIServerLBBackendSetName] = networkloadbalancer.BackendSetDetails{
                Policy:                   LoadBalancerPolicy,
                IsPreserveSource:         isPreserverSourceIp,
                IsFailOpen:               lb.NLBSpec.BackendSetDetails.IsFailOpen,
                IsInstantFailoverEnabled: lb.NLBSpec.BackendSetDetails.IsInstantFailoverEnabled,
                HealthChecker: &amp;networkloadbalancer.HealthChecker{
                        Port:       common.Int(int(s.APIServerPort())),
                        Protocol:   networkloadbalancer.HealthCheckProtocolsHttps,
                        UrlPath:    healthCheckUrl,
                        ReturnCode: common.Int(200),
                },
                Backends: []networkloadbalancer.Backend{},
        }

        var controlPlaneEndpointSubnets []string
        for _, subnet := range ptr.ToSubnetSlice(s.OCIClusterAccessor.GetNetworkSpec().Vcn.Subnets) </span><span class="cov8" title="1">{
                if subnet.Role == infrastructurev1beta2.ControlPlaneEndpointRole </span><span class="cov8" title="1">{
                        if subnet.ID != nil </span><span class="cov8" title="1">{
                                controlPlaneEndpointSubnets = append(controlPlaneEndpointSubnets, *subnet.ID)
                        }</span>
                }
        }
        <span class="cov8" title="1">var reservedIps []networkloadbalancer.ReservedIp
        if len(lb.NLBSpec.ReservedIpIds) &gt; 0 </span><span class="cov8" title="1">{
                // since max is one we only take the first ip id supplied
                reservedIps = append(reservedIps, networkloadbalancer.ReservedIp{Id: common.String(lb.NLBSpec.ReservedIpIds[0])})
        }</span>

        <span class="cov8" title="1">if len(controlPlaneEndpointSubnets) &lt; 1 </span><span class="cov8" title="1">{
                return nil, nil, errors.New("control plane endpoint subnet not provided")
        }</span>

        <span class="cov8" title="1">if len(controlPlaneEndpointSubnets) &gt; 1 </span><span class="cov8" title="1">{
                return nil, nil, errors.New("cannot have more than 1 control plane endpoint subnet")
        }</span>
        <span class="cov8" title="1">nlbDetails := networkloadbalancer.CreateNetworkLoadBalancerDetails{
                CompartmentId: common.String(s.GetCompartmentId()),
                DisplayName:   common.String(lb.Name),
                SubnetId:      common.String(controlPlaneEndpointSubnets[0]),
                IsPrivate:     common.Bool(s.isControlPlaneEndpointSubnetPrivate()),
                Listeners:     listenerDetails,
                BackendSets:   backendSetDetails,
                FreeformTags:  s.GetFreeFormTags(),
                DefinedTags:   s.GetDefinedTags(),
                ReservedIps:   reservedIps,
        }
        nsgs := make([]string, 0)
        for _, nsg := range ptr.ToNSGSlice(s.OCIClusterAccessor.GetNetworkSpec().Vcn.NetworkSecurityGroup.List) </span><span class="cov8" title="1">{
                if nsg.Role == infrastructurev1beta2.ControlPlaneEndpointRole </span><span class="cov8" title="1">{
                        if nsg.ID != nil </span><span class="cov8" title="1">{
                                nsgs = append(nsgs, *nsg.ID)
                        }</span>
                }
        }
        <span class="cov8" title="1">nlbDetails.NetworkSecurityGroupIds = nsgs

        s.Logger.Info("Creating network load balancer")
        nlbResponse, err := s.NetworkLoadBalancerClient.CreateNetworkLoadBalancer(ctx, networkloadbalancer.CreateNetworkLoadBalancerRequest{
                CreateNetworkLoadBalancerDetails: nlbDetails,
                OpcRetryToken:                    ociutil.GetOPCRetryToken("%s-%s", "create-nlb", s.OCIClusterAccessor.GetOCIResourceIdentifier()),
        })
        if err != nil </span><span class="cov8" title="1">{
                s.Logger.Error(err, "failed to create apiserver nlb, failed to create work request")
                return nil, nil, errors.Wrap(err, "failed to create apiserver nlb, failed to create work request")
        }</span>
        <span class="cov8" title="1">_, err = ociutil.AwaitNLBWorkRequest(ctx, s.NetworkLoadBalancerClient, nlbResponse.OpcWorkRequestId)
        if err != nil </span><span class="cov8" title="1">{
                return nil, nil, errors.Wrap(err, "awaiting network load balancer")
        }</span>

        <span class="cov8" title="1">nlb, err := s.NetworkLoadBalancerClient.GetNetworkLoadBalancer(ctx, networkloadbalancer.GetNetworkLoadBalancerRequest{
                NetworkLoadBalancerId: nlbResponse.Id,
        })
        if err != nil </span><span class="cov0" title="0">{
                s.Logger.Error(err, "failed to get apiserver lb after creation")
                return nil, nil, errors.Wrap(err, "failed to get apiserver lb after creation")
        }</span>

        <span class="cov8" title="1">nlbIp, err := s.getNetworkLoadbalancerIp(nlb.NetworkLoadBalancer)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov8" title="1">s.Logger.Info("Successfully created apiserver lb", "lb", nlb.Id, "ip", nlbIp)
        return nlb.Id, nlbIp, nil</span>
}

func (s *ClusterScope) getNetworkLoadbalancerIp(nlb networkloadbalancer.NetworkLoadBalancer) (*string, error) <span class="cov8" title="1">{
        var nlbIp *string
        if len(nlb.IpAddresses) &lt; 1 </span><span class="cov8" title="1">{
                return nil, errors.New("nlb does not have valid ip addresses")
        }</span>
        <span class="cov8" title="1">if ptr.ToBool(nlb.IsPrivate) </span><span class="cov0" title="0">{
                nlbIp = nlb.IpAddresses[0].IpAddress
        }</span> else<span class="cov8" title="1"> {
                for _, ip := range nlb.IpAddresses </span><span class="cov8" title="1">{
                        if *ip.IsPublic </span><span class="cov8" title="1">{
                                nlbIp = ip.IpAddress
                        }</span>
                }
        }
        <span class="cov8" title="1">if nlbIp == nil </span><span class="cov8" title="1">{
                return nil, errors.New("nlb does not have valid public ip address")
        }</span>
        <span class="cov8" title="1">return nlbIp, nil</span>
}

// IsNLBEqual determines if the actual networkloadbalancer.NetworkLoadBalancer is equal to the desired.
// Equality is determined by DisplayName
func (s *ClusterScope) IsNLBEqual(actual *networkloadbalancer.NetworkLoadBalancer, desired infrastructurev1beta2.LoadBalancer) bool <span class="cov8" title="1">{
        if desired.Name != *actual.DisplayName </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">return true</span>
}

// GetNetworkLoadBalancers retrieves the Cluster's networkloadbalancer.NetworkLoadBalancer using the one of the following methods
//
// 1. the OCICluster's spec LoadBalancerId
//
// 2. Listing the NetworkLoadBalancers for the Compartment (by ID) and DisplayName then filtering by tag
// nolint:nilnil
func (s *ClusterScope) GetNetworkLoadBalancers(ctx context.Context) (*networkloadbalancer.NetworkLoadBalancer, error) <span class="cov8" title="1">{
        nlbOcid := s.OCIClusterAccessor.GetNetworkSpec().APIServerLB.LoadBalancerId
        if nlbOcid != nil </span><span class="cov8" title="1">{
                resp, err := s.NetworkLoadBalancerClient.GetNetworkLoadBalancer(ctx, networkloadbalancer.GetNetworkLoadBalancerRequest{
                        NetworkLoadBalancerId: nlbOcid,
                })
                if err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">nlb := resp.NetworkLoadBalancer
                if s.IsResourceCreatedByClusterAPI(nlb.FreeformTags) </span><span class="cov8" title="1">{
                        return &amp;nlb, nil
                }</span> else<span class="cov0" title="0"> {
                        return nil, errors.New("cluster api tags have been modified out of context")
                }</span>
        }
        <span class="cov8" title="1">nlbs, err := s.NetworkLoadBalancerClient.ListNetworkLoadBalancers(ctx, networkloadbalancer.ListNetworkLoadBalancersRequest{
                CompartmentId: common.String(s.GetCompartmentId()),
                DisplayName:   common.String(s.GetControlPlaneLoadBalancerName()),
        })
        if err != nil </span><span class="cov0" title="0">{
                s.Logger.Error(err, "Failed to list nlb by name")
                return nil, errors.Wrap(err, "failed to list nlb by name")
        }</span>

        <span class="cov8" title="1">for _, nlb := range nlbs.Items </span><span class="cov8" title="1">{
                if s.IsResourceCreatedByClusterAPI(nlb.FreeformTags) </span><span class="cov8" title="1">{
                        resp, err := s.NetworkLoadBalancerClient.GetNetworkLoadBalancer(ctx, networkloadbalancer.GetNetworkLoadBalancerRequest{
                                NetworkLoadBalancerId: nlb.Id,
                        })
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">return &amp;resp.NetworkLoadBalancer, nil</span>
                }
        }
        <span class="cov8" title="1">return nil, nil</span>
}
</pre>
		
		<pre class="file" id="file52" style="display: none">/*
 Copyright (c) 2021, 2022 Oracle and/or its affiliates.

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

      https://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
*/

package scope

import (
        "context"
        "fmt"
        "reflect"
        "strings"

        infrastructurev1beta2 "github.com/oracle/cluster-api-provider-oci/api/v1beta2"
        "github.com/oracle/cluster-api-provider-oci/cloud/ociutil"
        "github.com/oracle/cluster-api-provider-oci/cloud/ociutil/ptr"
        "github.com/oracle/oci-go-sdk/v65/common"
        "github.com/oracle/oci-go-sdk/v65/core"
        "github.com/pkg/errors"
)

func (s *ClusterScope) ReconcileNSG(ctx context.Context) error <span class="cov8" title="1">{
        if s.OCIClusterAccessor.GetNetworkSpec().Vcn.NetworkSecurityGroup.Skip </span><span class="cov0" title="0">{
                s.Logger.Info("Skipping Network Security Group reconciliation as per spec")
                return nil
        }</span>
        <span class="cov8" title="1">desiredNSGs := s.OCIClusterAccessor.GetNetworkSpec().Vcn.NetworkSecurityGroup
        for _, desiredNSG := range desiredNSGs.List </span><span class="cov8" title="1">{
                if desiredNSG == nil </span><span class="cov8" title="1">{
                        s.Logger.Info("Skipping nil NSG pointer in spec")
                        continue</span>
                }
                <span class="cov8" title="1">desiredNSGPtr := *desiredNSG
                nsg, err := s.GetNSG(ctx, desiredNSGPtr)
                if err != nil </span><span class="cov0" title="0">{
                        s.Logger.Error(err, "error to get nsg")
                        return err
                }</span>
                <span class="cov8" title="1">if nsg != nil </span><span class="cov8" title="1">{
                        nsgOCID := nsg.Id
                        desiredNSG.ID = nsgOCID
                        if !s.IsNSGEqual(nsg, desiredNSGPtr) </span><span class="cov8" title="1">{
                                err = s.UpdateNSG(ctx, desiredNSGPtr)
                                if err != nil </span><span class="cov8" title="1">{
                                        return err
                                }</span>
                                <span class="cov8" title="1">s.Logger.Info("Successfully updated network security list", "nsg", nsgOCID)</span>
                        }
                        <span class="cov8" title="1">continue</span>
                }
                <span class="cov8" title="1">s.Logger.Info("Creating the network security list")
                nsgID, err := s.CreateNSG(ctx, desiredNSGPtr)
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
                <span class="cov0" title="0">s.Logger.Info("Created the nsg", "nsg", nsgID)
                desiredNSG.ID = nsgID</span>

        }
        <span class="cov8" title="1">for _, desiredNSG := range desiredNSGs.List </span><span class="cov8" title="1">{
                if desiredNSG == nil </span><span class="cov8" title="1">{
                        s.Logger.Info("Skipping nil NSG pointer in spec")
                        continue</span>
                }
                <span class="cov8" title="1">s.adjustNSGRulesSpec(desiredNSG, desiredNSGs.List)
                isNSGUpdated, err := s.UpdateNSGSecurityRulesIfNeeded(ctx, *desiredNSG, desiredNSG.ID)
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
                <span class="cov8" title="1">if !isNSGUpdated </span><span class="cov8" title="1">{
                        s.Logger.Info("No Reconciliation Required for Network Security Group", "nsg", *desiredNSG.ID)
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (s *ClusterScope) adjustNSGRulesSpec(desiredNSG *infrastructurev1beta2.NSG, nsgList []*infrastructurev1beta2.NSG) <span class="cov8" title="1">{
        ingressRules := make([]infrastructurev1beta2.IngressSecurityRuleForNSG, 0)
        for _, ingressRule := range desiredNSG.IngressRules </span><span class="cov8" title="1">{
                if ingressRule.SourceType == infrastructurev1beta2.IngressSecurityRuleSourceTypeServiceCidrBlock </span><span class="cov0" title="0">{
                        ingressRule.Source = common.String(fmt.Sprintf("all-%s-services-in-oracle-services-network", strings.ToLower(s.RegionKey)))
                }</span>
                <span class="cov8" title="1">ingressRules = append(ingressRules, ingressRule)</span>
        }
        <span class="cov8" title="1">desiredNSG.IngressRules = ingressRules
        egressRules := make([]infrastructurev1beta2.EgressSecurityRuleForNSG, 0)
        for _, egressRule := range desiredNSG.EgressRules </span><span class="cov8" title="1">{
                if egressRule.DestinationType == infrastructurev1beta2.EgressSecurityRuleDestinationTypeServiceCidrBlock </span><span class="cov0" title="0">{
                        egressRule.Destination = common.String(fmt.Sprintf("all-%s-services-in-oracle-services-network", strings.ToLower(s.RegionKey)))
                }</span>
                <span class="cov8" title="1">egressRules = append(egressRules, egressRule)</span>
        }
        <span class="cov8" title="1">desiredNSG.EgressRules = egressRules</span>
}

// nolint:nilnil
func (s *ClusterScope) GetNSG(ctx context.Context, spec infrastructurev1beta2.NSG) (*core.NetworkSecurityGroup, error) <span class="cov8" title="1">{
        nsgOCID := spec.ID
        if nsgOCID != nil </span><span class="cov8" title="1">{
                resp, err := s.VCNClient.GetNetworkSecurityGroup(ctx, core.GetNetworkSecurityGroupRequest{
                        NetworkSecurityGroupId: nsgOCID,
                })
                if err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">nsg := resp.NetworkSecurityGroup
                if s.IsResourceCreatedByClusterAPI(nsg.FreeformTags) </span><span class="cov8" title="1">{
                        return &amp;nsg, nil
                }</span> else<span class="cov0" title="0"> {
                        return nil, errors.New("cluster api tags have been modified out of context")
                }</span>
        }
        <span class="cov8" title="1">nsgs, err := s.VCNClient.ListNetworkSecurityGroups(ctx, core.ListNetworkSecurityGroupsRequest{
                CompartmentId: common.String(s.GetCompartmentId()),
                VcnId:         s.getVcnId(),
                DisplayName:   common.String(spec.Name),
        })
        if err != nil </span><span class="cov0" title="0">{
                s.Logger.Error(err, "failed to list network security groups")
                return nil, errors.Wrap(err, "failed to list network security groups")
        }</span>
        <span class="cov8" title="1">for _, nsg := range nsgs.Items </span><span class="cov0" title="0">{
                if s.IsResourceCreatedByClusterAPI(nsg.FreeformTags) </span><span class="cov0" title="0">{
                        return &amp;nsg, nil
                }</span>
        }
        <span class="cov8" title="1">return nil, nil</span>
}

func (s *ClusterScope) DeleteNSGs(ctx context.Context) error <span class="cov8" title="1">{
        if s.OCIClusterAccessor.GetNetworkSpec().Vcn.NetworkSecurityGroup.Skip </span><span class="cov0" title="0">{
                s.Logger.Info("Skipping Network Security Group reconciliation as per spec")
                return nil
        }</span>
        <span class="cov8" title="1">desiredNSGs := s.OCIClusterAccessor.GetNetworkSpec().Vcn.NetworkSecurityGroup
        for _, desiredNSG := range desiredNSGs.List </span><span class="cov8" title="1">{
                nsg, err := s.GetNSG(ctx, *desiredNSG)
                if err != nil &amp;&amp; !ociutil.IsNotFound(err) </span><span class="cov8" title="1">{
                        return err
                }</span>
                <span class="cov8" title="1">if nsg == nil </span><span class="cov8" title="1">{
                        s.Logger.Info("nsg is already deleted", "nsg", desiredNSG.Name)
                        continue</span>
                }
                <span class="cov8" title="1">_, err = s.VCNClient.DeleteNetworkSecurityGroup(ctx, core.DeleteNetworkSecurityGroupRequest{
                        NetworkSecurityGroupId: nsg.Id,
                })
                if err != nil </span><span class="cov8" title="1">{
                        s.Logger.Error(err, "failed to delete nsg")
                        return errors.Wrap(err, "failed to delete nsg")
                }</span>
                <span class="cov8" title="1">s.Logger.Info("Successfully deleted nsg", "subnet", desiredNSG.Name)</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (s *ClusterScope) GetNSGSpec() []*infrastructurev1beta2.NSG <span class="cov8" title="1">{
        return s.OCIClusterAccessor.GetNetworkSpec().Vcn.NetworkSecurityGroup.List
}</span>

func (s *ClusterScope) IsNSGExitsByRole(role infrastructurev1beta2.Role) bool <span class="cov0" title="0">{
        for _, nsg := range s.GetNSGSpec() </span><span class="cov0" title="0">{
                if role == nsg.Role </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

// IsNSGEqual compares the actual and desired NSG using name.
func (s *ClusterScope) IsNSGEqual(actual *core.NetworkSecurityGroup, desired infrastructurev1beta2.NSG) bool <span class="cov8" title="1">{
        if *actual.DisplayName != desired.Name </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">return true</span>
}

// UpdateNSGSecurityRulesIfNeeded updates NSG rules if required by comparing actual and desired.
func (s *ClusterScope) UpdateNSGSecurityRulesIfNeeded(ctx context.Context, desired infrastructurev1beta2.NSG,
        nsgId *string) (bool, error) <span class="cov8" title="1">{
        var ingressRulesToAdd []infrastructurev1beta2.IngressSecurityRuleForNSG
        var egressRulesToAdd []infrastructurev1beta2.EgressSecurityRuleForNSG
        var securityRulesToRemove []string
        var isNSGUpdated bool
        listSecurityRulesResponse, err := s.VCNClient.ListNetworkSecurityGroupSecurityRules(ctx, core.ListNetworkSecurityGroupSecurityRulesRequest{
                NetworkSecurityGroupId: nsgId,
        })
        if err != nil </span><span class="cov0" title="0">{
                s.Logger.Error(err, "failed to reconcile the network security group, failed to list security rules")
                return isNSGUpdated, errors.Wrap(err, "failed to reconcile the network security group, failed to list security rules")
        }</span>
        <span class="cov8" title="1">ingressRules, egressRules := s.generateSpecFromSecurityRules(listSecurityRulesResponse.Items, nsgId)

        for i, ingressRule := range desired.IngressRules </span><span class="cov8" title="1">{
                if ingressRule.IsStateless == nil </span><span class="cov8" title="1">{
                        desired.IngressRules[i].IsStateless = common.Bool(false)
                }</span>
        }
        <span class="cov8" title="1">for i, egressRule := range desired.EgressRules </span><span class="cov8" title="1">{
                if egressRule.IsStateless == nil </span><span class="cov8" title="1">{
                        desired.EgressRules[i].IsStateless = common.Bool(false)
                }</span>
        }

        <span class="cov8" title="1">for _, desiredRule := range desired.IngressRules </span><span class="cov8" title="1">{
                found := false
                for _, actualRule := range ingressRules </span><span class="cov8" title="1">{
                        if reflect.DeepEqual(desiredRule, actualRule) </span><span class="cov8" title="1">{
                                found = true
                                break</span>
                        }
                }
                <span class="cov8" title="1">if !found </span><span class="cov8" title="1">{
                        ingressRulesToAdd = append(ingressRulesToAdd, desiredRule)
                }</span>
        }

        <span class="cov8" title="1">for id, actualRule := range ingressRules </span><span class="cov8" title="1">{
                found := false
                for _, desiredRule := range desired.IngressRules </span><span class="cov8" title="1">{
                        if reflect.DeepEqual(desiredRule, actualRule) </span><span class="cov8" title="1">{
                                found = true
                                break</span>
                        }
                }
                <span class="cov8" title="1">if !found </span><span class="cov8" title="1">{
                        securityRulesToRemove = append(securityRulesToRemove, id)
                }</span>
        }

        <span class="cov8" title="1">for _, desiredRule := range desired.EgressRules </span><span class="cov8" title="1">{
                found := false
                for _, actualRule := range egressRules </span><span class="cov8" title="1">{
                        if reflect.DeepEqual(desiredRule, actualRule) </span><span class="cov8" title="1">{
                                found = true
                                break</span>
                        }
                }
                <span class="cov8" title="1">if !found </span><span class="cov8" title="1">{
                        egressRulesToAdd = append(egressRulesToAdd, desiredRule)
                }</span>
        }

        <span class="cov8" title="1">for id, actualRule := range egressRules </span><span class="cov8" title="1">{
                found := false
                for _, desiredRule := range desired.EgressRules </span><span class="cov8" title="1">{
                        if reflect.DeepEqual(desiredRule, actualRule) </span><span class="cov8" title="1">{
                                found = true
                                break</span>
                        }
                }
                <span class="cov8" title="1">if !found </span><span class="cov8" title="1">{
                        securityRulesToRemove = append(securityRulesToRemove, id)
                }</span>
        }

        <span class="cov8" title="1">if len(ingressRulesToAdd) &gt; 0 || len(egressRulesToAdd) &gt; 0 </span><span class="cov8" title="1">{
                isNSGUpdated = true
                err := s.AddNSGSecurityRules(ctx, desired.ID, ingressRulesToAdd, egressRulesToAdd)
                if err != nil </span><span class="cov8" title="1">{
                        s.Logger.Error(err, "failed to reconcile the network security group, failed to add security rules")
                        return isNSGUpdated, err
                }</span>
                <span class="cov8" title="1">s.Logger.Info("Successfully added missing rules in NSG", "nsg", *nsgId)</span>
        }
        <span class="cov8" title="1">if len(securityRulesToRemove) &gt; 0 </span><span class="cov8" title="1">{
                isNSGUpdated = true
                _, err = s.VCNClient.RemoveNetworkSecurityGroupSecurityRules(ctx, core.RemoveNetworkSecurityGroupSecurityRulesRequest{
                        NetworkSecurityGroupId: desired.ID,
                        RemoveNetworkSecurityGroupSecurityRulesDetails: core.RemoveNetworkSecurityGroupSecurityRulesDetails{
                                SecurityRuleIds: securityRulesToRemove,
                        },
                })
                if err != nil </span><span class="cov0" title="0">{
                        s.Logger.Error(err, "failed to reconcile the network security group, failed to remove security rules")
                        return isNSGUpdated, err
                }</span>
                <span class="cov8" title="1">s.Logger.Info("Successfully deleted rules in NSG", "nsg", *nsgId)</span>
        }
        <span class="cov8" title="1">return isNSGUpdated, nil</span>
}

func (s *ClusterScope) UpdateNSG(ctx context.Context, nsgSpec infrastructurev1beta2.NSG) error <span class="cov8" title="1">{
        updateNSGDetails := core.UpdateNetworkSecurityGroupDetails{
                DisplayName: common.String(nsgSpec.Name),
        }
        nsgResponse, err := s.VCNClient.UpdateNetworkSecurityGroup(ctx, core.UpdateNetworkSecurityGroupRequest{
                NetworkSecurityGroupId:            nsgSpec.ID,
                UpdateNetworkSecurityGroupDetails: updateNSGDetails,
        })
        if err != nil </span><span class="cov8" title="1">{
                s.Logger.Error(err, "failed to reconcile the network security group, failed to update")
                return errors.Wrap(err, "failed to reconcile the network security group, failed to update")
        }</span>
        <span class="cov8" title="1">s.Logger.Info("successfully updated the network security group", "network security group", *nsgResponse.Id)
        return nil</span>
}

func (s *ClusterScope) generateAddSecurityRuleFromSpec(ingressRules []infrastructurev1beta2.IngressSecurityRuleForNSG,
        egressRules []infrastructurev1beta2.EgressSecurityRuleForNSG) []core.AddSecurityRuleDetails <span class="cov8" title="1">{
        var securityRules []core.AddSecurityRuleDetails
        var icmpOptions *core.IcmpOptions
        var tcpOptions *core.TcpOptions
        var udpOptions *core.UdpOptions
        var stateless *bool
        for _, ingressRule := range ingressRules </span><span class="cov8" title="1">{
                icmpOptions, tcpOptions, udpOptions = getProtocolOptions(ingressRule.IcmpOptions, ingressRule.TcpOptions, ingressRule.UdpOptions)
                // while comparing values, the boolean value has to be always set
                stateless = ingressRule.IsStateless
                if stateless == nil </span><span class="cov0" title="0">{
                        stateless = common.Bool(false)
                }</span>
                <span class="cov8" title="1">secRule := core.AddSecurityRuleDetails{
                        Direction:   core.AddSecurityRuleDetailsDirectionIngress,
                        Protocol:    ingressRule.Protocol,
                        Description: ingressRule.Description,
                        IcmpOptions: icmpOptions,
                        IsStateless: stateless,
                        Source:      ingressRule.Source,
                        SourceType:  core.AddSecurityRuleDetailsSourceTypeEnum(ingressRule.SourceType),
                        TcpOptions:  tcpOptions,
                        UdpOptions:  udpOptions,
                }
                if ingressRule.SourceType == infrastructurev1beta2.IngressSecurityRuleSourceTypeNSG </span><span class="cov8" title="1">{
                        secRule.Source = getNsgIdFromName(ingressRule.Source, s.GetNSGSpec())
                }</span>
                <span class="cov8" title="1">securityRules = append(securityRules, secRule)</span>
        }
        <span class="cov8" title="1">for _, egressRule := range egressRules </span><span class="cov8" title="1">{
                icmpOptions, tcpOptions, udpOptions = getProtocolOptions(egressRule.IcmpOptions, egressRule.TcpOptions, egressRule.UdpOptions)
                // while comparing values, the boolean value has to be always set
                stateless = egressRule.IsStateless
                if stateless == nil </span><span class="cov0" title="0">{
                        stateless = common.Bool(false)
                }</span>
                <span class="cov8" title="1">secRule := core.AddSecurityRuleDetails{
                        Direction:       core.AddSecurityRuleDetailsDirectionEgress,
                        Protocol:        egressRule.Protocol,
                        Description:     egressRule.Description,
                        IcmpOptions:     icmpOptions,
                        IsStateless:     stateless,
                        Destination:     egressRule.Destination,
                        DestinationType: core.AddSecurityRuleDetailsDestinationTypeEnum(egressRule.DestinationType),
                        TcpOptions:      tcpOptions,
                        UdpOptions:      udpOptions,
                }
                if egressRule.DestinationType == infrastructurev1beta2.EgressSecurityRuleDestinationTypeNSG </span><span class="cov8" title="1">{
                        secRule.Destination = getNsgIdFromName(egressRule.Destination, s.GetNSGSpec())
                }</span>
                <span class="cov8" title="1">securityRules = append(securityRules, secRule)</span>
        }
        <span class="cov8" title="1">return securityRules</span>
}

func (s *ClusterScope) generateSpecFromSecurityRules(rules []core.SecurityRule, nsgId *string) (map[string]infrastructurev1beta2.IngressSecurityRuleForNSG, map[string]infrastructurev1beta2.EgressSecurityRuleForNSG) <span class="cov8" title="1">{
        var ingressRules = make(map[string]infrastructurev1beta2.IngressSecurityRuleForNSG)
        var egressRules = make(map[string]infrastructurev1beta2.EgressSecurityRuleForNSG)
        var stateless *bool
        for _, rule := range rules </span><span class="cov8" title="1">{

                icmpOptions, tcpOptions, udpOptions := getProtocolOptionsForSpec(rule.IcmpOptions, rule.TcpOptions, rule.UdpOptions)
                stateless = rule.IsStateless
                if stateless == nil </span><span class="cov0" title="0">{
                        stateless = common.Bool(false)
                }</span>
                <span class="cov8" title="1">switch rule.Direction </span>{
                case core.SecurityRuleDirectionIngress:<span class="cov8" title="1">
                        ingressRule := infrastructurev1beta2.IngressSecurityRuleForNSG{
                                IngressSecurityRule: infrastructurev1beta2.IngressSecurityRule{
                                        Protocol:    rule.Protocol,
                                        Source:      rule.Source,
                                        IcmpOptions: icmpOptions,
                                        IsStateless: stateless,
                                        SourceType:  infrastructurev1beta2.IngressSecurityRuleSourceTypeEnum(rule.SourceType),
                                        TcpOptions:  tcpOptions,
                                        UdpOptions:  udpOptions,
                                        Description: rule.Description,
                                },
                        }
                        if rule.SourceType == core.SecurityRuleSourceTypeNetworkSecurityGroup </span><span class="cov8" title="1">{
                                ingressRule.IngressSecurityRule.Source = getNsgNameFromId(rule.Source, s.GetNSGSpec())
                        }</span>
                        <span class="cov8" title="1">ingressRules[*rule.Id] = ingressRule</span>
                case core.SecurityRuleDirectionEgress:<span class="cov8" title="1">
                        egressRule := infrastructurev1beta2.EgressSecurityRuleForNSG{
                                EgressSecurityRule: infrastructurev1beta2.EgressSecurityRule{
                                        Destination:     rule.Destination,
                                        Protocol:        rule.Protocol,
                                        DestinationType: infrastructurev1beta2.EgressSecurityRuleDestinationTypeEnum(rule.DestinationType),
                                        IcmpOptions:     icmpOptions,
                                        IsStateless:     stateless,
                                        TcpOptions:      tcpOptions,
                                        UdpOptions:      udpOptions,
                                        Description:     rule.Description,
                                },
                        }
                        if rule.DestinationType == core.SecurityRuleDestinationTypeNetworkSecurityGroup </span><span class="cov8" title="1">{
                                egressRule.EgressSecurityRule.Destination = getNsgNameFromId(rule.Destination, s.GetNSGSpec())
                        }</span>
                        <span class="cov8" title="1">egressRules[*rule.Id] = egressRule</span>
                }
        }
        <span class="cov8" title="1">return ingressRules, egressRules</span>

}

func (s *ClusterScope) AddNSGSecurityRules(ctx context.Context, nsgId *string, ingress []infrastructurev1beta2.IngressSecurityRuleForNSG,
        egress []infrastructurev1beta2.EgressSecurityRuleForNSG) error <span class="cov8" title="1">{
        securityRules := s.generateAddSecurityRuleFromSpec(ingress, egress)

        _, err := s.VCNClient.AddNetworkSecurityGroupSecurityRules(ctx, core.AddNetworkSecurityGroupSecurityRulesRequest{
                NetworkSecurityGroupId: nsgId,
                AddNetworkSecurityGroupSecurityRulesDetails: core.AddNetworkSecurityGroupSecurityRulesDetails{
                        SecurityRules: securityRules,
                },
        })
        if err != nil </span><span class="cov8" title="1">{
                s.Logger.Error(err, "failed add nsg security rules")
                return errors.Wrap(err, "failed add nsg security rules")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (s *ClusterScope) CreateNSG(ctx context.Context, nsg infrastructurev1beta2.NSG) (*string, error) <span class="cov8" title="1">{
        createNetworkSecurityGroupDetails := core.CreateNetworkSecurityGroupDetails{
                CompartmentId: common.String(s.GetCompartmentId()),
                VcnId:         s.getVcnId(),
                DefinedTags:   s.GetDefinedTags(),
                DisplayName:   common.String(nsg.Name),
                FreeformTags:  s.GetFreeFormTags(),
        }
        nsgResponse, err := s.VCNClient.CreateNetworkSecurityGroup(ctx, core.CreateNetworkSecurityGroupRequest{
                CreateNetworkSecurityGroupDetails: createNetworkSecurityGroupDetails,
                RequestMetadata:                   common.RequestMetadata{},
        })
        if err != nil </span><span class="cov8" title="1">{
                s.Logger.Error(err, "failed create nsg")
                return nil, errors.Wrap(err, "failed create nsg")
        }</span>
        <span class="cov0" title="0">s.Logger.Info("successfully created the nsg", "nsg", *nsgResponse.Id)
        return nsgResponse.Id, nil</span>
}

func getProtocolOptionsForSpec(icmp *core.IcmpOptions, tcp *core.TcpOptions, udp *core.UdpOptions) (*infrastructurev1beta2.IcmpOptions, *infrastructurev1beta2.TcpOptions,
        *infrastructurev1beta2.UdpOptions) <span class="cov8" title="1">{
        var icmpOptions *infrastructurev1beta2.IcmpOptions
        var tcpOptions *infrastructurev1beta2.TcpOptions
        var udpOptions *infrastructurev1beta2.UdpOptions
        if icmp != nil </span><span class="cov0" title="0">{
                icmpOptions = &amp;infrastructurev1beta2.IcmpOptions{
                        Type: icmp.Type,
                        Code: icmp.Code,
                }
        }</span>
        <span class="cov8" title="1">if tcp != nil </span><span class="cov8" title="1">{
                tcpOptions = &amp;infrastructurev1beta2.TcpOptions{}
                if tcp.DestinationPortRange != nil </span><span class="cov8" title="1">{
                        tcpOptions.DestinationPortRange = &amp;infrastructurev1beta2.PortRange{}
                        tcpOptions.DestinationPortRange.Max = tcp.DestinationPortRange.Max
                        tcpOptions.DestinationPortRange.Min = tcp.DestinationPortRange.Min
                }</span>
                <span class="cov8" title="1">if tcp.SourcePortRange != nil </span><span class="cov0" title="0">{
                        tcpOptions.SourcePortRange = &amp;infrastructurev1beta2.PortRange{}
                        tcpOptions.SourcePortRange.Max = tcp.SourcePortRange.Max
                        tcpOptions.SourcePortRange.Min = tcp.SourcePortRange.Min
                }</span>
        }
        <span class="cov8" title="1">if udp != nil </span><span class="cov0" title="0">{
                udpOptions = &amp;infrastructurev1beta2.UdpOptions{}
                if udp.DestinationPortRange != nil </span><span class="cov0" title="0">{
                        udpOptions.DestinationPortRange = &amp;infrastructurev1beta2.PortRange{}
                        udpOptions.DestinationPortRange.Max = udp.DestinationPortRange.Max
                        udpOptions.DestinationPortRange.Min = udp.DestinationPortRange.Min
                }</span>
                <span class="cov0" title="0">if udp.SourcePortRange != nil </span><span class="cov0" title="0">{
                        udpOptions.SourcePortRange = &amp;infrastructurev1beta2.PortRange{}
                        udpOptions.SourcePortRange.Max = udp.SourcePortRange.Max
                        udpOptions.SourcePortRange.Min = udp.SourcePortRange.Min
                }</span>
        }
        <span class="cov8" title="1">return icmpOptions, tcpOptions, udpOptions</span>
}

func getNsgIdFromName(nsgName *string, list []*infrastructurev1beta2.NSG) *string <span class="cov8" title="1">{
        nsgSlice := ptr.ToNSGSlice(list)
        for i := range nsgSlice </span><span class="cov8" title="1">{
                if nsgSlice[i].Name == *nsgName </span><span class="cov8" title="1">{
                        return nsgSlice[i].ID
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func getNsgNameFromId(nsgId *string, list []*infrastructurev1beta2.NSG) *string <span class="cov8" title="1">{
        if nsgId == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">nsgSlice := ptr.ToNSGSlice(list)
        for i := range nsgSlice </span><span class="cov8" title="1">{
                nsg := &amp;nsgSlice[i]
                if nsg.ID != nil &amp;&amp; reflect.DeepEqual(nsg.ID, nsgId) </span><span class="cov8" title="1">{
                        return &amp;nsg.Name
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file53" style="display: none">/*
Copyright (c) 2021, 2022 Oracle and/or its affiliates.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package scope

import (
        infrastructurev1beta2 "github.com/oracle/cluster-api-provider-oci/api/v1beta2"
        corev1 "k8s.io/api/core/v1"
        clusterv1 "sigs.k8s.io/cluster-api/api/core/v1beta1"
        "sigs.k8s.io/cluster-api/util/deprecated/v1beta1/conditions"
)

// OCIManagedCluster is the ClusterAccessor implementation for managed clusters(OKE)
type OCIManagedCluster struct {
        OCIManagedCluster *infrastructurev1beta2.OCIManagedCluster
}

func (c OCIManagedCluster) GetNameSpace() string <span class="cov0" title="0">{
        return c.OCIManagedCluster.Namespace
}</span>

func (c OCIManagedCluster) GetRegion() string <span class="cov0" title="0">{
        return c.OCIManagedCluster.Spec.Region
}</span>

func (c OCIManagedCluster) GetClientOverrides() *infrastructurev1beta2.ClientOverrides <span class="cov0" title="0">{
        return c.OCIManagedCluster.Spec.ClientOverrides
}</span>

func (c OCIManagedCluster) MarkConditionFalse(t clusterv1.ConditionType, reason string, severity clusterv1.ConditionSeverity, messageFormat string, messageArgs ...interface{}) <span class="cov0" title="0">{
        conditions.MarkFalse(c.OCIManagedCluster, infrastructurev1beta2.ClusterReadyCondition, reason, severity, messageFormat, messageArgs...)

}</span>

func (c OCIManagedCluster) GetIdentityRef() *corev1.ObjectReference <span class="cov0" title="0">{
        return c.OCIManagedCluster.Spec.IdentityRef
}</span>

func (c OCIManagedCluster) GetOCIResourceIdentifier() string <span class="cov8" title="1">{
        return c.OCIManagedCluster.Spec.OCIResourceIdentifier
}</span>

func (c OCIManagedCluster) GetName() string <span class="cov0" title="0">{
        return c.OCIManagedCluster.Name
}</span>

func (c OCIManagedCluster) GetDefinedTags() map[string]map[string]string <span class="cov8" title="1">{
        return c.OCIManagedCluster.Spec.DefinedTags
}</span>

func (c OCIManagedCluster) GetCompartmentId() string <span class="cov8" title="1">{
        return c.OCIManagedCluster.Spec.CompartmentId
}</span>

func (c OCIManagedCluster) GetFreeformTags() map[string]string <span class="cov8" title="1">{
        return c.OCIManagedCluster.Spec.FreeformTags
}</span>

func (c OCIManagedCluster) GetDRG() *infrastructurev1beta2.DRG <span class="cov0" title="0">{
        return c.OCIManagedCluster.Spec.NetworkSpec.VCNPeering.DRG
}</span>

func (c OCIManagedCluster) GetVCNPeering() *infrastructurev1beta2.VCNPeering <span class="cov0" title="0">{
        return c.OCIManagedCluster.Spec.NetworkSpec.VCNPeering
}</span>

func (c OCIManagedCluster) GetNetworkSpec() *infrastructurev1beta2.NetworkSpec <span class="cov8" title="1">{
        return &amp;c.OCIManagedCluster.Spec.NetworkSpec
}</span>

func (c OCIManagedCluster) SetControlPlaneEndpoint(endpoint clusterv1.APIEndpoint) <span class="cov0" title="0">{
        c.OCIManagedCluster.Spec.ControlPlaneEndpoint = endpoint
}</span>

func (c OCIManagedCluster) GetControlPlaneEndpoint() clusterv1.APIEndpoint <span class="cov0" title="0">{
        return c.OCIManagedCluster.Spec.ControlPlaneEndpoint
}</span>

func (c OCIManagedCluster) GetFailureDomains() clusterv1.FailureDomains <span class="cov0" title="0">{
        return c.OCIManagedCluster.Status.FailureDomains
}</span>

func (c OCIManagedCluster) SetFailureDomain(id string, spec clusterv1.FailureDomainSpec) <span class="cov0" title="0">{
        if c.OCIManagedCluster.Status.FailureDomains == nil </span><span class="cov0" title="0">{
                c.OCIManagedCluster.Status.FailureDomains = make(clusterv1.FailureDomains)
        }</span>
        <span class="cov0" title="0">c.OCIManagedCluster.Status.FailureDomains[id] = spec</span>
}
func (c OCIManagedCluster) GetAvailabilityDomains() map[string]infrastructurev1beta2.OCIAvailabilityDomain <span class="cov0" title="0">{
        return c.OCIManagedCluster.Spec.AvailabilityDomains
}</span>
func (c OCIManagedCluster) SetAvailabilityDomains(ads map[string]infrastructurev1beta2.OCIAvailabilityDomain) <span class="cov0" title="0">{
        c.OCIManagedCluster.Spec.AvailabilityDomains = ads
}</span>

func (c OCIManagedCluster) GetProviderID(instanceId string) string <span class="cov0" title="0">{
        return instanceId
}</span>
</pre>
		
		<pre class="file" id="file54" style="display: none">/*
Copyright (c) 2021, 2022 Oracle and/or its affiliates.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package scope

import (
        "fmt"
        infrastructurev1beta2 "github.com/oracle/cluster-api-provider-oci/api/v1beta2"
        corev1 "k8s.io/api/core/v1"
        clusterv1 "sigs.k8s.io/cluster-api/api/core/v1beta1"
        "sigs.k8s.io/cluster-api/util/deprecated/v1beta1/conditions"
)

// OCISelfManagedCluster is the ClusterAccessor implementation for self managed clusters
type OCISelfManagedCluster struct {
        OCICluster *infrastructurev1beta2.OCICluster
}

func (c OCISelfManagedCluster) GetNameSpace() string <span class="cov0" title="0">{
        return c.OCICluster.Namespace
}</span>

func (c OCISelfManagedCluster) GetRegion() string <span class="cov0" title="0">{
        return c.OCICluster.Spec.Region
}</span>

func (c OCISelfManagedCluster) GetClientOverrides() *infrastructurev1beta2.ClientOverrides <span class="cov0" title="0">{
        return c.OCICluster.Spec.ClientOverrides
}</span>

func (c OCISelfManagedCluster) GetIdentityRef() *corev1.ObjectReference <span class="cov0" title="0">{
        return c.OCICluster.Spec.IdentityRef
}</span>

func (c OCISelfManagedCluster) MarkConditionFalse(t clusterv1.ConditionType, reason string, severity clusterv1.ConditionSeverity, messageFormat string, messageArgs ...interface{}) <span class="cov0" title="0">{
        conditions.MarkFalse(c.OCICluster, infrastructurev1beta2.ClusterReadyCondition, reason, severity, messageFormat, messageArgs...)
}</span>

func (c OCISelfManagedCluster) GetOCIResourceIdentifier() string <span class="cov8" title="1">{
        return c.OCICluster.Spec.OCIResourceIdentifier
}</span>

func (c OCISelfManagedCluster) GetName() string <span class="cov8" title="1">{
        return c.OCICluster.Name
}</span>

func (c OCISelfManagedCluster) GetDefinedTags() map[string]map[string]string <span class="cov8" title="1">{
        return c.OCICluster.Spec.DefinedTags
}</span>

func (c OCISelfManagedCluster) GetCompartmentId() string <span class="cov8" title="1">{
        return c.OCICluster.Spec.CompartmentId
}</span>

func (c OCISelfManagedCluster) GetFreeformTags() map[string]string <span class="cov8" title="1">{
        return c.OCICluster.Spec.FreeformTags
}</span>

func (c OCISelfManagedCluster) GetDRG() *infrastructurev1beta2.DRG <span class="cov0" title="0">{
        return c.OCICluster.Spec.NetworkSpec.VCNPeering.DRG
}</span>

func (c OCISelfManagedCluster) GetVCNPeering() *infrastructurev1beta2.VCNPeering <span class="cov0" title="0">{
        return c.OCICluster.Spec.NetworkSpec.VCNPeering
}</span>

func (c OCISelfManagedCluster) GetNetworkSpec() *infrastructurev1beta2.NetworkSpec <span class="cov8" title="1">{
        return &amp;c.OCICluster.Spec.NetworkSpec
}</span>

func (c OCISelfManagedCluster) SetControlPlaneEndpoint(endpoint clusterv1.APIEndpoint) <span class="cov8" title="1">{
        c.OCICluster.Spec.ControlPlaneEndpoint = endpoint
}</span>

func (c OCISelfManagedCluster) GetFailureDomains() clusterv1.FailureDomains <span class="cov8" title="1">{
        return c.OCICluster.Status.FailureDomains
}</span>

func (c OCISelfManagedCluster) SetFailureDomain(id string, spec clusterv1.FailureDomainSpec) <span class="cov8" title="1">{
        if c.OCICluster.Status.FailureDomains == nil </span><span class="cov8" title="1">{
                c.OCICluster.Status.FailureDomains = make(clusterv1.FailureDomains)
        }</span>
        <span class="cov8" title="1">c.OCICluster.Status.FailureDomains[id] = spec</span>
}

func (c OCISelfManagedCluster) GetAvailabilityDomains() map[string]infrastructurev1beta2.OCIAvailabilityDomain <span class="cov8" title="1">{
        return c.OCICluster.Spec.AvailabilityDomains
}</span>
func (c OCISelfManagedCluster) SetAvailabilityDomains(ads map[string]infrastructurev1beta2.OCIAvailabilityDomain) <span class="cov8" title="1">{
        c.OCICluster.Spec.AvailabilityDomains = ads
}</span>

func (c OCISelfManagedCluster) GetControlPlaneEndpoint() clusterv1.APIEndpoint <span class="cov8" title="1">{
        return c.OCICluster.Spec.ControlPlaneEndpoint
}</span>

func (c OCISelfManagedCluster) GetProviderID(instanceId string) string <span class="cov0" title="0">{
        return fmt.Sprintf("oci://%s", instanceId)
}</span>
</pre>
		
		<pre class="file" id="file55" style="display: none">/*
 Copyright (c) 2021, 2022 Oracle and/or its affiliates.

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

      https://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
*/

package scope

import (
        "context"
        "fmt"
        "strings"

        infrastructurev1beta2 "github.com/oracle/cluster-api-provider-oci/api/v1beta2"
        "github.com/oracle/cluster-api-provider-oci/cloud/ociutil"
        "github.com/oracle/oci-go-sdk/v65/common"
        "github.com/oracle/oci-go-sdk/v65/core"
        "github.com/pkg/errors"
)

func (s *ClusterScope) ReconcileRouteTable(ctx context.Context) error <span class="cov8" title="1">{
        if s.OCIClusterAccessor.GetNetworkSpec().Vcn.RouteTable.Skip </span><span class="cov8" title="1">{
                s.Logger.Info("Skipping Route table reconciliation as per spec")
                return nil
        }</span>
        <span class="cov8" title="1">desiredRouteTables := s.GetDesiredRouteTables()
        for _, rt := range desiredRouteTables </span><span class="cov8" title="1">{
                routeTable, err := s.getRouteTable(ctx, rt)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">if routeTable != nil </span><span class="cov8" title="1">{
                        routeTableOCID := routeTable.Id
                        s.setRTStatus(routeTableOCID, rt)
                        s.Logger.Info("No Reconciliation Required for Route Table", "route-table", routeTableOCID)
                        continue</span>
                }

                <span class="cov8" title="1">s.Logger.Info("Creating the route table")
                rtId, err := s.CreateRouteTable(ctx, rt)
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
                <span class="cov8" title="1">s.Logger.Info("Created the route table", "route-table", rtId)
                s.setRTStatus(rtId, rt)</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (s *ClusterScope) GetDesiredRouteTables() []string <span class="cov8" title="1">{
        var desiredRouteTables []string
        if s.IsAllSubnetsPrivate() </span><span class="cov8" title="1">{
                desiredRouteTables = []string{infrastructurev1beta2.Private}
        }</span> else<span class="cov8" title="1"> if s.IsAllSubnetsPublic() </span><span class="cov8" title="1">{
                desiredRouteTables = []string{infrastructurev1beta2.Public}
        }</span> else<span class="cov8" title="1"> {
                desiredRouteTables = []string{infrastructurev1beta2.Private, infrastructurev1beta2.Public}
        }</span>
        <span class="cov8" title="1">return desiredRouteTables</span>
}

// nolint:nilnil
func (s *ClusterScope) getRouteTable(ctx context.Context, routeTableType string) (*core.RouteTable, error) <span class="cov8" title="1">{
        routeTableId := s.OCIClusterAccessor.GetNetworkSpec().Vcn.RouteTable.PublicRouteTableId
        if routeTableType == infrastructurev1beta2.Private </span><span class="cov8" title="1">{
                routeTableId = s.OCIClusterAccessor.GetNetworkSpec().Vcn.RouteTable.PrivateRouteTableId
        }</span>
        <span class="cov8" title="1">if routeTableId != nil </span><span class="cov8" title="1">{
                resp, err := s.VCNClient.GetRouteTable(ctx, core.GetRouteTableRequest{
                        RtId: routeTableId,
                })
                if err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">rt := resp.RouteTable
                if s.IsResourceCreatedByClusterAPI(rt.FreeformTags) </span><span class="cov8" title="1">{
                        return &amp;rt, nil
                }</span> else<span class="cov0" title="0"> {
                        return nil, errors.New("cluster api tags have been modified out of context")
                }</span>

        }
        <span class="cov8" title="1">vcnId := s.getVcnId()
        routeTableName := PublicRouteTableName
        if routeTableType == infrastructurev1beta2.Private </span><span class="cov8" title="1">{
                routeTableName = PrivateRouteTableName
        }</span>

        <span class="cov8" title="1">rts, err := s.VCNClient.ListRouteTables(ctx, core.ListRouteTablesRequest{
                CompartmentId: common.String(s.GetCompartmentId()),
                VcnId:         vcnId,
                DisplayName:   common.String(routeTableName),
        })
        if err != nil </span><span class="cov0" title="0">{
                s.Logger.Error(err, "failed to list route tables")
                return nil, errors.Wrap(err, "failed to list route tables")
        }</span>
        <span class="cov8" title="1">for _, rt := range rts.Items </span><span class="cov8" title="1">{
                if s.IsResourceCreatedByClusterAPI(rt.FreeformTags) </span><span class="cov8" title="1">{
                        return &amp;rt, nil
                }</span>
        }

        <span class="cov8" title="1">return nil, nil</span>
}

func (s *ClusterScope) CreateRouteTable(ctx context.Context, routeTableType string) (*string, error) <span class="cov8" title="1">{
        var routeRules []core.RouteRule
        var routeTableName string
        if routeTableType == infrastructurev1beta2.Private </span><span class="cov8" title="1">{
                routeRules = []core.RouteRule{
                        {
                                DestinationType: core.RouteRuleDestinationTypeCidrBlock,
                                Destination:     common.String("0.0.0.0/0"),
                                NetworkEntityId: s.OCIClusterAccessor.GetNetworkSpec().Vcn.NATGateway.Id,
                                Description:     common.String("traffic to the internet"),
                        },
                        {
                                DestinationType: core.RouteRuleDestinationTypeServiceCidrBlock,
                                Destination:     common.String(fmt.Sprintf("all-%s-services-in-oracle-services-network", strings.ToLower(s.RegionKey))),
                                NetworkEntityId: s.OCIClusterAccessor.GetNetworkSpec().Vcn.ServiceGateway.Id,
                                Description:     common.String("traffic to OCI services"),
                        },
                }
                vcnPeering := s.OCIClusterAccessor.GetNetworkSpec().VCNPeering
                if vcnPeering != nil </span><span class="cov8" title="1">{
                        if s.getDRG() == nil </span><span class="cov8" title="1">{
                                return nil, errors.New("Create Route Table: DRG has not been specified")
                        }</span>
                        <span class="cov8" title="1">if s.getDrgID() == nil </span><span class="cov8" title="1">{
                                return nil, errors.New("Create Route Table: DRG ID has not been set")
                        }</span>

                        <span class="cov8" title="1">for _, routeRule := range vcnPeering.PeerRouteRules </span><span class="cov8" title="1">{
                                routeRules = append(routeRules, core.RouteRule{
                                        DestinationType: core.RouteRuleDestinationTypeCidrBlock,
                                        Destination:     common.String(routeRule.VCNCIDRRange),
                                        NetworkEntityId: s.getDrgID(),
                                        Description:     common.String("traffic to peer DRG"),
                                })
                        }</span>
                }

                <span class="cov8" title="1">routeTableName = PrivateRouteTableName</span>
        } else<span class="cov8" title="1"> {
                routeRules = []core.RouteRule{
                        {
                                DestinationType: core.RouteRuleDestinationTypeCidrBlock,
                                Destination:     common.String("0.0.0.0/0"),
                                NetworkEntityId: s.OCIClusterAccessor.GetNetworkSpec().Vcn.InternetGateway.Id,
                                Description:     common.String("traffic to/from internet"),
                        },
                }
                resp, err := s.VCNClient.GetVcn(ctx, core.GetVcnRequest{VcnId: s.getVcnId()})
                if err != nil </span><span class="cov0" title="0">{
                        s.Logger.Error(err, "failed to get VCN")
                        return nil, errors.Wrap(err, "failed to get VCN for route table creation")
                }</span>
                <span class="cov8" title="1">if resp.Vcn.Ipv6CidrBlocks != nil </span><span class="cov0" title="0">{
                        routeRules = append(routeRules, core.RouteRule{
                                DestinationType: core.RouteRuleDestinationTypeCidrBlock,
                                Destination:     common.String("::/0"),
                                NetworkEntityId: s.OCIClusterAccessor.GetNetworkSpec().Vcn.InternetGateway.Id,
                                Description:     common.String("ipv6 traffic to/from internet"),
                        })
                }</span>
                <span class="cov8" title="1">routeTableName = PublicRouteTableName</span>
        }
        <span class="cov8" title="1">vcnId := s.getVcnId()
        routeTableDetails := core.CreateRouteTableDetails{
                VcnId:         vcnId,
                CompartmentId: common.String(s.GetCompartmentId()),
                DisplayName:   common.String(routeTableName),
                RouteRules:    routeRules,
                FreeformTags:  s.GetFreeFormTags(),
                DefinedTags:   s.GetDefinedTags(),
        }
        routeTableResponse, err := s.VCNClient.CreateRouteTable(ctx, core.CreateRouteTableRequest{
                CreateRouteTableDetails: routeTableDetails,
        })
        if err != nil </span><span class="cov8" title="1">{
                s.Logger.Error(err, "failed create route table")
                return nil, errors.Wrap(err, "failed create route table")
        }</span>
        <span class="cov8" title="1">s.Logger.Info("successfully created the route table", "route-table", *routeTableResponse.Id)
        return routeTableResponse.Id, nil</span>
}

func (s *ClusterScope) setRTStatus(id *string, routeTableType string) <span class="cov8" title="1">{
        if routeTableType == infrastructurev1beta2.Private </span><span class="cov8" title="1">{
                s.OCIClusterAccessor.GetNetworkSpec().Vcn.RouteTable.PrivateRouteTableId = id
                return
        }</span>
        <span class="cov8" title="1">s.OCIClusterAccessor.GetNetworkSpec().Vcn.RouteTable.PublicRouteTableId = id</span>
}

func (s *ClusterScope) DeleteRouteTables(ctx context.Context) error <span class="cov8" title="1">{
        if s.OCIClusterAccessor.GetNetworkSpec().Vcn.RouteTable.Skip </span><span class="cov0" title="0">{
                s.Logger.Info("Skipping Route table reconciliation as per spec")
                return nil
        }</span>
        <span class="cov8" title="1">desiredRouteTables := s.GetDesiredRouteTables()
        for _, routeTable := range desiredRouteTables </span><span class="cov8" title="1">{
                rt, err := s.getRouteTable(ctx, routeTable)
                if err != nil &amp;&amp; !ociutil.IsNotFound(err) </span><span class="cov8" title="1">{
                        return err
                }</span>
                <span class="cov8" title="1">if rt == nil </span><span class="cov8" title="1">{
                        s.Logger.Info("Route Table is already deleted", "rt", routeTable)
                        continue</span>
                }
                <span class="cov8" title="1">_, err = s.VCNClient.DeleteRouteTable(ctx, core.DeleteRouteTableRequest{
                        RtId: rt.Id,
                })
                if err != nil </span><span class="cov8" title="1">{
                        s.Logger.Error(err, "failed to delete route table")
                        return errors.Wrap(err, "failed to delete route table")
                }</span>
                <span class="cov8" title="1">s.Logger.Info("successfully deleted route table", "route-table", *rt.Id)</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (s *ClusterScope) getRouteTableId(routeTableType string) *string <span class="cov8" title="1">{
        if routeTableType == infrastructurev1beta2.Private </span><span class="cov8" title="1">{
                return s.OCIClusterAccessor.GetNetworkSpec().Vcn.RouteTable.PrivateRouteTableId
        }</span>
        <span class="cov8" title="1">return s.OCIClusterAccessor.GetNetworkSpec().Vcn.RouteTable.PublicRouteTableId</span>
}
</pre>
		
		<pre class="file" id="file56" style="display: none">/*
 Copyright (c) 2021, 2022 Oracle and/or its affiliates.

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

      https://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
*/

package scope

import (
        "context"
        "reflect"

        "github.com/oracle/cluster-api-provider-oci/cloud/ociutil"
        "github.com/oracle/cluster-api-provider-oci/cloud/ociutil/ptr"

        infrastructurev1beta2 "github.com/oracle/cluster-api-provider-oci/api/v1beta2"
        "github.com/oracle/oci-go-sdk/v65/common"
        "github.com/oracle/oci-go-sdk/v65/core"
        "github.com/pkg/errors"
)

func (s *ClusterScope) DeleteSecurityLists(ctx context.Context) error <span class="cov8" title="1">{
        desiredSubnets := ptr.ToSubnetSlice(s.GetSubnetsSpec())
        for _, desiredSubnet := range desiredSubnets </span><span class="cov8" title="1">{
                if desiredSubnet.SecurityList != nil </span><span class="cov8" title="1">{
                        securityList, err := s.GetSecurityList(ctx, *desiredSubnet.SecurityList)
                        if err != nil &amp;&amp; !ociutil.IsNotFound(err) </span><span class="cov8" title="1">{
                                return err
                        }</span>
                        <span class="cov8" title="1">if securityList == nil </span><span class="cov8" title="1">{
                                s.Logger.Info("security list is already deleted", "securityList", desiredSubnet.SecurityList.Name)
                                continue</span>
                        }
                        <span class="cov8" title="1">_, err = s.VCNClient.DeleteSecurityList(ctx, core.DeleteSecurityListRequest{
                                SecurityListId: securityList.Id,
                        })
                        if err != nil </span><span class="cov8" title="1">{
                                s.Logger.Error(err, "failed to delete security list")
                                return errors.Wrap(err, "failed to delete security list")
                        }</span>
                        <span class="cov8" title="1">s.Logger.Info("Successfully deleted security list", "subnet", desiredSubnet.SecurityList.Name)</span>
                }
        }
        <span class="cov8" title="1">return nil</span>
}

func (s *ClusterScope) CreateSecurityList(ctx context.Context, secList infrastructurev1beta2.SecurityList) (*string, error) <span class="cov8" title="1">{
        var ingressRules []core.IngressSecurityRule
        var egressRules []core.EgressSecurityRule
        for _, rule := range secList.EgressRules </span><span class="cov8" title="1">{
                egressRules = append(egressRules, convertSecurityListEgressRule(rule))
        }</span>
        <span class="cov8" title="1">for _, rule := range secList.IngressRules </span><span class="cov8" title="1">{
                ingressRules = append(ingressRules, convertSecurityListIngressRule(rule))
        }</span>
        <span class="cov8" title="1">if ingressRules == nil </span><span class="cov0" title="0">{
                ingressRules = []core.IngressSecurityRule{}
        }</span>
        <span class="cov8" title="1">if egressRules == nil </span><span class="cov0" title="0">{
                egressRules = []core.EgressSecurityRule{}
        }</span>
        <span class="cov8" title="1">securityListDetails := core.CreateSecurityListDetails{
                VcnId:                s.getVcnId(),
                CompartmentId:        common.String(s.GetCompartmentId()),
                DisplayName:          common.String(secList.Name),
                EgressSecurityRules:  egressRules,
                IngressSecurityRules: ingressRules,
                FreeformTags:         s.GetFreeFormTags(),
                DefinedTags:          s.GetDefinedTags(),
        }
        securityListResponse, err := s.VCNClient.CreateSecurityList(ctx, core.CreateSecurityListRequest{
                CreateSecurityListDetails: securityListDetails,
        })
        if err != nil </span><span class="cov8" title="1">{
                s.Logger.Error(err, "failed create security list")
                return nil, errors.Wrap(err, "failed create security list")
        }</span>
        <span class="cov8" title="1">s.Logger.Info("successfully created the security list", "security-list", *securityListResponse.Id)
        return securityListResponse.Id, nil</span>
}

func (s *ClusterScope) IsSecurityListEqual(actual core.SecurityList, desired infrastructurev1beta2.SecurityList) bool <span class="cov8" title="1">{
        if *actual.DisplayName != desired.Name </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">if len(actual.IngressSecurityRules) != len(desired.IngressRules) </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov0" title="0">if len(actual.EgressSecurityRules) != len(desired.EgressRules) </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">for _, rule := range desired.IngressRules </span><span class="cov0" title="0">{
                found := false
                for _, existingRule := range actual.IngressSecurityRules </span><span class="cov0" title="0">{
                        if reflect.DeepEqual(existingRule, convertSecurityListIngressRule(rule)) </span><span class="cov0" title="0">{
                                found = true
                                break</span>
                        }
                }
                <span class="cov0" title="0">if !found </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov0" title="0">for _, rule := range desired.EgressRules </span><span class="cov0" title="0">{
                found := false
                for _, existingRule := range actual.EgressSecurityRules </span><span class="cov0" title="0">{
                        if reflect.DeepEqual(existingRule, convertSecurityListEgressRule(rule)) </span><span class="cov0" title="0">{
                                found = true
                                break</span>
                        }
                }
                <span class="cov0" title="0">if !found </span><span class="cov0" title="0">{
                        return false
                }</span>
        }
        <span class="cov0" title="0">return true</span>
}

func (s *ClusterScope) UpdateSecurityList(ctx context.Context, securityListSpec infrastructurev1beta2.SecurityList) error <span class="cov8" title="1">{
        var ingressRules []core.IngressSecurityRule
        var egressRules []core.EgressSecurityRule

        if securityListSpec.ID == nil </span><span class="cov8" title="1">{
                return errors.New("Update Security List failed: unable to update with a nil ID")
        }</span>

        <span class="cov8" title="1">for _, rule := range securityListSpec.EgressRules </span><span class="cov8" title="1">{
                egressRules = append(egressRules, convertSecurityListEgressRule(rule))
        }</span>
        <span class="cov8" title="1">for _, rule := range securityListSpec.IngressRules </span><span class="cov8" title="1">{
                ingressRules = append(ingressRules, convertSecurityListIngressRule(rule))
        }</span>
        <span class="cov8" title="1">if ingressRules == nil </span><span class="cov8" title="1">{
                ingressRules = []core.IngressSecurityRule{}
        }</span>
        <span class="cov8" title="1">if egressRules == nil </span><span class="cov8" title="1">{
                egressRules = []core.EgressSecurityRule{}
        }</span>
        <span class="cov8" title="1">updateSecurityListDetails := core.UpdateSecurityListDetails{
                DisplayName:          common.String(securityListSpec.Name),
                EgressSecurityRules:  egressRules,
                IngressSecurityRules: ingressRules,
        }
        securityListResponse, err := s.VCNClient.UpdateSecurityList(ctx, core.UpdateSecurityListRequest{
                UpdateSecurityListDetails: updateSecurityListDetails,
                SecurityListId:            common.String(*securityListSpec.ID),
        })
        if err != nil </span><span class="cov8" title="1">{
                s.Logger.Error(err, "failed to reconcile the security list, failed to update")
                return errors.Wrap(err, "failed to reconcile the security list, failed to update")
        }</span>
        <span class="cov8" title="1">s.Logger.Info("successfully updated the security list", "security list", *securityListResponse.Id)
        return nil</span>
}

func convertSecurityListIngressRule(rule infrastructurev1beta2.IngressSecurityRule) core.IngressSecurityRule <span class="cov8" title="1">{
        var icmpOptions *core.IcmpOptions
        var tcpOptions *core.TcpOptions
        var udpOptions *core.UdpOptions
        icmpOptions, tcpOptions, udpOptions = getProtocolOptions(rule.IcmpOptions, rule.TcpOptions, rule.UdpOptions)

        // while comparing values, the boolean value has to be always set
        stateless := rule.IsStateless
        if stateless == nil </span><span class="cov8" title="1">{
                stateless = common.Bool(false)
        }</span>
        <span class="cov8" title="1">return core.IngressSecurityRule{
                Protocol:    rule.Protocol,
                Source:      rule.Source,
                IcmpOptions: icmpOptions,
                IsStateless: stateless,
                SourceType:  core.IngressSecurityRuleSourceTypeEnum(rule.SourceType),
                TcpOptions:  tcpOptions,
                UdpOptions:  udpOptions,
                Description: rule.Description,
        }</span>
}

func convertSecurityListEgressRule(rule infrastructurev1beta2.EgressSecurityRule) core.EgressSecurityRule <span class="cov8" title="1">{
        var icmpOptions *core.IcmpOptions
        var tcpOptions *core.TcpOptions
        var udpOptions *core.UdpOptions

        // while comparing values, the boolean value has to be always set
        stateless := rule.IsStateless
        if stateless == nil </span><span class="cov8" title="1">{
                stateless = common.Bool(false)
        }</span>
        <span class="cov8" title="1">icmpOptions, tcpOptions, udpOptions = getProtocolOptions(rule.IcmpOptions, rule.TcpOptions, rule.UdpOptions)
        return core.EgressSecurityRule{
                Protocol:        rule.Protocol,
                Destination:     rule.Destination,
                IcmpOptions:     icmpOptions,
                IsStateless:     stateless,
                DestinationType: core.EgressSecurityRuleDestinationTypeEnum(rule.DestinationType),
                TcpOptions:      tcpOptions,
                UdpOptions:      udpOptions,
                Description:     rule.Description,
        }</span>
}

func getProtocolOptions(icmp *infrastructurev1beta2.IcmpOptions, tcp *infrastructurev1beta2.TcpOptions,
        udp *infrastructurev1beta2.UdpOptions) (*core.IcmpOptions, *core.TcpOptions, *core.UdpOptions) <span class="cov8" title="1">{
        var icmpOptions *core.IcmpOptions
        var tcpOptions *core.TcpOptions
        var udpOptions *core.UdpOptions
        if icmp != nil </span><span class="cov0" title="0">{
                icmpOptions = &amp;core.IcmpOptions{
                        Type: icmp.Type,
                        Code: icmp.Code,
                }
        }</span>
        <span class="cov8" title="1">if tcp != nil </span><span class="cov8" title="1">{
                tcpOptions = &amp;core.TcpOptions{}
                if tcp.DestinationPortRange != nil </span><span class="cov8" title="1">{
                        tcpOptions.DestinationPortRange = &amp;core.PortRange{}
                        tcpOptions.DestinationPortRange.Max = tcp.DestinationPortRange.Max
                        tcpOptions.DestinationPortRange.Min = tcp.DestinationPortRange.Min
                }</span>
                <span class="cov8" title="1">if tcp.SourcePortRange != nil </span><span class="cov0" title="0">{
                        tcpOptions.SourcePortRange = &amp;core.PortRange{}
                        tcpOptions.SourcePortRange.Max = tcp.SourcePortRange.Max
                        tcpOptions.SourcePortRange.Min = tcp.SourcePortRange.Min
                }</span>
        }
        <span class="cov8" title="1">if udp != nil </span><span class="cov0" title="0">{
                udpOptions = &amp;core.UdpOptions{}
                if udp.DestinationPortRange != nil </span><span class="cov0" title="0">{
                        udpOptions.DestinationPortRange = &amp;core.PortRange{}
                        udpOptions.DestinationPortRange.Max = udp.DestinationPortRange.Max
                        udpOptions.DestinationPortRange.Min = udp.DestinationPortRange.Min
                }</span>
                <span class="cov0" title="0">if udp.SourcePortRange != nil </span><span class="cov0" title="0">{
                        udpOptions.SourcePortRange = &amp;core.PortRange{}
                        udpOptions.SourcePortRange.Max = udp.SourcePortRange.Max
                        udpOptions.SourcePortRange.Min = udp.SourcePortRange.Min
                }</span>
        }
        <span class="cov8" title="1">return icmpOptions, tcpOptions, udpOptions</span>
}

func (s *ClusterScope) IsSecurityListExitsByRole(role infrastructurev1beta2.Role) bool <span class="cov0" title="0">{
        for _, subnet := range ptr.ToSubnetSlice(s.GetSubnetsSpec()) </span><span class="cov0" title="0">{
                if role == subnet.Role </span><span class="cov0" title="0">{
                        if subnet.SecurityList != nil </span><span class="cov0" title="0">{
                                return true
                        }</span>
                }
        }
        <span class="cov0" title="0">return false</span>
}

// nolint:nilnil
func (s *ClusterScope) GetSecurityList(ctx context.Context, spec infrastructurev1beta2.SecurityList) (*core.SecurityList, error) <span class="cov8" title="1">{
        securityListOcid := spec.ID
        if securityListOcid != nil </span><span class="cov8" title="1">{
                resp, err := s.VCNClient.GetSecurityList(ctx, core.GetSecurityListRequest{
                        SecurityListId: securityListOcid,
                })
                if err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">securityList := resp.SecurityList
                if s.IsResourceCreatedByClusterAPI(securityList.FreeformTags) </span><span class="cov8" title="1">{
                        return &amp;securityList, nil
                }</span> else<span class="cov0" title="0"> {
                        return nil, errors.New("cluster api tags have been modified out of context")
                }</span>
        }
        <span class="cov8" title="1">securityLists, err := s.VCNClient.ListSecurityLists(ctx, core.ListSecurityListsRequest{
                CompartmentId: common.String(s.GetCompartmentId()),
                VcnId:         s.getVcnId(),
                DisplayName:   common.String(spec.Name),
        })
        if err != nil </span><span class="cov0" title="0">{
                s.Logger.Error(err, "failed to list security lists")
                return nil, errors.Wrap(err, "failed to list security lists")
        }</span>
        <span class="cov8" title="1">for _, securityList := range securityLists.Items </span><span class="cov0" title="0">{
                if s.IsResourceCreatedByClusterAPI(securityList.FreeformTags) </span><span class="cov0" title="0">{
                        return &amp;securityList, nil
                }</span>
        }
        <span class="cov8" title="1">return nil, nil</span>
}
</pre>
		
		<pre class="file" id="file57" style="display: none">/*
 Copyright (c) 2021, 2022 Oracle and/or its affiliates.

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

      https://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
*/

package scope

import (
        "context"
        "strings"

        "github.com/oracle/cluster-api-provider-oci/cloud/ociutil"
        "github.com/oracle/oci-go-sdk/v65/common"
        "github.com/oracle/oci-go-sdk/v65/core"
        "github.com/pkg/errors"
)

func (s *ClusterScope) ReconcileServiceGateway(ctx context.Context) error <span class="cov8" title="1">{
        if s.OCIClusterAccessor.GetNetworkSpec().Vcn.ServiceGateway.Skip </span><span class="cov0" title="0">{
                s.Logger.Info("Skipping Service Gateway reconciliation as per spec")
                return nil
        }</span>
        <span class="cov8" title="1">if s.IsAllSubnetsPublic() </span><span class="cov8" title="1">{
                s.Logger.Info("All subnets are public, we don't need service gateway")
                return nil
        }</span>
        <span class="cov8" title="1">var err error
        sgw, err := s.GetServiceGateway(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if sgw != nil </span><span class="cov8" title="1">{
                s.OCIClusterAccessor.GetNetworkSpec().Vcn.ServiceGateway.Id = sgw.Id
                s.Logger.Info("No Reconciliation Required for Service Gateway", "service_gateway", sgw.Id)
                return nil
        }</span>
        <span class="cov8" title="1">serviceGateway, err := s.CreateServiceGateway(ctx)
        s.OCIClusterAccessor.GetNetworkSpec().Vcn.ServiceGateway.Id = serviceGateway
        return err</span>
}

func (s *ClusterScope) CreateServiceGateway(ctx context.Context) (*string, error) <span class="cov8" title="1">{
        var serviceOcid string
        var isServiceFound bool
        listServicesResponse, err := s.VCNClient.ListServices(ctx, core.ListServicesRequest{})
        if err != nil </span><span class="cov0" title="0">{
                s.Logger.Error(err, "failed to get the list of services")
                return nil, errors.Wrap(err, "failed to get the list of services")
        }</span>
        <span class="cov8" title="1">for _, service := range listServicesResponse.Items </span><span class="cov8" title="1">{
                if strings.HasSuffix(*service.CidrBlock, SGWServiceSuffix) </span><span class="cov8" title="1">{
                        serviceOcid = *service.Id
                        isServiceFound = true
                        break</span>
                }
        }
        <span class="cov8" title="1">if !isServiceFound </span><span class="cov0" title="0">{
                s.Logger.Error(err, "failed to get the services ocid")
                return nil, errors.Wrap(err, "failed to get the services ocid")
        }</span>

        <span class="cov8" title="1">sgwDetails := core.CreateServiceGatewayDetails{
                CompartmentId: common.String(s.GetCompartmentId()),
                DisplayName:   common.String(ServiceGatewayName),
                VcnId:         s.getVcnId(),
                Services:      []core.ServiceIdRequestDetails{{ServiceId: common.String(serviceOcid)}},
                FreeformTags:  s.GetFreeFormTags(),
                DefinedTags:   s.GetDefinedTags(),
        }
        sgwResponse, err := s.VCNClient.CreateServiceGateway(ctx, core.CreateServiceGatewayRequest{
                CreateServiceGatewayDetails: sgwDetails,
        })
        if err != nil </span><span class="cov8" title="1">{
                s.Logger.Error(err, "failed create service gateway")
                return nil, errors.Wrap(err, "failed create service gateway")
        }</span>
        <span class="cov8" title="1">s.Logger.Info("successfully created the service gateway", "ngw", *sgwResponse.Id)
        return sgwResponse.Id, nil</span>
}

func (s *ClusterScope) DeleteServiceGateway(ctx context.Context) error <span class="cov8" title="1">{
        if s.OCIClusterAccessor.GetNetworkSpec().Vcn.ServiceGateway.Skip </span><span class="cov0" title="0">{
                s.Logger.Info("Skipping Service Gateway reconciliation as per spec")
                return nil
        }</span>
        <span class="cov8" title="1">sgw, err := s.GetServiceGateway(ctx)
        if err != nil &amp;&amp; !ociutil.IsNotFound(err) </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">if sgw == nil </span><span class="cov8" title="1">{
                s.Logger.Info("Service Gateway is already deleted")
                return nil
        }</span>
        <span class="cov8" title="1">_, err = s.VCNClient.DeleteServiceGateway(ctx, core.DeleteServiceGatewayRequest{
                ServiceGatewayId: sgw.Id,
        })
        if err != nil </span><span class="cov8" title="1">{
                s.Logger.Error(err, "failed to delete ServiceGateways")
                return errors.Wrap(err, "failed to delete ServiceGateways")
        }</span>
        <span class="cov8" title="1">s.Logger.Info("successfully deleted ServiceGateway", "subnet", *sgw.Id)
        return nil</span>
}

// nolint:nilnil
func (s *ClusterScope) GetServiceGateway(ctx context.Context) (*core.ServiceGateway, error) <span class="cov8" title="1">{
        sgwId := s.OCIClusterAccessor.GetNetworkSpec().Vcn.ServiceGateway.Id
        if sgwId != nil </span><span class="cov8" title="1">{
                resp, err := s.VCNClient.GetServiceGateway(ctx, core.GetServiceGatewayRequest{
                        ServiceGatewayId: sgwId,
                })
                if err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">sgw := resp.ServiceGateway
                if s.IsResourceCreatedByClusterAPI(sgw.FreeformTags) </span><span class="cov8" title="1">{
                        return &amp;sgw, err
                }</span> else<span class="cov0" title="0"> {
                        return nil, errors.New("cluster api tags have been modified out of context")
                }</span>
        }
        <span class="cov8" title="1">sgws, err := s.VCNClient.ListServiceGateways(ctx, core.ListServiceGatewaysRequest{
                CompartmentId: common.String(s.GetCompartmentId()),
                VcnId:         s.getVcnId(),
        })
        if err != nil </span><span class="cov0" title="0">{
                s.Logger.Error(err, "failed to list Service gateways")
                return nil, errors.Wrap(err, "failed to list Service gateways")
        }</span>
        <span class="cov8" title="1">for _, sgw := range sgws.Items </span><span class="cov8" title="1">{
                if *sgw.DisplayName == ServiceGatewayName </span><span class="cov8" title="1">{
                        if s.IsResourceCreatedByClusterAPI(sgw.FreeformTags) </span><span class="cov8" title="1">{
                                return &amp;sgw, nil
                        }</span>
                }
        }
        <span class="cov8" title="1">return nil, nil</span>
}
</pre>
		
		<pre class="file" id="file58" style="display: none">/*
 Copyright (c) 2021, 2022 Oracle and/or its affiliates.

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

      https://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
*/

package scope

import (
        "context"
        "fmt"
        "net"
        "slices"
        "strings"

        infrastructurev1beta2 "github.com/oracle/cluster-api-provider-oci/api/v1beta2"
        "github.com/oracle/cluster-api-provider-oci/cloud/ociutil"
        "github.com/oracle/cluster-api-provider-oci/cloud/ociutil/ptr"
        "github.com/oracle/oci-go-sdk/v65/common"
        "github.com/oracle/oci-go-sdk/v65/core"
        "github.com/pkg/errors"
)

func (s *ClusterScope) ReconcileSubnet(ctx context.Context) error <span class="cov8" title="1">{
        desiredSubnets := s.OCIClusterAccessor.GetNetworkSpec().Vcn.Subnets
        for _, desiredSubnet := range desiredSubnets </span><span class="cov8" title="1">{
                if desiredSubnet == nil </span><span class="cov8" title="1">{
                        return errors.New("Skipping Subnet reconciliation: Subnet can't be nil")
                }</span>
                <span class="cov8" title="1">if desiredSubnet.Skip </span><span class="cov0" title="0">{
                        s.Logger.Info("Skipping Subnet reconciliation as per spec")
                        continue</span>
                }
                <span class="cov8" title="1">subnet, err := s.GetSubnet(ctx, *desiredSubnet)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">if subnet != nil </span><span class="cov8" title="1">{
                        subnetOCID := subnet.Id
                        desiredSubnet.ID = subnetOCID
                        if desiredSubnet.SecurityList != nil </span><span class="cov8" title="1">{
                                securityList, err := s.GetSecurityList(ctx, *desiredSubnet.SecurityList)
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                                <span class="cov8" title="1">if securityList == nil </span><span class="cov8" title="1">{
                                        seclistId, err := s.CreateSecurityList(ctx, *desiredSubnet.SecurityList)
                                        if err != nil </span><span class="cov8" title="1">{
                                                return err
                                        }</span>
                                        <span class="cov8" title="1">s.Logger.Info("Created the security list", "ocid", seclistId)
                                        desiredSubnet.SecurityList.ID = seclistId</span>
                                } else<span class="cov8" title="1"> {
                                        if s.IsSecurityListEqual(*securityList, *desiredSubnet.SecurityList) </span><span class="cov0" title="0">{
                                                s.Logger.Info("No Reconciliation Required for Security List", "securitylist", securityList.Id)
                                        }</span> else<span class="cov8" title="1"> {
                                                err = s.UpdateSecurityList(ctx, *desiredSubnet.SecurityList)
                                                if err != nil </span><span class="cov8" title="1">{
                                                        return err
                                                }</span>
                                                <span class="cov8" title="1">s.Logger.Info("Successfully updated security list", "securitylist", securityList)</span>
                                        }
                                }
                        }
                        <span class="cov8" title="1">if s.IsSubnetsEqual(subnet, *desiredSubnet) </span><span class="cov8" title="1">{
                                s.Logger.Info("No Reconciliation Required for Subnet", "subnet", subnetOCID)
                        }</span> else<span class="cov8" title="1"> {
                                err = s.UpdateSubnet(ctx, *desiredSubnet)
                                if err != nil </span><span class="cov8" title="1">{
                                        return err
                                }</span>
                                <span class="cov8" title="1">s.Logger.Info("Successfully updated subnet", "subnet", subnetOCID)</span>
                        }
                        <span class="cov8" title="1">continue</span>
                }
                <span class="cov8" title="1">s.Logger.Info("Creating the subnet")
                if desiredSubnet.SecurityList != nil </span><span class="cov8" title="1">{
                        s.Logger.Info("Creating the security List")
                        seclistId, err := s.CreateSecurityList(ctx, *desiredSubnet.SecurityList)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">s.Logger.Info("Created the security list", "ocid", seclistId)
                        desiredSubnet.SecurityList.ID = seclistId</span>
                }
                <span class="cov8" title="1">subnetId, err := s.CreateSubnet(ctx, *desiredSubnet)
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
                <span class="cov8" title="1">s.Logger.Info("Created the subnet", "ocid", subnetId)
                desiredSubnet.ID = subnetId</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (s *ClusterScope) CreateSubnet(ctx context.Context, spec infrastructurev1beta2.Subnet) (*string, error) <span class="cov8" title="1">{
        var err error
        var routeTable *string
        var isPrivate bool
        if spec.Type == infrastructurev1beta2.Private </span><span class="cov8" title="1">{
                isPrivate = true
                routeTable = s.getRouteTableId(infrastructurev1beta2.Private)
        }</span> else<span class="cov8" title="1"> {
                routeTable = s.getRouteTableId(infrastructurev1beta2.Public)
        }</span>

        <span class="cov8" title="1">resp, err := s.VCNClient.GetVcn(ctx, core.GetVcnRequest{VcnId: s.getVcnId()})

        var ipv6subnetCIDR_Ptr *string

        // Constructing IPv6 Subnet CIDR
        if len(resp.Vcn.Ipv6CidrBlocks) &gt; 0 </span><span class="cov0" title="0">{

                // VCNs can have multiple IPv6 CIDR Blocks, and the CIDR block with IPv6 GUA Allocated by Oracle is the first (index 0) in the list
                vcnCIDR := resp.Vcn.Ipv6CidrBlocks[0]

                // Split CIDR block into hextets
                ip, _, err := net.ParseCIDR(vcnCIDR)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errors.Wrap(err, "failed to parse IPv6 CIDR block")
                }</span>
                <span class="cov0" title="0">hextets := strings.Split(ip.String(), ":")

                // Modify the 4th hextet (index 3) of vcn CIDR to reflect the subnet CIDR with Ipv6CidrBlockHextet value in it
                if len(hextets) &gt;= 4 </span><span class="cov0" title="0">{
                        originalHextet := hextets[3]
                        if len(originalHextet) &lt; 4 </span><span class="cov0" title="0">{
                                originalHextet = fmt.Sprintf("%04s", originalHextet)
                        }</span>
                        <span class="cov0" title="0">newHextet := originalHextet[:2] + *spec.Ipv6CidrBlockHextet
                        hextets[3] = newHextet

                        // Reconstruct the IPv6 address with a /64 CIDR for the subnet
                        ipv6subnetCIDR := strings.Join(hextets, ":") + "/64"
                        ipv6subnetCIDR_Ptr = &amp;ipv6subnetCIDR</span>
                }
        }

        <span class="cov8" title="1">createSubnetDetails := core.CreateSubnetDetails{
                CompartmentId:           common.String(s.GetCompartmentId()),
                CidrBlock:               common.String(spec.CIDR),
                VcnId:                   s.getVcnId(),
                DisplayName:             common.String(spec.Name),
                ProhibitInternetIngress: common.Bool(isPrivate),
                ProhibitPublicIpOnVnic:  common.Bool(isPrivate),
                RouteTableId:            routeTable,
                FreeformTags:            s.GetFreeFormTags(),
                DefinedTags:             s.GetDefinedTags(),
                DnsLabel:                spec.DnsLabel,
                Ipv6CidrBlock:           ipv6subnetCIDR_Ptr,
        }

        if spec.SecurityList != nil </span><span class="cov8" title="1">{
                createSubnetDetails.SecurityListIds = []string{*spec.SecurityList.ID}
        }</span>
        <span class="cov8" title="1">subnetResponse, err := s.VCNClient.CreateSubnet(ctx, core.CreateSubnetRequest{
                CreateSubnetDetails: createSubnetDetails,
        })
        if err != nil </span><span class="cov8" title="1">{
                s.Logger.Error(err, "failed create subnet")
                return nil, errors.Wrap(err, "failed create subnet")
        }</span>
        <span class="cov8" title="1">s.Logger.Info("Successfully created the subnet", "subnet", *subnetResponse.Subnet.Id)
        return subnetResponse.Subnet.Id, nil</span>
}

func (s *ClusterScope) UpdateSubnet(ctx context.Context, spec infrastructurev1beta2.Subnet) error <span class="cov8" title="1">{
        updateSubnetDetails := core.UpdateSubnetDetails{
                DisplayName: common.String(spec.Name),
                CidrBlock:   common.String(spec.CIDR),
        }
        if spec.SecurityList != nil </span><span class="cov8" title="1">{
                if spec.SecurityList.ID == nil </span><span class="cov0" title="0">{
                        err := errors.New("SecurityListID required")
                        s.Logger.Error(err, "failed updating subnet")
                        return err
                }</span>
                <span class="cov8" title="1">updateSubnetDetails.SecurityListIds = []string{*spec.SecurityList.ID}</span>
        }
        <span class="cov8" title="1">subnetResponse, err := s.VCNClient.UpdateSubnet(ctx, core.UpdateSubnetRequest{
                UpdateSubnetDetails: updateSubnetDetails,
                SubnetId:            spec.ID,
        })
        if err != nil </span><span class="cov8" title="1">{
                s.Logger.Error(err, "failed to reconcile the subnet, failed to update")
                return errors.Wrap(err, "failed to reconcile the subnet, failed to update")
        }</span>
        <span class="cov8" title="1">s.Logger.Info("Successfully updated the subnet", "subnet", *subnetResponse.Id)
        return nil</span>
}

func (s *ClusterScope) DeleteSubnets(ctx context.Context) error <span class="cov8" title="1">{
        desiredSubnets := s.GetSubnetsSpec()
        for _, desiredSubnet := range desiredSubnets </span><span class="cov8" title="1">{
                if desiredSubnet.Skip </span><span class="cov0" title="0">{
                        s.Logger.Info("Skipping Subnet reconciliation as per spec")
                        continue</span>
                }
                <span class="cov8" title="1">subnet, err := s.GetSubnet(ctx, *desiredSubnet)
                if err != nil &amp;&amp; !ociutil.IsNotFound(err) </span><span class="cov8" title="1">{
                        return err
                }</span>
                <span class="cov8" title="1">if subnet == nil </span><span class="cov8" title="1">{
                        s.Logger.Info("subnet is already deleted", "subnet", desiredSubnet.Name)
                        continue</span>
                }
                <span class="cov8" title="1">_, err = s.VCNClient.DeleteSubnet(ctx, core.DeleteSubnetRequest{
                        SubnetId: subnet.Id,
                })
                if err != nil </span><span class="cov8" title="1">{
                        s.Logger.Error(err, "failed to delete subnet")
                        return errors.Wrap(err, "failed to delete subnet")
                }</span>
                <span class="cov8" title="1">s.Logger.Info("Successfully deleted subnet", "subnet", desiredSubnet.Name)</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// nolint:nilnil
func (s *ClusterScope) GetSubnet(ctx context.Context, spec infrastructurev1beta2.Subnet) (*core.Subnet, error) <span class="cov8" title="1">{
        subnetOcid := spec.ID
        if subnetOcid != nil </span><span class="cov8" title="1">{
                resp, err := s.VCNClient.GetSubnet(ctx, core.GetSubnetRequest{
                        SubnetId: subnetOcid,
                })
                if err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">subnet := resp.Subnet
                if s.IsResourceCreatedByClusterAPI(subnet.FreeformTags) </span><span class="cov8" title="1">{
                        return &amp;subnet, nil
                }</span> else<span class="cov0" title="0"> {
                        return nil, errors.New("cluster api tags have been modified out of context")
                }</span>
        }
        <span class="cov8" title="1">subnets, err := s.VCNClient.ListSubnets(ctx, core.ListSubnetsRequest{
                CompartmentId: common.String(s.GetCompartmentId()),
                VcnId:         s.getVcnId(),
                DisplayName:   common.String(spec.Name),
        })
        if err != nil </span><span class="cov0" title="0">{
                s.Logger.Error(err, "failed to list subnets")
                return nil, errors.Wrap(err, "failed to list subnets")
        }</span>
        <span class="cov8" title="1">for _, subnet := range subnets.Items </span><span class="cov0" title="0">{
                if s.IsResourceCreatedByClusterAPI(subnet.FreeformTags) </span><span class="cov0" title="0">{
                        return &amp;subnet, nil
                }</span>
        }
        <span class="cov8" title="1">return nil, nil</span>
}

func (s *ClusterScope) GetControlPlaneEndpointSubnet() *infrastructurev1beta2.Subnet <span class="cov8" title="1">{
        for _, subnet := range s.GetSubnetsSpec() </span><span class="cov8" title="1">{
                if subnet != nil &amp;&amp; subnet.Role == infrastructurev1beta2.ControlPlaneEndpointRole </span><span class="cov8" title="1">{
                        return subnet
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (s *ClusterScope) GetControlPlaneMachineSubnet() *infrastructurev1beta2.Subnet <span class="cov8" title="1">{
        for _, subnet := range s.GetSubnetsSpec() </span><span class="cov8" title="1">{
                if subnet != nil &amp;&amp; subnet.Role == infrastructurev1beta2.ControlPlaneRole </span><span class="cov8" title="1">{
                        return subnet
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (s *ClusterScope) GetServiceLoadBalancerSubnet() *infrastructurev1beta2.Subnet <span class="cov8" title="1">{
        for _, subnet := range s.GetSubnetsSpec() </span><span class="cov8" title="1">{
                if subnet != nil &amp;&amp; subnet.Role == infrastructurev1beta2.ServiceLoadBalancerRole </span><span class="cov8" title="1">{
                        return subnet
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (s *ClusterScope) GetNodeSubnet() []*infrastructurev1beta2.Subnet <span class="cov8" title="1">{
        var nodeSubnets []*infrastructurev1beta2.Subnet
        for _, subnet := range s.GetSubnetsSpec() </span><span class="cov8" title="1">{
                if subnet != nil &amp;&amp; subnet.Role == infrastructurev1beta2.WorkerRole </span><span class="cov8" title="1">{
                        nodeSubnets = append(nodeSubnets, subnet)
                }</span>
        }
        <span class="cov8" title="1">return nodeSubnets</span>
}

func (s *ClusterScope) GetSubnetsSpec() []*infrastructurev1beta2.Subnet <span class="cov8" title="1">{
        return s.OCIClusterAccessor.GetNetworkSpec().Vcn.Subnets
}</span>

func (s *ClusterScope) IsSubnetsEqual(actual *core.Subnet, desired infrastructurev1beta2.Subnet) bool <span class="cov8" title="1">{
        if desired.Name != ptr.ToString(actual.DisplayName) </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">if desired.CIDR != ptr.ToString(actual.CidrBlock) </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">if desired.SecurityList != nil </span><span class="cov8" title="1">{
                if desired.SecurityList.ID == nil </span><span class="cov8" title="1">{
                        return false
                }</span>

                <span class="cov8" title="1">return slices.Contains(actual.SecurityListIds, ptr.ToString(desired.SecurityList.ID))</span>
        }
        <span class="cov8" title="1">return true</span>
}

func (s *ClusterScope) isControlPlaneEndpointSubnetPrivate() bool <span class="cov8" title="1">{
        for _, subnet := range ptr.ToSubnetSlice(s.OCIClusterAccessor.GetNetworkSpec().Vcn.Subnets) </span><span class="cov8" title="1">{
                if subnet.Role == infrastructurev1beta2.ControlPlaneEndpointRole &amp;&amp; subnet.Type == infrastructurev1beta2.Private </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

func (s *ClusterScope) GetControlPlaneEndpointSubnetCidr() string <span class="cov0" title="0">{
        subnetSlice := ptr.ToSubnetSlice(s.GetSubnetsSpec())
        for i := range subnetSlice </span><span class="cov0" title="0">{
                subnet := &amp;subnetSlice[i]
                if subnet.Role == infrastructurev1beta2.ControlPlaneEndpointRole </span><span class="cov0" title="0">{
                        if subnet.CIDR != "" </span><span class="cov0" title="0">{
                                return subnet.CIDR
                        }</span>
                }
        }
        <span class="cov0" title="0">return ControlPlaneEndpointSubnetDefaultCIDR</span>
}

func (s *ClusterScope) GetServiceLoadBalancerSubnetCidr() string <span class="cov0" title="0">{
        subnetSlice := ptr.ToSubnetSlice(s.GetSubnetsSpec())
        for i := range subnetSlice </span><span class="cov0" title="0">{
                subnet := &amp;subnetSlice[i]
                if subnet.Role == infrastructurev1beta2.ServiceLoadBalancerRole </span><span class="cov0" title="0">{
                        if subnet.CIDR != "" </span><span class="cov0" title="0">{
                                return subnet.CIDR
                        }</span>
                }
        }
        <span class="cov0" title="0">return ServiceLoadBalancerDefaultCIDR</span>
}

func (s *ClusterScope) NodeSubnetCidr() []string <span class="cov0" title="0">{
        var nodeCIDR []string
        subnetSlice := ptr.ToSubnetSlice(s.GetNodeSubnet())
        for i := range subnetSlice </span><span class="cov0" title="0">{
                subnet := &amp;subnetSlice[i]
                if subnet.CIDR != "" </span><span class="cov0" title="0">{
                        nodeCIDR = append(nodeCIDR, subnet.CIDR)
                }</span>
                <span class="cov0" title="0">nodeCIDR = append(nodeCIDR, WorkerSubnetDefaultCIDR)</span>
        }
        <span class="cov0" title="0">if len(nodeCIDR) == 0 </span><span class="cov0" title="0">{
                return []string{WorkerSubnetDefaultCIDR}
        }</span>
        <span class="cov0" title="0">return nodeCIDR</span>
}
func (s *ClusterScope) GetControlPlaneMachineSubnetCidr() string <span class="cov0" title="0">{
        subnet := s.GetControlPlaneMachineSubnet()
        if subnet != nil </span><span class="cov0" title="0">{
                if subnet.CIDR != "" </span><span class="cov0" title="0">{
                        return subnet.CIDR
                }</span>
        }
        <span class="cov0" title="0">return ControlPlaneMachineSubnetDefaultCIDR</span>
}

// IsAllSubnetsPrivate determines if all the ClusterScope's subnets are private
func (s *ClusterScope) IsAllSubnetsPrivate() bool <span class="cov8" title="1">{
        subnetSlice := ptr.ToSubnetSlice(s.GetSubnetsSpec())
        for i := range subnetSlice </span><span class="cov8" title="1">{
                subnet := &amp;subnetSlice[i]
                if subnet.Type == infrastructurev1beta2.Public </span><span class="cov8" title="1">{
                        return false
                }</span>
        }
        <span class="cov8" title="1">if (s.GetControlPlaneEndpointSubnet() == nil) || (s.GetServiceLoadBalancerSubnet() == nil) </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">return true</span>
}

// IsAllSubnetsPublic determines if all the ClusterScope's subnets are public
func (s *ClusterScope) IsAllSubnetsPublic() bool <span class="cov8" title="1">{
        for _, subnet := range ptr.ToSubnetSlice(s.GetSubnetsSpec()) </span><span class="cov8" title="1">{
                if subnet.Type == infrastructurev1beta2.Private </span><span class="cov0" title="0">{
                        return false
                }</span>
        }
        <span class="cov8" title="1">if (s.GetControlPlaneMachineSubnet() == nil) || (len(s.GetNodeSubnet()) == 0) </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">return true</span>
}
</pre>
		
		<pre class="file" id="file59" style="display: none">/*
Copyright (c) 2021, 2022 Oracle and/or its affiliates.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package scope

import (
        infrastructurev1beta2 "github.com/oracle/cluster-api-provider-oci/api/v1beta2"
        "github.com/oracle/cluster-api-provider-oci/cloud/ociutil/ptr"
)

const (
        LogLevelWarn = 3
)

// GetNsgNamesFromId returns the names of the NSGs with the provided IDs
func GetNsgNamesFromId(ids []string, nsgs []*infrastructurev1beta2.NSG) []string <span class="cov8" title="1">{
        if len(ids) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">names := make([]string, 0)
        for _, id := range ids </span><span class="cov8" title="1">{
                for _, nsg := range ptr.ToNSGSlice(nsgs) </span><span class="cov8" title="1">{
                        if id == ptr.ToString(nsg.ID) </span><span class="cov8" title="1">{
                                names = append(names, nsg.Name)
                        }</span>
                }
        }
        <span class="cov8" title="1">return names</span>
}

// GetSubnetNameFromId returns the name of the Subnet with the provided ID
func GetSubnetNameFromId(id *string, subnets []*infrastructurev1beta2.Subnet) string <span class="cov8" title="1">{
        for _, subnet := range ptr.ToSubnetSlice(subnets) </span><span class="cov8" title="1">{
                if ptr.ToString(id) == ptr.ToString(subnet.ID) </span><span class="cov8" title="1">{
                        return subnet.Name
                }</span>
        }
        <span class="cov8" title="1">return ""</span>
}

// GetSubnetNamesFromId returns the names of the Subnets with the provided IDs
func GetSubnetNamesFromId(ids []string, subnets []*infrastructurev1beta2.Subnet) []string <span class="cov8" title="1">{
        names := make([]string, 0)
        for _, id := range ids </span><span class="cov8" title="1">{
                for _, subnet := range ptr.ToSubnetSlice(subnets) </span><span class="cov8" title="1">{
                        if id == ptr.ToString(subnet.ID) </span><span class="cov8" title="1">{
                                names = append(names, subnet.Name)
                        }</span>
                }
        }
        <span class="cov8" title="1">return names</span>
}

// ConvertMachineDefinedTags passes in the OCIMachineSpec DefinedTags and returns a converted map of defined tags
// to be used when creating API requests.
func ConvertMachineDefinedTags(machineDefinedTags map[string]map[string]string) map[string]map[string]interface{} <span class="cov8" title="1">{
        definedTags := make(map[string]map[string]interface{})
        if machineDefinedTags != nil </span><span class="cov0" title="0">{
                for ns, mapNs := range machineDefinedTags </span><span class="cov0" title="0">{
                        mapValues := make(map[string]interface{})
                        for k, v := range mapNs </span><span class="cov0" title="0">{
                                mapValues[k] = v
                        }</span>
                        <span class="cov0" title="0">definedTags[ns] = mapValues</span>
                }
        }

        <span class="cov8" title="1">return definedTags</span>
}
</pre>
		
		<pre class="file" id="file60" style="display: none">/*
 Copyright (c) 2021, 2022 Oracle and/or its affiliates.

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

      https://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
*/

package scope

import (
        "context"
        "fmt"

        infrastructurev1beta2 "github.com/oracle/cluster-api-provider-oci/api/v1beta2"
        "github.com/oracle/cluster-api-provider-oci/cloud/ociutil"
        "github.com/oracle/oci-go-sdk/v65/common"
        "github.com/oracle/oci-go-sdk/v65/core"
        "github.com/pkg/errors"
)

func (s *ClusterScope) ReconcileVCN(ctx context.Context) error <span class="cov8" title="1">{
        if s.OCIClusterAccessor.GetNetworkSpec().Vcn.Skip </span><span class="cov0" title="0">{
                s.Logger.Info("Skipping VCN reconciliation as per spec")
                return nil
        }</span>
        <span class="cov8" title="1">spec := s.OCIClusterAccessor.GetNetworkSpec().Vcn

        var err error
        vcn, err := s.GetVCN(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if vcn != nil </span><span class="cov8" title="1">{
                s.OCIClusterAccessor.GetNetworkSpec().Vcn.ID = vcn.Id
                if s.IsVcnEquals(vcn) </span><span class="cov8" title="1">{
                        s.Logger.Info("No Reconciliation Required for VCN", "vcn", s.getVcnId())
                        return nil
                }</span>
                <span class="cov8" title="1">return s.UpdateVCN(ctx, spec)</span>
        }
        <span class="cov8" title="1">vcnId, err := s.CreateVCN(ctx, spec)
        s.OCIClusterAccessor.GetNetworkSpec().Vcn.ID = vcnId
        return err</span>
}

func (s *ClusterScope) IsVcnEquals(actual *core.Vcn) bool <span class="cov8" title="1">{
        if *actual.DisplayName != s.GetVcnName() </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">return true</span>
}

func (s *ClusterScope) GetVcnName() string <span class="cov8" title="1">{
        if s.OCIClusterAccessor.GetNetworkSpec().Vcn.Name != "" </span><span class="cov8" title="1">{
                return s.OCIClusterAccessor.GetNetworkSpec().Vcn.Name
        }</span>
        <span class="cov8" title="1">return fmt.Sprintf("%s", s.OCIClusterAccessor.GetName())</span>
}

func (s *ClusterScope) GetVcnCidrs() []string <span class="cov8" title="1">{
        if s.OCIClusterAccessor.GetNetworkSpec().Vcn.CIDRS != nil &amp;&amp; len(s.OCIClusterAccessor.GetNetworkSpec().Vcn.CIDRS) &gt; 0 </span><span class="cov8" title="1">{
                return s.OCIClusterAccessor.GetNetworkSpec().Vcn.CIDRS
        }</span> else<span class="cov8" title="1"> if s.OCIClusterAccessor.GetNetworkSpec().Vcn.CIDR != "" </span><span class="cov8" title="1">{
                return []string{s.OCIClusterAccessor.GetNetworkSpec().Vcn.CIDR}
        }</span>
        <span class="cov8" title="1">return []string{VcnDefaultCidr}</span>
}

// nolint:nilnil
func (s *ClusterScope) GetVCN(ctx context.Context) (*core.Vcn, error) <span class="cov8" title="1">{
        vcnId := s.getVcnId()
        if vcnId != nil </span><span class="cov8" title="1">{
                resp, err := s.VCNClient.GetVcn(ctx, core.GetVcnRequest{
                        VcnId: vcnId,
                })
                if err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">vcn := resp.Vcn
                if s.IsResourceCreatedByClusterAPI(vcn.FreeformTags) </span><span class="cov8" title="1">{
                        return &amp;vcn, nil
                }</span> else<span class="cov8" title="1"> {
                        return nil, errors.New("cluster api tags have been modified out of context")
                }</span>
        }
        <span class="cov8" title="1">vcns, err := s.VCNClient.ListVcns(ctx, core.ListVcnsRequest{
                CompartmentId: common.String(s.GetCompartmentId()),
                DisplayName:   common.String(s.GetVcnName()),
        })
        if err != nil </span><span class="cov8" title="1">{
                s.Logger.Error(err, "failed to list vcn by name")
                return nil, errors.Wrap(err, "failed to list vcn by name")
        }</span>

        <span class="cov8" title="1">for _, vcn := range vcns.Items </span><span class="cov8" title="1">{
                if s.IsResourceCreatedByClusterAPI(vcn.FreeformTags) </span><span class="cov8" title="1">{
                        return &amp;vcn, nil
                }</span>
        }
        <span class="cov8" title="1">return nil, nil</span>
}

func (s *ClusterScope) UpdateVCN(ctx context.Context, vcn infrastructurev1beta2.VCN) error <span class="cov8" title="1">{
        updateVCNDetails := core.UpdateVcnDetails{
                DisplayName: common.String(s.GetVcnName()),
        }
        vcnResponse, err := s.VCNClient.UpdateVcn(ctx, core.UpdateVcnRequest{
                UpdateVcnDetails: updateVCNDetails,
                VcnId:            s.getVcnId(),
        })
        if err != nil </span><span class="cov8" title="1">{
                s.Logger.Error(err, "failed to reconcile the vcn, failed to update")
                return errors.Wrap(err, "failed to reconcile the vcn, failed to update")
        }</span>
        <span class="cov8" title="1">s.Logger.Info("successfully updated the vcn", "vcn", *vcnResponse.Id)
        return nil</span>
}

func (s *ClusterScope) CreateVCN(ctx context.Context, spec infrastructurev1beta2.VCN) (*string, error) <span class="cov8" title="1">{
        vcnDetails := core.CreateVcnDetails{
                CompartmentId: common.String(s.GetCompartmentId()),
                DisplayName:   common.String(s.GetVcnName()),
                CidrBlocks:    s.GetVcnCidrs(),
                FreeformTags:  s.GetFreeFormTags(),
                DefinedTags:   s.GetDefinedTags(),
                DnsLabel:      spec.DnsLabel,
                IsIpv6Enabled: spec.IsIpv6Enabled,
        }

        if spec.IsIpv6Enabled != nil </span><span class="cov8" title="1">{
                if spec.IsIpv6Enabled == common.Bool(true) </span><span class="cov0" title="0">{
                        vcnDetails.IsOracleGuaAllocationEnabled = common.Bool(true)
                }</span>
        }

        <span class="cov8" title="1">vcnResponse, err := s.VCNClient.CreateVcn(ctx, core.CreateVcnRequest{
                CreateVcnDetails: vcnDetails,
                OpcRetryToken:    ociutil.GetOPCRetryToken("%s-%s", "create-vcn", string(s.OCIClusterAccessor.GetOCIResourceIdentifier())),
        })
        if err != nil </span><span class="cov8" title="1">{
                s.Logger.Error(err, "failed create vcn")
                return nil, errors.Wrap(err, "failed create vcn")
        }</span>
        <span class="cov8" title="1">s.Logger.Info("successfully created the vcn", "vcn", *vcnResponse.Vcn.Id)
        return vcnResponse.Vcn.Id, nil</span>
}

func (s *ClusterScope) DeleteVCN(ctx context.Context) error <span class="cov8" title="1">{
        if s.OCIClusterAccessor.GetNetworkSpec().Vcn.Skip </span><span class="cov0" title="0">{
                s.Logger.Info("Skipping VCN reconciliation as per spec")
                return nil
        }</span>
        <span class="cov8" title="1">vcn, err := s.GetVCN(ctx)

        if err != nil &amp;&amp; !ociutil.IsNotFound(err) </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">if vcn == nil </span><span class="cov8" title="1">{
                s.Logger.Info("VCN is already deleted")
                return nil
        }</span>
        <span class="cov8" title="1">_, err = s.VCNClient.DeleteVcn(ctx, core.DeleteVcnRequest{
                VcnId: vcn.Id,
        })
        if err != nil </span><span class="cov8" title="1">{
                s.Logger.Error(err, "failed to delete vcn")
                return errors.Wrap(err, "failed to delete vcn")
        }</span>
        <span class="cov8" title="1">s.Logger.Info("Successfully deleted VCN")
        return nil</span>
}

func (s *ClusterScope) getVcnId() *string <span class="cov8" title="1">{
        id := s.OCIClusterAccessor.GetNetworkSpec().Vcn.ID
        if id == nil </span><span class="cov8" title="1">{
                s.Logger.Info("VCN ID is nil")

        }</span>
        <span class="cov8" title="1">return id</span>
}
</pre>
		
		<pre class="file" id="file61" style="display: none">/*
 Copyright (c) 2022 Oracle and/or its affiliates.

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

      https://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
*/

package scope

import (
        "context"
        "encoding/json"
        "fmt"

        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"

        "reflect"

        "github.com/go-logr/logr"
        infrastructurev1beta2 "github.com/oracle/cluster-api-provider-oci/api/v1beta2"
        "github.com/oracle/cluster-api-provider-oci/cloud/ociutil"
        "github.com/oracle/cluster-api-provider-oci/cloud/ociutil/ptr"
        "github.com/oracle/cluster-api-provider-oci/cloud/services/computemanagement"
        "github.com/oracle/cluster-api-provider-oci/cloud/services/containerengine"
        expinfra1 "github.com/oracle/cluster-api-provider-oci/exp/api/v1beta2"
        infrav2exp "github.com/oracle/cluster-api-provider-oci/exp/api/v1beta2"
        "github.com/oracle/oci-go-sdk/v65/common"
        oke "github.com/oracle/oci-go-sdk/v65/containerengine"
        "github.com/pkg/errors"
        "k8s.io/klog/v2/klogr"
        clusterv1 "sigs.k8s.io/cluster-api/api/core/v1beta1"
        expclusterv1 "sigs.k8s.io/cluster-api/api/core/v1beta1"
        capierrors "sigs.k8s.io/cluster-api/errors"
        "sigs.k8s.io/cluster-api/util/annotations"
        "sigs.k8s.io/cluster-api/util/patch"
        "sigs.k8s.io/controller-runtime/pkg/client"
)

const (
        OCIVirtualMachinePoolKind = "OCIVirtualMachinePool"
)

// VirtualMachinePoolScopeParams defines the params need to create a new VirtualMachinePoolScope
type VirtualMachinePoolScopeParams struct {
        Logger                  *logr.Logger
        Cluster                 *clusterv1.Cluster
        MachinePool             *expclusterv1.MachinePool
        Client                  client.Client
        ComputeManagementClient computemanagement.Client
        OCIManagedCluster       *infrastructurev1beta2.OCIManagedCluster
        OCIManagedControlPlane  *infrastructurev1beta2.OCIManagedControlPlane
        OCIVirtualMachinePool   *expinfra1.OCIVirtualMachinePool
        ContainerEngineClient   containerengine.Client
}

type VirtualMachinePoolScope struct {
        *logr.Logger
        Client                  client.Client
        patchHelper             *patch.Helper
        Cluster                 *clusterv1.Cluster
        MachinePool             *expclusterv1.MachinePool
        ComputeManagementClient computemanagement.Client
        OCIManagedCluster       *infrastructurev1beta2.OCIManagedCluster
        OCIVirtualMachinePool   *expinfra1.OCIVirtualMachinePool
        ContainerEngineClient   containerengine.Client
        OCIManagedControlPlane  *infrastructurev1beta2.OCIManagedControlPlane
}

// NewVirtualMachinePoolScope creates a VirtualMachinePoolScope given the VirtualMachinePoolScopeParams
func NewVirtualMachinePoolScope(params VirtualMachinePoolScopeParams) (*VirtualMachinePoolScope, error) <span class="cov8" title="1">{
        if params.MachinePool == nil </span><span class="cov0" title="0">{
                return nil, errors.New("failed to generate new scope from nil MachinePool")
        }</span>
        <span class="cov8" title="1">if params.OCIManagedCluster == nil </span><span class="cov0" title="0">{
                return nil, errors.New("failed to generate new scope from nil OCIManagedCluster")
        }</span>

        <span class="cov8" title="1">if params.Logger == nil </span><span class="cov8" title="1">{
                log := klogr.New()
                params.Logger = &amp;log
        }</span>
        <span class="cov8" title="1">helper, err := patch.NewHelper(params.OCIVirtualMachinePool, params.Client)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "failed to init patch helper")
        }</span>
        <span class="cov8" title="1">params.OCIVirtualMachinePool.Status.InfrastructureMachineKind = "OCIMachinePoolMachine"
        return &amp;VirtualMachinePoolScope{
                Logger:                  params.Logger,
                Client:                  params.Client,
                ComputeManagementClient: params.ComputeManagementClient,
                Cluster:                 params.Cluster,
                OCIManagedCluster:       params.OCIManagedCluster,
                patchHelper:             helper,
                MachinePool:             params.MachinePool,
                OCIVirtualMachinePool:   params.OCIVirtualMachinePool,
                ContainerEngineClient:   params.ContainerEngineClient,
                OCIManagedControlPlane:  params.OCIManagedControlPlane,
        }, nil</span>
}

// PatchObject persists the cluster configuration and status.
func (m *VirtualMachinePoolScope) PatchObject(ctx context.Context) error <span class="cov0" title="0">{
        return m.patchHelper.Patch(ctx, m.OCIVirtualMachinePool)
}</span>

// Close closes the current scope persisting the cluster configuration and status.
func (m *VirtualMachinePoolScope) Close(ctx context.Context) error <span class="cov0" title="0">{
        return m.PatchObject(ctx)
}</span>

// SetFailureReason sets the OCIMachine status error reason.
func (m *VirtualMachinePoolScope) SetFailureReason(v capierrors.MachinePoolStatusFailure) <span class="cov0" title="0">{
        m.OCIVirtualMachinePool.Status.FailureReason = &amp;v
}</span>

func (m *VirtualMachinePoolScope) SetReplicaCount(count int32) <span class="cov0" title="0">{
        m.OCIVirtualMachinePool.Status.Replicas = count
}</span>

// GetWorkerMachineSubnet returns the WorkerRole core.Subnet id for the cluster
func (m *VirtualMachinePoolScope) GetWorkerMachineSubnet() *string <span class="cov0" title="0">{
        for _, subnet := range ptr.ToSubnetSlice(m.OCIManagedCluster.Spec.NetworkSpec.Vcn.Subnets) </span><span class="cov0" title="0">{
                if subnet.Role == infrastructurev1beta2.WorkerRole </span><span class="cov0" title="0">{
                        return subnet.ID
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// ListandSetMachinePoolInstances retrieves a virtual node pools instances and sets them in the ProviderIDList
func (m *VirtualMachinePoolScope) ListandSetMachinePoolInstances(ctx context.Context, nodePool *oke.VirtualNodePool) ([]infrav2exp.OCIMachinePoolMachine, error) <span class="cov0" title="0">{
        machines := make([]infrav2exp.OCIMachinePoolMachine, 0)
        var page *string
        for </span><span class="cov0" title="0">{
                reqList := oke.ListVirtualNodesRequest{
                        VirtualNodePoolId: nodePool.Id,
                        Page:              page,
                }

                response, err := m.ContainerEngineClient.ListVirtualNodes(ctx, reqList)
                if err != nil </span><span class="cov0" title="0">{
                        return machines, err
                }</span>
                <span class="cov0" title="0">for _, node := range response.Items </span><span class="cov0" title="0">{
                        // deleted nodes should not be considered
                        if node.LifecycleState == oke.VirtualNodeLifecycleStateDeleted ||
                                node.LifecycleState == oke.VirtualNodeLifecycleStateFailed </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">ready := false
                        if node.LifecycleState == oke.VirtualNodeLifecycleStateActive </span><span class="cov0" title="0">{
                                ready = true
                        }</span>
                        <span class="cov0" title="0">machines = append(machines, infrav2exp.OCIMachinePoolMachine{
                                ObjectMeta: metav1.ObjectMeta{
                                        Name: *node.DisplayName,
                                },
                                Spec: infrav2exp.OCIMachinePoolMachineSpec{
                                        OCID:         node.Id,
                                        ProviderID:   node.Id,
                                        InstanceName: node.DisplayName,
                                        MachineType:  infrav2exp.Virtual,
                                },
                                Status: infrav2exp.OCIMachinePoolMachineStatus{
                                        Ready: ready,
                                },
                        })</span>
                }
                <span class="cov0" title="0">if response.OpcNextPage == nil </span><span class="cov0" title="0">{
                        break</span>
                } else<span class="cov0" title="0"> {
                        page = response.OpcNextPage
                }</span>
        }
        <span class="cov0" title="0">return machines, nil</span>
}

// IsResourceCreatedByClusterAPI determines if the virtual node pool was created by the cluster using the
// tags created at virtual node pool launch.
func (m *VirtualMachinePoolScope) IsResourceCreatedByClusterAPI(resourceFreeFormTags map[string]string) bool <span class="cov0" title="0">{
        tagsAddedByClusterAPI := ociutil.BuildClusterTags(m.OCIManagedCluster.Spec.OCIResourceIdentifier)
        for k, v := range tagsAddedByClusterAPI </span><span class="cov0" title="0">{
                if resourceFreeFormTags[k] != v </span><span class="cov0" title="0">{
                        return false
                }</span>
        }
        <span class="cov0" title="0">return true</span>
}

// FindVirtualNodePool attempts to find the node pool by id if the id exists or by name. It checks to make sure
// the node pool was created by the cluster before returning the correct pool
// nolint:nilnil
func (m *VirtualMachinePoolScope) FindVirtualNodePool(ctx context.Context) (*oke.VirtualNodePool, error) <span class="cov0" title="0">{
        if m.OCIVirtualMachinePool.Spec.ID != nil </span><span class="cov0" title="0">{
                response, err := m.ContainerEngineClient.GetVirtualNodePool(ctx, oke.GetVirtualNodePoolRequest{
                        VirtualNodePoolId: m.OCIVirtualMachinePool.Spec.ID,
                })
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">if m.IsResourceCreatedByClusterAPI(response.FreeformTags) </span><span class="cov0" title="0">{
                        return &amp;response.VirtualNodePool, nil
                }</span> else<span class="cov0" title="0"> {
                        return nil, errors.New("cluster api tags have been modified out of context")
                }</span>
        }

        <span class="cov0" title="0">var page *string
        for </span><span class="cov0" title="0">{
                reqList := oke.ListVirtualNodePoolsRequest{
                        CompartmentId: common.String(m.OCIManagedCluster.Spec.CompartmentId),
                        ClusterId:     m.OCIManagedControlPlane.Spec.ID,
                        Name:          common.String(m.getNodePoolName()),
                        Page:          page,
                }

                response, err := m.ContainerEngineClient.ListVirtualNodePools(ctx, reqList)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">for _, i := range response.Items </span><span class="cov0" title="0">{
                        if m.IsResourceCreatedByClusterAPI(i.FreeformTags) </span><span class="cov0" title="0">{
                                return m.getOKEVirtualNodePoolFromOCID(ctx, i.Id)
                        }</span>
                }
                <span class="cov0" title="0">if response.OpcNextPage == nil </span><span class="cov0" title="0">{
                        break</span>
                } else<span class="cov0" title="0"> {
                        page = response.OpcNextPage
                }</span>
        }
        <span class="cov0" title="0">return nil, nil</span>
}

func (m *VirtualMachinePoolScope) getNodePoolName() string <span class="cov8" title="1">{
        return m.OCIVirtualMachinePool.GetName()
}</span>

// CreateVirtualNodePool attempts to create a virtual node pool
func (m *VirtualMachinePoolScope) CreateVirtualNodePool(ctx context.Context) (*oke.VirtualNodePool, error) <span class="cov8" title="1">{
        m.Info("Creating Node Pool")

        placementConfigs := m.OCIVirtualMachinePool.Spec.PlacementConfigs
        if len(placementConfigs) == 0 </span><span class="cov8" title="1">{
                placementConfigs = make([]expinfra1.VirtualNodepoolPlacementConfig, 0)
                workerSubnets := m.getWorkerMachineSubnets()
                if len(workerSubnets) == 0 </span><span class="cov8" title="1">{
                        return nil, errors.New("worker subnets are not specified")
                }</span>
                <span class="cov8" title="1">adMap := m.OCIManagedCluster.Spec.AvailabilityDomains
                for k, v := range adMap </span><span class="cov8" title="1">{
                        placementConfigs = append(placementConfigs, expinfra1.VirtualNodepoolPlacementConfig{
                                AvailabilityDomain: common.String(k),
                                FaultDomains:       v.FaultDomains,
                                SubnetName:         common.String(workerSubnets[0]),
                        })
                }</span>
                <span class="cov8" title="1">m.OCIVirtualMachinePool.Spec.PlacementConfigs = placementConfigs</span>
        }
        <span class="cov8" title="1">if len(m.OCIVirtualMachinePool.Spec.NsgNames) == 0 </span><span class="cov8" title="1">{
                m.OCIVirtualMachinePool.Spec.NsgNames = m.getWorkerMachineNSGList()
        }</span>
        <span class="cov8" title="1">placementConfig, err := m.buildPlacementConfig(placementConfigs)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">podConfiguration := m.getPodConfiguration()

        nodePoolDetails := oke.CreateVirtualNodePoolDetails{
                CompartmentId:            common.String(m.OCIManagedCluster.Spec.CompartmentId),
                Size:                     common.Int(int(*m.MachinePool.Spec.Replicas)),
                ClusterId:                m.OCIManagedControlPlane.Spec.ID,
                DisplayName:              common.String(m.getNodePoolName()),
                PlacementConfigurations:  placementConfig,
                FreeformTags:             m.getFreeFormTags(),
                DefinedTags:              m.getDefinedTags(),
                NsgIds:                   m.getWorkerMachineNSGs(),
                InitialVirtualNodeLabels: m.getInitialNodeKeyValuePairs(),
                PodConfiguration:         podConfiguration,
                Taints:                   m.getTaints(),
                VirtualNodeTags: &amp;oke.VirtualNodeTags{
                        FreeformTags: m.getFreeFormTags(),
                        DefinedTags:  m.getDefinedTags(),
                },
        }
        nodePoolDetails.InitialVirtualNodeLabels = m.getInitialNodeKeyValuePairs()

        req := oke.CreateVirtualNodePoolRequest{
                CreateVirtualNodePoolDetails: nodePoolDetails,
        }
        response, err := m.ContainerEngineClient.CreateVirtualNodePool(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrapf(err, "failed to create OCIVirtualMachinePool")
        }</span>

        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">wrResponse, err := m.ContainerEngineClient.GetWorkRequest(ctx, oke.GetWorkRequestRequest{
                WorkRequestId: response.OpcWorkRequestId,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">resources := wrResponse.Resources
        var nodePoolId *string
        for _, resource := range resources </span><span class="cov8" title="1">{
                if *resource.EntityType == "VirtualNodePool" </span><span class="cov8" title="1">{
                        nodePoolId = resource.Identifier
                }</span>
        }
        <span class="cov8" title="1">m.Logger.Info("Work request affected resources", "resources", resources)
        if nodePoolId == nil </span><span class="cov0" title="0">{
                return nil, errors.New(fmt.Sprintf("node pool ws not created with the request, please create a "+
                        "support ticket with opc-request-id %s", *wrResponse.OpcRequestId))
        }</span>
        <span class="cov8" title="1">m.OCIVirtualMachinePool.Spec.ID = nodePoolId
        m.Info("Created Node Pool", "id", nodePoolId)
        return m.getOKEVirtualNodePoolFromOCID(ctx, nodePoolId)</span>
}

func (m *VirtualMachinePoolScope) getOKEVirtualNodePoolFromOCID(ctx context.Context, nodePoolId *string) (*oke.VirtualNodePool, error) <span class="cov8" title="1">{
        req := oke.GetVirtualNodePoolRequest{VirtualNodePoolId: nodePoolId}

        // Send the request using the service client
        resp, err := m.ContainerEngineClient.GetVirtualNodePool(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return &amp;resp.VirtualNodePool, nil</span>
}

// DeleteVirtualNodePool terminates a virtual nodepool
func (m *VirtualMachinePoolScope) DeleteVirtualNodePool(ctx context.Context, nodePool *oke.VirtualNodePool) error <span class="cov0" title="0">{
        m.Info("Terminating node pool", "id", nodePool.Id)
        req := oke.DeleteVirtualNodePoolRequest{VirtualNodePoolId: nodePool.Id}
        if _, err := m.ContainerEngineClient.DeleteVirtualNodePool(ctx, req); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (m *VirtualMachinePoolScope) getDefinedTags() map[string]map[string]interface{} <span class="cov8" title="1">{
        tags := m.OCIManagedCluster.Spec.DefinedTags
        if tags == nil </span><span class="cov0" title="0">{
                return make(map[string]map[string]interface{})
        }</span>
        <span class="cov8" title="1">definedTags := make(map[string]map[string]interface{})
        for ns, mapNs := range tags </span><span class="cov8" title="1">{
                mapValues := make(map[string]interface{})
                for k, v := range mapNs </span><span class="cov8" title="1">{
                        mapValues[k] = v
                }</span>
                <span class="cov8" title="1">definedTags[ns] = mapValues</span>
        }
        <span class="cov8" title="1">return definedTags</span>
}

func (m *VirtualMachinePoolScope) getFreeFormTags() map[string]string <span class="cov8" title="1">{
        tags := ociutil.BuildClusterTags(m.OCIManagedCluster.Spec.OCIResourceIdentifier)
        if m.OCIManagedCluster.Spec.FreeformTags != nil </span><span class="cov0" title="0">{
                for k, v := range m.OCIManagedCluster.Spec.FreeformTags </span><span class="cov0" title="0">{
                        tags[k] = v
                }</span>
        }

        <span class="cov8" title="1">return tags</span>
}

func (m *VirtualMachinePoolScope) getWorkerMachineSubnets() []string <span class="cov8" title="1">{
        subnetList := make([]string, 0)
        for _, subnet := range ptr.ToSubnetSlice(m.OCIManagedCluster.Spec.NetworkSpec.Vcn.Subnets) </span><span class="cov8" title="1">{
                if subnet.Role == infrastructurev1beta2.WorkerRole </span><span class="cov8" title="1">{
                        subnetList = append(subnetList, subnet.Name)
                }</span>
        }
        <span class="cov8" title="1">return subnetList</span>
}

func (m *VirtualMachinePoolScope) getWorkerMachineNSGs() []string <span class="cov8" title="1">{
        nsgList := make([]string, 0)
        specNsgNames := m.OCIVirtualMachinePool.Spec.NsgNames
        if len(specNsgNames) &gt; 0 </span><span class="cov8" title="1">{
                for _, nsgName := range specNsgNames </span><span class="cov8" title="1">{
                        for _, nsg := range ptr.ToNSGSlice(m.OCIManagedCluster.Spec.NetworkSpec.Vcn.NetworkSecurityGroup.List) </span><span class="cov8" title="1">{
                                if nsg.Name == nsgName </span><span class="cov8" title="1">{
                                        nsgList = append(nsgList, ptr.ToString(nsg.ID))
                                }</span>
                        }
                }
        } else<span class="cov0" title="0"> {
                for _, nsg := range ptr.ToNSGSlice(m.OCIManagedCluster.Spec.NetworkSpec.Vcn.NetworkSecurityGroup.List) </span><span class="cov0" title="0">{
                        if nsg.Role == infrastructurev1beta2.WorkerRole </span><span class="cov0" title="0">{
                                nsgList = append(nsgList, ptr.ToString(nsg.ID))
                        }</span>
                }
        }
        <span class="cov8" title="1">return nsgList</span>
}

func (m *VirtualMachinePoolScope) getWorkerMachineNSGList() []string <span class="cov8" title="1">{
        nsgList := make([]string, 0)
        for _, nsg := range ptr.ToNSGSlice(m.OCIManagedCluster.Spec.NetworkSpec.Vcn.NetworkSecurityGroup.List) </span><span class="cov8" title="1">{
                if nsg.Role == infrastructurev1beta2.WorkerRole </span><span class="cov8" title="1">{
                        nsgList = append(nsgList, nsg.Name)
                }</span>
        }
        <span class="cov8" title="1">return nsgList</span>
}

func (m *VirtualMachinePoolScope) getPodNSGs(nsgs []string) []string <span class="cov8" title="1">{
        nsgList := make([]string, 0)
        if len(nsgs) &gt; 0 </span><span class="cov8" title="1">{
                for _, nsgName := range nsgs </span><span class="cov8" title="1">{
                        for _, nsg := range ptr.ToNSGSlice(m.OCIManagedCluster.Spec.NetworkSpec.Vcn.NetworkSecurityGroup.List) </span><span class="cov8" title="1">{
                                if nsg.Name == nsgName </span><span class="cov8" title="1">{
                                        nsgList = append(nsgList, ptr.ToString(nsg.ID))
                                }</span>
                        }
                }
        }
        <span class="cov8" title="1">return nsgList</span>
}

func (m *VirtualMachinePoolScope) buildPlacementConfig(configs []expinfra1.VirtualNodepoolPlacementConfig) ([]oke.PlacementConfiguration, error) <span class="cov8" title="1">{
        placementConfigs := make([]oke.PlacementConfiguration, 0)
        for _, config := range configs </span><span class="cov8" title="1">{
                subnetId := m.getSubnet(config.SubnetName)
                if subnetId == nil </span><span class="cov8" title="1">{
                        return nil, errors.New(fmt.Sprintf("worker subnet with name %s is not present in spec",
                                *config.SubnetName))
                }</span>
                <span class="cov8" title="1">placementConfigs = append(placementConfigs, oke.PlacementConfiguration{
                        AvailabilityDomain: config.AvailabilityDomain,
                        SubnetId:           subnetId,
                        FaultDomain:        config.FaultDomains,
                })</span>
        }
        <span class="cov8" title="1">return placementConfigs, nil</span>
}

func (m *VirtualMachinePoolScope) getInitialNodeKeyValuePairs() []oke.InitialVirtualNodeLabel <span class="cov8" title="1">{
        keyValues := make([]oke.InitialVirtualNodeLabel, 0)
        for _, kv := range m.OCIVirtualMachinePool.Spec.InitialVirtualNodeLabels </span><span class="cov8" title="1">{
                keyValues = append(keyValues, oke.InitialVirtualNodeLabel{
                        Key:   kv.Key,
                        Value: kv.Value,
                })
        }</span>
        <span class="cov8" title="1">return keyValues</span>
}

func (m *VirtualMachinePoolScope) getTaints() []oke.Taint <span class="cov8" title="1">{
        taints := make([]oke.Taint, 0)
        for _, taint := range m.OCIVirtualMachinePool.Spec.Taints </span><span class="cov8" title="1">{
                taints = append(taints, oke.Taint{
                        Key:    taint.Key,
                        Value:  taint.Value,
                        Effect: taint.Effect,
                })
        }</span>
        <span class="cov8" title="1">return taints</span>
}

func (m *VirtualMachinePoolScope) getSubnet(name *string) *string <span class="cov8" title="1">{
        for _, subnet := range ptr.ToSubnetSlice(m.OCIManagedCluster.Spec.NetworkSpec.Vcn.Subnets) </span><span class="cov8" title="1">{
                if subnet.Name == *name </span><span class="cov8" title="1">{
                        return subnet.ID
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// UpdateVirtualNodePool updates a virtual node pool, if needed, based on updated spec
func (m *VirtualMachinePoolScope) UpdateVirtualNodePool(ctx context.Context, pool *oke.VirtualNodePool) (bool, error) <span class="cov8" title="1">{
        spec := m.OCIVirtualMachinePool.Spec.DeepCopy()
        setVirtualMachinePoolSpecDefaults(spec)
        nodePoolSizeUpdateRequired := false
        // if replicas is not managed by cluster autoscaler and if the number of nodes in the spec is not equal to number set in the node pool
        // update the node pool
        if !annotations.ReplicasManagedByExternalAutoscaler(m.MachinePool) &amp;&amp; (*m.MachinePool.Spec.Replicas != int32(*pool.Size)) </span><span class="cov8" title="1">{
                nodePoolSizeUpdateRequired = true
        }</span>
        <span class="cov8" title="1">actual := m.getSpecFromAPIObject(pool)
        if !reflect.DeepEqual(spec, actual) ||
                m.getNodePoolName() != *pool.DisplayName || nodePoolSizeUpdateRequired </span><span class="cov8" title="1">{
                m.Logger.Info("Updating virtual node pool")
                // printing json specs will help debug problems when there are spurious/unwanted updates
                jsonSpec, err := json.Marshal(*spec)
                if err != nil </span><span class="cov0" title="0">{
                        return false, err
                }</span>
                <span class="cov8" title="1">jsonActual, err := json.Marshal(*actual)
                if err != nil </span><span class="cov0" title="0">{
                        return false, err
                }</span>
                <span class="cov8" title="1">m.Logger.Info("Virtual Node pool", "spec", jsonSpec, "actual", jsonActual)
                if len(m.OCIVirtualMachinePool.Spec.NsgNames) == 0 </span><span class="cov0" title="0">{
                        m.OCIVirtualMachinePool.Spec.NsgNames = m.getWorkerMachineNSGList()
                }</span>
                <span class="cov8" title="1">placementConfigs := m.OCIVirtualMachinePool.Spec.PlacementConfigs
                placementConfig, err := m.buildPlacementConfig(placementConfigs)
                if err != nil </span><span class="cov0" title="0">{
                        return false, err
                }</span>
                <span class="cov8" title="1">podConfiguration := m.getPodConfiguration()

                nodePoolDetails := oke.UpdateVirtualNodePoolDetails{
                        Size:                     common.Int(int(*m.MachinePool.Spec.Replicas)),
                        DisplayName:              common.String(m.getNodePoolName()),
                        PlacementConfigurations:  placementConfig,
                        NsgIds:                   m.getWorkerMachineNSGs(),
                        InitialVirtualNodeLabels: m.getInitialNodeKeyValuePairs(),
                        PodConfiguration:         podConfiguration,
                        Taints:                   m.getTaints(),
                }

                nodePoolDetails.InitialVirtualNodeLabels = m.getInitialNodeKeyValuePairs()

                req := oke.UpdateVirtualNodePoolRequest{
                        VirtualNodePoolId:            pool.Id,
                        UpdateVirtualNodePoolDetails: nodePoolDetails,
                }
                _, err = m.ContainerEngineClient.UpdateVirtualNodePool(ctx, req)
                if err != nil </span><span class="cov0" title="0">{
                        return false, errors.Wrapf(err, "failed to update Virtual Node Pool")
                }</span>

                <span class="cov8" title="1">m.Info("Updated virtual node pool")
                return true, nil</span>
        } else<span class="cov8" title="1"> {
                m.Info("No reconciliation needed for virtual node pool")
        }</span>
        <span class="cov8" title="1">return false, nil</span>
}

// setVirtualMachinePoolSpecDefaults sets the defaults in the spec as returned by OKE API. We need to set defaults here rather than webhook as
// there is a chance user will edit the cluster
func setVirtualMachinePoolSpecDefaults(spec *infrav2exp.OCIVirtualMachinePoolSpec) <span class="cov8" title="1">{
        spec.ProviderIDList = nil
        spec.ProviderID = nil
}</span>

func (m *VirtualMachinePoolScope) getSpecFromAPIObject(pool *oke.VirtualNodePool) *expinfra1.OCIVirtualMachinePoolSpec <span class="cov8" title="1">{
        spec := expinfra1.OCIVirtualMachinePoolSpec{
                ID: pool.Id,
        }
        if pool.PodConfiguration != nil </span><span class="cov8" title="1">{
                podConfiguration := expinfra1.PodConfig{
                        Shape: pool.PodConfiguration.Shape,
                }
                podConfiguration.NsgNames = GetNsgNamesFromId(pool.PodConfiguration.NsgIds, m.OCIManagedCluster.Spec.NetworkSpec.Vcn.NetworkSecurityGroup.List)
                podConfiguration.SubnetName = common.String(GetSubnetNameFromId(pool.PodConfiguration.SubnetId, m.OCIManagedCluster.Spec.NetworkSpec.Vcn.Subnets))
                spec.PodConfiguration = podConfiguration
        }</span>
        <span class="cov8" title="1">spec.PlacementConfigs = m.buildPlacementConfigFromActual(pool.PlacementConfigurations)
        spec.NsgNames = GetNsgNamesFromId(pool.NsgIds, m.OCIManagedCluster.Spec.NetworkSpec.Vcn.NetworkSecurityGroup.List)
        spec.InitialVirtualNodeLabels = getInitialVirtualNodeLabels(pool.InitialVirtualNodeLabels)
        spec.Taints = getTaints(pool.Taints)
        return &amp;spec</span>
}

func getInitialVirtualNodeLabels(labels []oke.InitialVirtualNodeLabel) []expinfra1.KeyValue <span class="cov8" title="1">{
        if len(labels) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">kv := make([]expinfra1.KeyValue, 0)
        for _, l := range labels </span><span class="cov8" title="1">{
                kv = append(kv, expinfra1.KeyValue{
                        Key:   l.Key,
                        Value: l.Value,
                })
        }</span>
        <span class="cov8" title="1">return kv</span>
}

func getTaints(taints []oke.Taint) []expinfra1.Taint <span class="cov8" title="1">{
        if len(taints) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">kv := make([]expinfra1.Taint, 0)
        for _, l := range taints </span><span class="cov8" title="1">{
                kv = append(kv, expinfra1.Taint{
                        Key:    l.Key,
                        Value:  l.Value,
                        Effect: l.Effect,
                })
        }</span>
        <span class="cov8" title="1">return kv</span>
}

func (m *VirtualMachinePoolScope) buildPlacementConfigFromActual(actualConfigs []oke.PlacementConfiguration) []expinfra1.VirtualNodepoolPlacementConfig <span class="cov8" title="1">{
        configs := make([]expinfra1.VirtualNodepoolPlacementConfig, 0)
        for _, config := range actualConfigs </span><span class="cov8" title="1">{
                configs = append(configs, expinfra1.VirtualNodepoolPlacementConfig{
                        AvailabilityDomain: config.AvailabilityDomain,
                        FaultDomains:       config.FaultDomain,
                        SubnetName:         common.String(GetSubnetNameFromId(config.SubnetId, m.OCIManagedCluster.Spec.NetworkSpec.Vcn.Subnets)),
                })
        }</span>
        <span class="cov8" title="1">return configs</span>
}

func (m *VirtualMachinePoolScope) getPodConfiguration() *oke.PodConfiguration <span class="cov8" title="1">{
        subnetId := m.getSubnet(m.OCIVirtualMachinePool.Spec.PodConfiguration.SubnetName)
        podConfig := m.OCIVirtualMachinePool.Spec.PodConfiguration
        return &amp;oke.PodConfiguration{
                SubnetId: subnetId,
                Shape:    podConfig.Shape,
                NsgIds:   m.getPodNSGs(podConfig.NsgNames),
        }
}</span>
</pre>
		
		<pre class="file" id="file62" style="display: none">/*
 Copyright (c) 2022 Oracle and/or its affiliates.

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

      https://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
*/

package scope

import (
        "context"
        "fmt"

        "github.com/oracle/cluster-api-provider-oci/cloud/ociutil"

        infrastructurev1beta2 "github.com/oracle/cluster-api-provider-oci/api/v1beta2"
        "github.com/oracle/oci-go-sdk/v65/common"
        "github.com/oracle/oci-go-sdk/v65/core"
        "github.com/pkg/errors"
)

func (m *MachineScope) ReconcileVnicAttachments(ctx context.Context) error <span class="cov8" title="1">{
        if m.IsControlPlane() </span><span class="cov8" title="1">{
                return errors.New("cannot attach multiple vnics to ControlPlane machines")
        }</span>

        <span class="cov8" title="1">for index, vnicAttachment := range m.OCIMachine.Spec.VnicAttachments </span><span class="cov8" title="1">{
                if m.vnicAttachmentExists(ctx, vnicAttachment) </span><span class="cov0" title="0">{
                        m.Logger.Info("vnicAttachment", ociutil.DerefString(vnicAttachment.DisplayName), " already exists and is immutable")
                        continue</span>
                }

                <span class="cov8" title="1">vnicId, err := m.createVnicAttachment(ctx, vnicAttachment)
                if err != nil </span><span class="cov8" title="1">{
                        msg := fmt.Sprintf("Error creating VnicAttachment %s for cluster %s",
                                ociutil.DerefString(vnicAttachment.DisplayName), m.Cluster.Name)
                        m.Logger.Error(err, msg)
                        return err
                }</span>

                <span class="cov8" title="1">m.OCIMachine.Spec.VnicAttachments[index].VnicAttachmentId = vnicId</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func (m *MachineScope) createVnicAttachment(ctx context.Context, spec infrastructurev1beta2.VnicAttachment) (*string, error) <span class="cov8" title="1">{
        vnicName := spec.DisplayName

        // Default to machine subnet if spec doesn't supply one
        subnetId := m.getWorkerMachineSubnet()
        if spec.SubnetName != "" </span><span class="cov0" title="0">{
                var err error
                subnetId, err = m.getMachineSubnet(spec.SubnetName)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        <span class="cov8" title="1">tags := m.getFreeFormTags()

        definedTags := ConvertMachineDefinedTags(m.OCIMachine.Spec.DefinedTags)

        if spec.NicIndex == nil </span><span class="cov0" title="0">{
                spec.NicIndex = common.Int(0)
        }</span>

        <span class="cov8" title="1">secondVnic := core.AttachVnicDetails{
                DisplayName: vnicName,
                NicIndex:    spec.NicIndex,
                InstanceId:  m.OCIMachine.Spec.InstanceId,
                CreateVnicDetails: &amp;core.CreateVnicDetails{
                        SubnetId:               subnetId,
                        AssignPublicIp:         common.Bool(spec.AssignPublicIp),
                        FreeformTags:           tags,
                        DefinedTags:            definedTags,
                        HostnameLabel:          m.OCIMachine.Spec.NetworkDetails.HostnameLabel,
                        NsgIds:                 m.getWorkerMachineNSGs(),
                        SkipSourceDestCheck:    m.OCIMachine.Spec.NetworkDetails.SkipSourceDestCheck,
                        AssignPrivateDnsRecord: m.OCIMachine.Spec.NetworkDetails.AssignPrivateDnsRecord,
                        DisplayName:            vnicName,
                },
        }

        req := core.AttachVnicRequest{AttachVnicDetails: secondVnic}
        resp, err := m.ComputeClient.AttachVnic(ctx, req)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return resp.Id, nil</span>
}

func (m *MachineScope) vnicAttachmentExists(ctx context.Context, vnic infrastructurev1beta2.VnicAttachment) bool <span class="cov8" title="1">{

        found := false
        var page *string
        for </span><span class="cov8" title="1">{
                resp, err := m.ComputeClient.ListVnicAttachments(ctx, core.ListVnicAttachmentsRequest{
                        InstanceId:    m.GetInstanceId(),
                        CompartmentId: common.String(m.getCompartmentId()),
                        Page:          page,
                })
                if err != nil </span><span class="cov0" title="0">{
                        return false
                }</span>
                <span class="cov8" title="1">for _, attachment := range resp.Items </span><span class="cov8" title="1">{
                        if ociutil.DerefString(attachment.DisplayName) == ociutil.DerefString(vnic.DisplayName) </span><span class="cov0" title="0">{
                                m.Logger.Info("Vnic is already attached ", attachment)
                                return true
                        }</span>
                }

                <span class="cov8" title="1">if resp.OpcNextPage == nil </span><span class="cov8" title="1">{
                        break</span>
                } else<span class="cov0" title="0"> {
                        page = resp.OpcNextPage
                }</span>
        }
        <span class="cov8" title="1">return found</span>
}
</pre>
		
		<pre class="file" id="file63" style="display: none">/*
Copyright (c) 2021, 2022 Oracle and/or its affiliates.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package base

import (
        "context"
        "encoding/base64"
        "fmt"
        "net/http"
        "time"

        "github.com/go-logr/logr"
        "github.com/oracle/oci-go-sdk/v65/common"
        "github.com/pkg/errors"
)

var (
        // list of required headers for generation and parsing.
        requiredHeaders = []string{"date", "authorization"}
)

type Client struct {
        endpoint string
        logger   *logr.Logger
        signer   common.HTTPRequestSigner
}

// NewBaseClient creates a new base client
func NewBaseClient(configProvider common.ConfigurationProvider, logger *logr.Logger) (BaseClient, error) <span class="cov0" title="0">{
        region, err := configProvider.Region()
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.New("more than one resources are affected by the work request to create the cluster")
        }</span>

        <span class="cov0" title="0">endpoint := common.StringToRegion(region).EndpointForTemplate("containerengine", "containerengine.{region}.{secondLevelDomain}")
        signer := common.DefaultRequestSigner(configProvider)

        return &amp;Client{
                endpoint: endpoint,
                logger:   logger,
                signer:   signer,
        }, err</span>
}

func (c *Client) GenerateToken(ctx context.Context, clusterID string) (string, error) <span class="cov0" title="0">{
        endpoint := fmt.Sprintf(
                "https://%s/cluster_request/%s",
                c.endpoint,
                clusterID)

        req, err := http.NewRequest(http.MethodGet, endpoint, nil)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">req.Header.Set("date", time.Now().UTC().Format(http.TimeFormat))
        err = c.signer.Sign(req)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">url := req.URL
        query := url.Query()
        for _, header := range requiredHeaders </span><span class="cov0" title="0">{
                query.Set(header, req.Header.Get(header))
        }</span>
        <span class="cov0" title="0">url.RawQuery = query.Encode()
        return base64.URLEncoding.EncodeToString([]byte(url.String())), nil</span>
}
</pre>
		
		<pre class="file" id="file64" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: client.go

// Package mock_base is a generated GoMock package.
package mock_base

import (
        context "context"
        reflect "reflect"

        gomock "github.com/golang/mock/gomock"
)

// MockBaseClient is a mock_computemanagement of BaseClient interface.
type MockBaseClient struct {
        ctrl     *gomock.Controller
        recorder *MockBaseClientMockRecorder
}

// MockBaseClientMockRecorder is the mock_computemanagement recorder for MockBaseClient.
type MockBaseClientMockRecorder struct {
        mock *MockBaseClient
}

// NewMockBaseClient creates a new mock_computemanagement instance.
func NewMockBaseClient(ctrl *gomock.Controller) *MockBaseClient <span class="cov0" title="0">{
        mock := &amp;MockBaseClient{ctrl: ctrl}
        mock.recorder = &amp;MockBaseClientMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockBaseClient) EXPECT() *MockBaseClientMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// GenerateToken mocks base method.
func (m *MockBaseClient) GenerateToken(ctx context.Context, clusterID string) (string, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GenerateToken", ctx, clusterID)
        ret0, _ := ret[0].(string)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GenerateToken indicates an expected call of GenerateToken.
func (mr *MockBaseClientMockRecorder) GenerateToken(ctx, clusterID interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GenerateToken", reflect.TypeOf((*MockBaseClient)(nil).GenerateToken), ctx, clusterID)
}</span>
</pre>
		
		<pre class="file" id="file65" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: client.go

// Package mock_compute is a generated GoMock package.
package mock_compute

import (
        context "context"
        reflect "reflect"

        gomock "github.com/golang/mock/gomock"
        core "github.com/oracle/oci-go-sdk/v65/core"
)

// MockComputeClient is a mock_computemanagement of ComputeClient interface.
type MockComputeClient struct {
        ctrl     *gomock.Controller
        recorder *MockComputeClientMockRecorder
}

// MockComputeClientMockRecorder is the mock_computemanagement recorder for MockComputeClient.
type MockComputeClientMockRecorder struct {
        mock *MockComputeClient
}

// NewMockComputeClient creates a new mock_computemanagement instance.
func NewMockComputeClient(ctrl *gomock.Controller) *MockComputeClient <span class="cov0" title="0">{
        mock := &amp;MockComputeClient{ctrl: ctrl}
        mock.recorder = &amp;MockComputeClientMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockComputeClient) EXPECT() *MockComputeClientMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// AttachVnic mocks base method.
func (m *MockComputeClient) AttachVnic(ctx context.Context, request core.AttachVnicRequest) (core.AttachVnicResponse, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "AttachVnic", ctx, request)
        ret0, _ := ret[0].(core.AttachVnicResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// AttachVnic indicates an expected call of AttachVnic.
func (mr *MockComputeClientMockRecorder) AttachVnic(ctx, request interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AttachVnic", reflect.TypeOf((*MockComputeClient)(nil).AttachVnic), ctx, request)
}</span>

// GetInstance mocks base method.
func (m *MockComputeClient) GetInstance(ctx context.Context, request core.GetInstanceRequest) (core.GetInstanceResponse, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetInstance", ctx, request)
        ret0, _ := ret[0].(core.GetInstanceResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetInstance indicates an expected call of GetInstance.
func (mr *MockComputeClientMockRecorder) GetInstance(ctx, request interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetInstance", reflect.TypeOf((*MockComputeClient)(nil).GetInstance), ctx, request)
}</span>

// LaunchInstance mocks base method.
func (m *MockComputeClient) LaunchInstance(ctx context.Context, request core.LaunchInstanceRequest) (core.LaunchInstanceResponse, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "LaunchInstance", ctx, request)
        ret0, _ := ret[0].(core.LaunchInstanceResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// LaunchInstance indicates an expected call of LaunchInstance.
func (mr *MockComputeClientMockRecorder) LaunchInstance(ctx, request interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "LaunchInstance", reflect.TypeOf((*MockComputeClient)(nil).LaunchInstance), ctx, request)
}</span>

// ListInstances mocks base method.
func (m *MockComputeClient) ListInstances(ctx context.Context, request core.ListInstancesRequest) (core.ListInstancesResponse, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "ListInstances", ctx, request)
        ret0, _ := ret[0].(core.ListInstancesResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// ListInstances indicates an expected call of ListInstances.
func (mr *MockComputeClientMockRecorder) ListInstances(ctx, request interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListInstances", reflect.TypeOf((*MockComputeClient)(nil).ListInstances), ctx, request)
}</span>

// ListVnicAttachments mocks base method.
func (m *MockComputeClient) ListVnicAttachments(ctx context.Context, request core.ListVnicAttachmentsRequest) (core.ListVnicAttachmentsResponse, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "ListVnicAttachments", ctx, request)
        ret0, _ := ret[0].(core.ListVnicAttachmentsResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// ListVnicAttachments indicates an expected call of ListVnicAttachments.
func (mr *MockComputeClientMockRecorder) ListVnicAttachments(ctx, request interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListVnicAttachments", reflect.TypeOf((*MockComputeClient)(nil).ListVnicAttachments), ctx, request)
}</span>

// TerminateInstance mocks base method.
func (m *MockComputeClient) TerminateInstance(ctx context.Context, request core.TerminateInstanceRequest) (core.TerminateInstanceResponse, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "TerminateInstance", ctx, request)
        ret0, _ := ret[0].(core.TerminateInstanceResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// TerminateInstance indicates an expected call of TerminateInstance.
func (mr *MockComputeClientMockRecorder) TerminateInstance(ctx, request interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "TerminateInstance", reflect.TypeOf((*MockComputeClient)(nil).TerminateInstance), ctx, request)
}</span>
</pre>
		
		<pre class="file" id="file66" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: client.go

// Package mock_computemanagement is a generated GoMock package.
package mock_computemanagement

import (
        context "context"
        reflect "reflect"

        gomock "github.com/golang/mock/gomock"
        core "github.com/oracle/oci-go-sdk/v65/core"
)

// MockClient is a mock of Client interface.
type MockClient struct {
        ctrl     *gomock.Controller
        recorder *MockClientMockRecorder
}

// MockClientMockRecorder is the mock recorder for MockClient.
type MockClientMockRecorder struct {
        mock *MockClient
}

// NewMockClient creates a new mock instance.
func NewMockClient(ctrl *gomock.Controller) *MockClient <span class="cov0" title="0">{
        mock := &amp;MockClient{ctrl: ctrl}
        mock.recorder = &amp;MockClientMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockClient) EXPECT() *MockClientMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// CreateInstanceConfiguration mocks base method.
func (m *MockClient) CreateInstanceConfiguration(ctx context.Context, request core.CreateInstanceConfigurationRequest) (core.CreateInstanceConfigurationResponse, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "CreateInstanceConfiguration", ctx, request)
        ret0, _ := ret[0].(core.CreateInstanceConfigurationResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// CreateInstanceConfiguration indicates an expected call of CreateInstanceConfiguration.
func (mr *MockClientMockRecorder) CreateInstanceConfiguration(ctx, request interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateInstanceConfiguration", reflect.TypeOf((*MockClient)(nil).CreateInstanceConfiguration), ctx, request)
}</span>

// CreateInstancePool mocks base method.
func (m *MockClient) CreateInstancePool(ctx context.Context, request core.CreateInstancePoolRequest) (core.CreateInstancePoolResponse, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "CreateInstancePool", ctx, request)
        ret0, _ := ret[0].(core.CreateInstancePoolResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// CreateInstancePool indicates an expected call of CreateInstancePool.
func (mr *MockClientMockRecorder) CreateInstancePool(ctx, request interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateInstancePool", reflect.TypeOf((*MockClient)(nil).CreateInstancePool), ctx, request)
}</span>

// DeleteInstanceConfiguration mocks base method.
func (m *MockClient) DeleteInstanceConfiguration(ctx context.Context, request core.DeleteInstanceConfigurationRequest) (core.DeleteInstanceConfigurationResponse, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "DeleteInstanceConfiguration", ctx, request)
        ret0, _ := ret[0].(core.DeleteInstanceConfigurationResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// DeleteInstanceConfiguration indicates an expected call of DeleteInstanceConfiguration.
func (mr *MockClientMockRecorder) DeleteInstanceConfiguration(ctx, request interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteInstanceConfiguration", reflect.TypeOf((*MockClient)(nil).DeleteInstanceConfiguration), ctx, request)
}</span>

// GetInstanceConfiguration mocks base method.
func (m *MockClient) GetInstanceConfiguration(ctx context.Context, request core.GetInstanceConfigurationRequest) (core.GetInstanceConfigurationResponse, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetInstanceConfiguration", ctx, request)
        ret0, _ := ret[0].(core.GetInstanceConfigurationResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetInstanceConfiguration indicates an expected call of GetInstanceConfiguration.
func (mr *MockClientMockRecorder) GetInstanceConfiguration(ctx, request interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetInstanceConfiguration", reflect.TypeOf((*MockClient)(nil).GetInstanceConfiguration), ctx, request)
}</span>

// GetInstancePool mocks base method.
func (m *MockClient) GetInstancePool(ctx context.Context, request core.GetInstancePoolRequest) (core.GetInstancePoolResponse, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetInstancePool", ctx, request)
        ret0, _ := ret[0].(core.GetInstancePoolResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetInstancePool indicates an expected call of GetInstancePool.
func (mr *MockClientMockRecorder) GetInstancePool(ctx, request interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetInstancePool", reflect.TypeOf((*MockClient)(nil).GetInstancePool), ctx, request)
}</span>

// ListInstanceConfigurations mocks base method.
func (m *MockClient) ListInstanceConfigurations(ctx context.Context, request core.ListInstanceConfigurationsRequest) (core.ListInstanceConfigurationsResponse, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "ListInstanceConfigurations", ctx, request)
        ret0, _ := ret[0].(core.ListInstanceConfigurationsResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// ListInstanceConfigurations indicates an expected call of ListInstanceConfigurations.
func (mr *MockClientMockRecorder) ListInstanceConfigurations(ctx, request interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListInstanceConfigurations", reflect.TypeOf((*MockClient)(nil).ListInstanceConfigurations), ctx, request)
}</span>

// ListInstancePoolInstances mocks base method.
func (m *MockClient) ListInstancePoolInstances(ctx context.Context, request core.ListInstancePoolInstancesRequest) (core.ListInstancePoolInstancesResponse, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "ListInstancePoolInstances", ctx, request)
        ret0, _ := ret[0].(core.ListInstancePoolInstancesResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// ListInstancePoolInstances indicates an expected call of ListInstancePoolInstances.
func (mr *MockClientMockRecorder) ListInstancePoolInstances(ctx, request interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListInstancePoolInstances", reflect.TypeOf((*MockClient)(nil).ListInstancePoolInstances), ctx, request)
}</span>

// ListInstancePools mocks base method.
func (m *MockClient) ListInstancePools(ctx context.Context, request core.ListInstancePoolsRequest) (core.ListInstancePoolsResponse, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "ListInstancePools", ctx, request)
        ret0, _ := ret[0].(core.ListInstancePoolsResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// ListInstancePools indicates an expected call of ListInstancePools.
func (mr *MockClientMockRecorder) ListInstancePools(ctx, request interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListInstancePools", reflect.TypeOf((*MockClient)(nil).ListInstancePools), ctx, request)
}</span>

// TerminateInstancePool mocks base method.
func (m *MockClient) TerminateInstancePool(ctx context.Context, request core.TerminateInstancePoolRequest) (core.TerminateInstancePoolResponse, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "TerminateInstancePool", ctx, request)
        ret0, _ := ret[0].(core.TerminateInstancePoolResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// TerminateInstancePool indicates an expected call of TerminateInstancePool.
func (mr *MockClientMockRecorder) TerminateInstancePool(ctx, request interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "TerminateInstancePool", reflect.TypeOf((*MockClient)(nil).TerminateInstancePool), ctx, request)
}</span>

// UpdateInstancePool mocks base method.
func (m *MockClient) UpdateInstancePool(ctx context.Context, request core.UpdateInstancePoolRequest) (core.UpdateInstancePoolResponse, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "UpdateInstancePool", ctx, request)
        ret0, _ := ret[0].(core.UpdateInstancePoolResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// UpdateInstancePool indicates an expected call of UpdateInstancePool.
func (mr *MockClientMockRecorder) UpdateInstancePool(ctx, request interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateInstancePool", reflect.TypeOf((*MockClient)(nil).UpdateInstancePool), ctx, request)
}</span>
</pre>
		
		<pre class="file" id="file67" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: client.go

// Package mock_containerengine is a generated GoMock package.
package mock_containerengine

import (
        context "context"
        reflect "reflect"

        gomock "github.com/golang/mock/gomock"
        containerengine "github.com/oracle/oci-go-sdk/v65/containerengine"
)

// MockClient is a mock of Client interface.
type MockClient struct {
        ctrl     *gomock.Controller
        recorder *MockClientMockRecorder
}

// MockClientMockRecorder is the mock recorder for MockClient.
type MockClientMockRecorder struct {
        mock *MockClient
}

// NewMockClient creates a new mock instance.
func NewMockClient(ctrl *gomock.Controller) *MockClient <span class="cov0" title="0">{
        mock := &amp;MockClient{ctrl: ctrl}
        mock.recorder = &amp;MockClientMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockClient) EXPECT() *MockClientMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// CreateCluster mocks base method.
func (m *MockClient) CreateCluster(ctx context.Context, request containerengine.CreateClusterRequest) (containerengine.CreateClusterResponse, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "CreateCluster", ctx, request)
        ret0, _ := ret[0].(containerengine.CreateClusterResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// CreateCluster indicates an expected call of CreateCluster.
func (mr *MockClientMockRecorder) CreateCluster(ctx, request interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateCluster", reflect.TypeOf((*MockClient)(nil).CreateCluster), ctx, request)
}</span>

// CreateKubeconfig mocks base method.
func (m *MockClient) CreateKubeconfig(ctx context.Context, request containerengine.CreateKubeconfigRequest) (containerengine.CreateKubeconfigResponse, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "CreateKubeconfig", ctx, request)
        ret0, _ := ret[0].(containerengine.CreateKubeconfigResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// CreateKubeconfig indicates an expected call of CreateKubeconfig.
func (mr *MockClientMockRecorder) CreateKubeconfig(ctx, request interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateKubeconfig", reflect.TypeOf((*MockClient)(nil).CreateKubeconfig), ctx, request)
}</span>

// CreateNodePool mocks base method.
func (m *MockClient) CreateNodePool(ctx context.Context, request containerengine.CreateNodePoolRequest) (containerengine.CreateNodePoolResponse, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "CreateNodePool", ctx, request)
        ret0, _ := ret[0].(containerengine.CreateNodePoolResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// CreateNodePool indicates an expected call of CreateNodePool.
func (mr *MockClientMockRecorder) CreateNodePool(ctx, request interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateNodePool", reflect.TypeOf((*MockClient)(nil).CreateNodePool), ctx, request)
}</span>

// CreateVirtualNodePool mocks base method.
func (m *MockClient) CreateVirtualNodePool(ctx context.Context, request containerengine.CreateVirtualNodePoolRequest) (containerengine.CreateVirtualNodePoolResponse, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "CreateVirtualNodePool", ctx, request)
        ret0, _ := ret[0].(containerengine.CreateVirtualNodePoolResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// CreateVirtualNodePool indicates an expected call of CreateVirtualNodePool.
func (mr *MockClientMockRecorder) CreateVirtualNodePool(ctx, request interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateVirtualNodePool", reflect.TypeOf((*MockClient)(nil).CreateVirtualNodePool), ctx, request)
}</span>

// DeleteCluster mocks base method.
func (m *MockClient) DeleteCluster(ctx context.Context, request containerengine.DeleteClusterRequest) (containerengine.DeleteClusterResponse, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "DeleteCluster", ctx, request)
        ret0, _ := ret[0].(containerengine.DeleteClusterResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// DeleteCluster indicates an expected call of DeleteCluster.
func (mr *MockClientMockRecorder) DeleteCluster(ctx, request interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteCluster", reflect.TypeOf((*MockClient)(nil).DeleteCluster), ctx, request)
}</span>

// DeleteNodePool mocks base method.
func (m *MockClient) DeleteNodePool(ctx context.Context, request containerengine.DeleteNodePoolRequest) (containerengine.DeleteNodePoolResponse, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "DeleteNodePool", ctx, request)
        ret0, _ := ret[0].(containerengine.DeleteNodePoolResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// DeleteNodePool indicates an expected call of DeleteNodePool.
func (mr *MockClientMockRecorder) DeleteNodePool(ctx, request interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteNodePool", reflect.TypeOf((*MockClient)(nil).DeleteNodePool), ctx, request)
}</span>

// DeleteVirtualNodePool mocks base method.
func (m *MockClient) DeleteVirtualNodePool(ctx context.Context, request containerengine.DeleteVirtualNodePoolRequest) (containerengine.DeleteVirtualNodePoolResponse, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "DeleteVirtualNodePool", ctx, request)
        ret0, _ := ret[0].(containerengine.DeleteVirtualNodePoolResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// DeleteVirtualNodePool indicates an expected call of DeleteVirtualNodePool.
func (mr *MockClientMockRecorder) DeleteVirtualNodePool(ctx, request interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteVirtualNodePool", reflect.TypeOf((*MockClient)(nil).DeleteVirtualNodePool), ctx, request)
}</span>

// DisableAddon mocks base method.
func (m *MockClient) DisableAddon(ctx context.Context, request containerengine.DisableAddonRequest) (containerengine.DisableAddonResponse, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "DisableAddon", ctx, request)
        ret0, _ := ret[0].(containerengine.DisableAddonResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// DisableAddon indicates an expected call of DisableAddon.
func (mr *MockClientMockRecorder) DisableAddon(ctx, request interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DisableAddon", reflect.TypeOf((*MockClient)(nil).DisableAddon), ctx, request)
}</span>

// GetAddon mocks base method.
func (m *MockClient) GetAddon(ctx context.Context, request containerengine.GetAddonRequest) (containerengine.GetAddonResponse, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetAddon", ctx, request)
        ret0, _ := ret[0].(containerengine.GetAddonResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetAddon indicates an expected call of GetAddon.
func (mr *MockClientMockRecorder) GetAddon(ctx, request interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetAddon", reflect.TypeOf((*MockClient)(nil).GetAddon), ctx, request)
}</span>

// GetCluster mocks base method.
func (m *MockClient) GetCluster(ctx context.Context, request containerengine.GetClusterRequest) (containerengine.GetClusterResponse, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetCluster", ctx, request)
        ret0, _ := ret[0].(containerengine.GetClusterResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetCluster indicates an expected call of GetCluster.
func (mr *MockClientMockRecorder) GetCluster(ctx, request interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetCluster", reflect.TypeOf((*MockClient)(nil).GetCluster), ctx, request)
}</span>

// GetNodePool mocks base method.
func (m *MockClient) GetNodePool(ctx context.Context, request containerengine.GetNodePoolRequest) (containerengine.GetNodePoolResponse, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetNodePool", ctx, request)
        ret0, _ := ret[0].(containerengine.GetNodePoolResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetNodePool indicates an expected call of GetNodePool.
func (mr *MockClientMockRecorder) GetNodePool(ctx, request interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetNodePool", reflect.TypeOf((*MockClient)(nil).GetNodePool), ctx, request)
}</span>

// GetNodePoolOptions mocks base method.
func (m *MockClient) GetNodePoolOptions(ctx context.Context, request containerengine.GetNodePoolOptionsRequest) (containerengine.GetNodePoolOptionsResponse, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetNodePoolOptions", ctx, request)
        ret0, _ := ret[0].(containerengine.GetNodePoolOptionsResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetNodePoolOptions indicates an expected call of GetNodePoolOptions.
func (mr *MockClientMockRecorder) GetNodePoolOptions(ctx, request interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetNodePoolOptions", reflect.TypeOf((*MockClient)(nil).GetNodePoolOptions), ctx, request)
}</span>

// GetVirtualNodePool mocks base method.
func (m *MockClient) GetVirtualNodePool(ctx context.Context, request containerengine.GetVirtualNodePoolRequest) (containerengine.GetVirtualNodePoolResponse, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetVirtualNodePool", ctx, request)
        ret0, _ := ret[0].(containerengine.GetVirtualNodePoolResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetVirtualNodePool indicates an expected call of GetVirtualNodePool.
func (mr *MockClientMockRecorder) GetVirtualNodePool(ctx, request interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetVirtualNodePool", reflect.TypeOf((*MockClient)(nil).GetVirtualNodePool), ctx, request)
}</span>

// GetWorkRequest mocks base method.
func (m *MockClient) GetWorkRequest(ctx context.Context, request containerengine.GetWorkRequestRequest) (containerengine.GetWorkRequestResponse, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetWorkRequest", ctx, request)
        ret0, _ := ret[0].(containerengine.GetWorkRequestResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetWorkRequest indicates an expected call of GetWorkRequest.
func (mr *MockClientMockRecorder) GetWorkRequest(ctx, request interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetWorkRequest", reflect.TypeOf((*MockClient)(nil).GetWorkRequest), ctx, request)
}</span>

// InstallAddon mocks base method.
func (m *MockClient) InstallAddon(ctx context.Context, request containerengine.InstallAddonRequest) (containerengine.InstallAddonResponse, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "InstallAddon", ctx, request)
        ret0, _ := ret[0].(containerengine.InstallAddonResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// InstallAddon indicates an expected call of InstallAddon.
func (mr *MockClientMockRecorder) InstallAddon(ctx, request interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "InstallAddon", reflect.TypeOf((*MockClient)(nil).InstallAddon), ctx, request)
}</span>

// ListAddons mocks base method.
func (m *MockClient) ListAddons(ctx context.Context, request containerengine.ListAddonsRequest) (containerengine.ListAddonsResponse, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "ListAddons", ctx, request)
        ret0, _ := ret[0].(containerengine.ListAddonsResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// ListAddons indicates an expected call of ListAddons.
func (mr *MockClientMockRecorder) ListAddons(ctx, request interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListAddons", reflect.TypeOf((*MockClient)(nil).ListAddons), ctx, request)
}</span>

// ListClusters mocks base method.
func (m *MockClient) ListClusters(ctx context.Context, request containerengine.ListClustersRequest) (containerengine.ListClustersResponse, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "ListClusters", ctx, request)
        ret0, _ := ret[0].(containerengine.ListClustersResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// ListClusters indicates an expected call of ListClusters.
func (mr *MockClientMockRecorder) ListClusters(ctx, request interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListClusters", reflect.TypeOf((*MockClient)(nil).ListClusters), ctx, request)
}</span>

// ListNodePools mocks base method.
func (m *MockClient) ListNodePools(ctx context.Context, request containerengine.ListNodePoolsRequest) (containerengine.ListNodePoolsResponse, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "ListNodePools", ctx, request)
        ret0, _ := ret[0].(containerengine.ListNodePoolsResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// ListNodePools indicates an expected call of ListNodePools.
func (mr *MockClientMockRecorder) ListNodePools(ctx, request interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListNodePools", reflect.TypeOf((*MockClient)(nil).ListNodePools), ctx, request)
}</span>

// ListVirtualNodePools mocks base method.
func (m *MockClient) ListVirtualNodePools(ctx context.Context, request containerengine.ListVirtualNodePoolsRequest) (containerengine.ListVirtualNodePoolsResponse, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "ListVirtualNodePools", ctx, request)
        ret0, _ := ret[0].(containerengine.ListVirtualNodePoolsResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// ListVirtualNodePools indicates an expected call of ListVirtualNodePools.
func (mr *MockClientMockRecorder) ListVirtualNodePools(ctx, request interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListVirtualNodePools", reflect.TypeOf((*MockClient)(nil).ListVirtualNodePools), ctx, request)
}</span>

// ListVirtualNodes mocks base method.
func (m *MockClient) ListVirtualNodes(ctx context.Context, request containerengine.ListVirtualNodesRequest) (containerengine.ListVirtualNodesResponse, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "ListVirtualNodes", ctx, request)
        ret0, _ := ret[0].(containerengine.ListVirtualNodesResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// ListVirtualNodes indicates an expected call of ListVirtualNodes.
func (mr *MockClientMockRecorder) ListVirtualNodes(ctx, request interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListVirtualNodes", reflect.TypeOf((*MockClient)(nil).ListVirtualNodes), ctx, request)
}</span>

// UpdateAddon mocks base method.
func (m *MockClient) UpdateAddon(ctx context.Context, request containerengine.UpdateAddonRequest) (containerengine.UpdateAddonResponse, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "UpdateAddon", ctx, request)
        ret0, _ := ret[0].(containerengine.UpdateAddonResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// UpdateAddon indicates an expected call of UpdateAddon.
func (mr *MockClientMockRecorder) UpdateAddon(ctx, request interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateAddon", reflect.TypeOf((*MockClient)(nil).UpdateAddon), ctx, request)
}</span>

// UpdateCluster mocks base method.
func (m *MockClient) UpdateCluster(ctx context.Context, request containerengine.UpdateClusterRequest) (containerengine.UpdateClusterResponse, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "UpdateCluster", ctx, request)
        ret0, _ := ret[0].(containerengine.UpdateClusterResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// UpdateCluster indicates an expected call of UpdateCluster.
func (mr *MockClientMockRecorder) UpdateCluster(ctx, request interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateCluster", reflect.TypeOf((*MockClient)(nil).UpdateCluster), ctx, request)
}</span>

// UpdateNodePool mocks base method.
func (m *MockClient) UpdateNodePool(ctx context.Context, request containerengine.UpdateNodePoolRequest) (containerengine.UpdateNodePoolResponse, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "UpdateNodePool", ctx, request)
        ret0, _ := ret[0].(containerengine.UpdateNodePoolResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// UpdateNodePool indicates an expected call of UpdateNodePool.
func (mr *MockClientMockRecorder) UpdateNodePool(ctx, request interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateNodePool", reflect.TypeOf((*MockClient)(nil).UpdateNodePool), ctx, request)
}</span>

// UpdateVirtualNodePool mocks base method.
func (m *MockClient) UpdateVirtualNodePool(ctx context.Context, request containerengine.UpdateVirtualNodePoolRequest) (containerengine.UpdateVirtualNodePoolResponse, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "UpdateVirtualNodePool", ctx, request)
        ret0, _ := ret[0].(containerengine.UpdateVirtualNodePoolResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// UpdateVirtualNodePool indicates an expected call of UpdateVirtualNodePool.
func (mr *MockClientMockRecorder) UpdateVirtualNodePool(ctx, request interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateVirtualNodePool", reflect.TypeOf((*MockClient)(nil).UpdateVirtualNodePool), ctx, request)
}</span>
</pre>
		
		<pre class="file" id="file68" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: /Users/aribandy/work/src/sigs.k8s.io/cluster-api-provider-oci/cloud/services/identity/client.go

// Package mock_identity is a generated GoMock package.
package mock_identity

import (
        context "context"
        reflect "reflect"

        gomock "github.com/golang/mock/gomock"
        identity "github.com/oracle/oci-go-sdk/v65/identity"
)

// MockClient is a mock_computemanagement of Client interface.
type MockClient struct {
        ctrl     *gomock.Controller
        recorder *MockClientMockRecorder
}

// MockClientMockRecorder is the mock_computemanagement recorder for MockClient.
type MockClientMockRecorder struct {
        mock *MockClient
}

// NewMockClient creates a new mock_computemanagement instance.
func NewMockClient(ctrl *gomock.Controller) *MockClient <span class="cov0" title="0">{
        mock := &amp;MockClient{ctrl: ctrl}
        mock.recorder = &amp;MockClientMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockClient) EXPECT() *MockClientMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// ListAvailabilityDomains mocks base method.
func (m *MockClient) ListAvailabilityDomains(ctx context.Context, request identity.ListAvailabilityDomainsRequest) (identity.ListAvailabilityDomainsResponse, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "ListAvailabilityDomains", ctx, request)
        ret0, _ := ret[0].(identity.ListAvailabilityDomainsResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// ListAvailabilityDomains indicates an expected call of ListAvailabilityDomains.
func (mr *MockClientMockRecorder) ListAvailabilityDomains(ctx, request interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListAvailabilityDomains", reflect.TypeOf((*MockClient)(nil).ListAvailabilityDomains), ctx, request)
}</span>

// ListFaultDomains mocks base method.
func (m *MockClient) ListFaultDomains(ctx context.Context, request identity.ListFaultDomainsRequest) (identity.ListFaultDomainsResponse, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "ListFaultDomains", ctx, request)
        ret0, _ := ret[0].(identity.ListFaultDomainsResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// ListFaultDomains indicates an expected call of ListFaultDomains.
func (mr *MockClientMockRecorder) ListFaultDomains(ctx, request interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListFaultDomains", reflect.TypeOf((*MockClient)(nil).ListFaultDomains), ctx, request)
}</span>

// ListRegions mocks base method.
func (m *MockClient) ListRegions(ctx context.Context) (identity.ListRegionsResponse, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "ListRegions", ctx)
        ret0, _ := ret[0].(identity.ListRegionsResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// ListRegions indicates an expected call of ListRegions.
func (mr *MockClientMockRecorder) ListRegions(ctx interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListRegions", reflect.TypeOf((*MockClient)(nil).ListRegions), ctx)
}</span>
</pre>
		
		<pre class="file" id="file69" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: client.go

// Package mock_lb is a generated GoMock package.
package mock_lb

import (
        context "context"
        reflect "reflect"

        gomock "github.com/golang/mock/gomock"
        loadbalancer "github.com/oracle/oci-go-sdk/v65/loadbalancer"
)

// MockLoadBalancerClient is a mock of LoadBalancerClient interface.
type MockLoadBalancerClient struct {
        ctrl     *gomock.Controller
        recorder *MockLoadBalancerClientMockRecorder
}

// MockLoadBalancerClientMockRecorder is the mock recorder for MockLoadBalancerClient.
type MockLoadBalancerClientMockRecorder struct {
        mock *MockLoadBalancerClient
}

// NewMockLoadBalancerClient creates a new mock instance.
func NewMockLoadBalancerClient(ctrl *gomock.Controller) *MockLoadBalancerClient <span class="cov0" title="0">{
        mock := &amp;MockLoadBalancerClient{ctrl: ctrl}
        mock.recorder = &amp;MockLoadBalancerClientMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockLoadBalancerClient) EXPECT() *MockLoadBalancerClientMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// CreateBackend mocks base method.
func (m *MockLoadBalancerClient) CreateBackend(arg0 context.Context, arg1 loadbalancer.CreateBackendRequest) (loadbalancer.CreateBackendResponse, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "CreateBackend", arg0, arg1)
        ret0, _ := ret[0].(loadbalancer.CreateBackendResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// CreateBackend indicates an expected call of CreateBackend.
func (mr *MockLoadBalancerClientMockRecorder) CreateBackend(arg0, arg1 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateBackend", reflect.TypeOf((*MockLoadBalancerClient)(nil).CreateBackend), arg0, arg1)
}</span>

// CreateLoadBalancer mocks base method.
func (m *MockLoadBalancerClient) CreateLoadBalancer(arg0 context.Context, arg1 loadbalancer.CreateLoadBalancerRequest) (loadbalancer.CreateLoadBalancerResponse, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "CreateLoadBalancer", arg0, arg1)
        ret0, _ := ret[0].(loadbalancer.CreateLoadBalancerResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// CreateLoadBalancer indicates an expected call of CreateLoadBalancer.
func (mr *MockLoadBalancerClientMockRecorder) CreateLoadBalancer(arg0, arg1 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateLoadBalancer", reflect.TypeOf((*MockLoadBalancerClient)(nil).CreateLoadBalancer), arg0, arg1)
}</span>

// DeleteBackend mocks base method.
func (m *MockLoadBalancerClient) DeleteBackend(arg0 context.Context, arg1 loadbalancer.DeleteBackendRequest) (loadbalancer.DeleteBackendResponse, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "DeleteBackend", arg0, arg1)
        ret0, _ := ret[0].(loadbalancer.DeleteBackendResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// DeleteBackend indicates an expected call of DeleteBackend.
func (mr *MockLoadBalancerClientMockRecorder) DeleteBackend(arg0, arg1 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteBackend", reflect.TypeOf((*MockLoadBalancerClient)(nil).DeleteBackend), arg0, arg1)
}</span>

// DeleteLoadBalancer mocks base method.
func (m *MockLoadBalancerClient) DeleteLoadBalancer(arg0 context.Context, arg1 loadbalancer.DeleteLoadBalancerRequest) (loadbalancer.DeleteLoadBalancerResponse, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "DeleteLoadBalancer", arg0, arg1)
        ret0, _ := ret[0].(loadbalancer.DeleteLoadBalancerResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// DeleteLoadBalancer indicates an expected call of DeleteLoadBalancer.
func (mr *MockLoadBalancerClientMockRecorder) DeleteLoadBalancer(arg0, arg1 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteLoadBalancer", reflect.TypeOf((*MockLoadBalancerClient)(nil).DeleteLoadBalancer), arg0, arg1)
}</span>

// GetLoadBalancer mocks base method.
func (m *MockLoadBalancerClient) GetLoadBalancer(arg0 context.Context, arg1 loadbalancer.GetLoadBalancerRequest) (loadbalancer.GetLoadBalancerResponse, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetLoadBalancer", arg0, arg1)
        ret0, _ := ret[0].(loadbalancer.GetLoadBalancerResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetLoadBalancer indicates an expected call of GetLoadBalancer.
func (mr *MockLoadBalancerClientMockRecorder) GetLoadBalancer(arg0, arg1 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetLoadBalancer", reflect.TypeOf((*MockLoadBalancerClient)(nil).GetLoadBalancer), arg0, arg1)
}</span>

// GetWorkRequest mocks base method.
func (m *MockLoadBalancerClient) GetWorkRequest(arg0 context.Context, arg1 loadbalancer.GetWorkRequestRequest) (loadbalancer.GetWorkRequestResponse, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetWorkRequest", arg0, arg1)
        ret0, _ := ret[0].(loadbalancer.GetWorkRequestResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetWorkRequest indicates an expected call of GetWorkRequest.
func (mr *MockLoadBalancerClientMockRecorder) GetWorkRequest(arg0, arg1 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetWorkRequest", reflect.TypeOf((*MockLoadBalancerClient)(nil).GetWorkRequest), arg0, arg1)
}</span>

// ListLoadBalancers mocks base method.
func (m *MockLoadBalancerClient) ListLoadBalancers(arg0 context.Context, arg1 loadbalancer.ListLoadBalancersRequest) (loadbalancer.ListLoadBalancersResponse, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "ListLoadBalancers", arg0, arg1)
        ret0, _ := ret[0].(loadbalancer.ListLoadBalancersResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// ListLoadBalancers indicates an expected call of ListLoadBalancers.
func (mr *MockLoadBalancerClientMockRecorder) ListLoadBalancers(arg0, arg1 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListLoadBalancers", reflect.TypeOf((*MockLoadBalancerClient)(nil).ListLoadBalancers), arg0, arg1)
}</span>

// UpdateLoadBalancer mocks base method.
func (m *MockLoadBalancerClient) UpdateLoadBalancer(arg0 context.Context, arg1 loadbalancer.UpdateLoadBalancerRequest) (loadbalancer.UpdateLoadBalancerResponse, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "UpdateLoadBalancer", arg0, arg1)
        ret0, _ := ret[0].(loadbalancer.UpdateLoadBalancerResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// UpdateLoadBalancer indicates an expected call of UpdateLoadBalancer.
func (mr *MockLoadBalancerClientMockRecorder) UpdateLoadBalancer(arg0, arg1 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateLoadBalancer", reflect.TypeOf((*MockLoadBalancerClient)(nil).UpdateLoadBalancer), arg0, arg1)
}</span>
</pre>
		
		<pre class="file" id="file70" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: client.go

// Package mock_nlb is a generated GoMock package.
package mock_nlb

import (
        context "context"
        reflect "reflect"

        gomock "github.com/golang/mock/gomock"
        networkloadbalancer "github.com/oracle/oci-go-sdk/v65/networkloadbalancer"
)

// MockNetworkLoadBalancerClient is a mock_computemanagement of LoadBalancerClient interface.
type MockNetworkLoadBalancerClient struct {
        ctrl     *gomock.Controller
        recorder *MockNetworkLoadBalancerClientMockRecorder
}

// MockNetworkLoadBalancerClientMockRecorder is the mock_computemanagement recorder for MockNetworkLoadBalancerClient.
type MockNetworkLoadBalancerClientMockRecorder struct {
        mock *MockNetworkLoadBalancerClient
}

// NewMockNetworkLoadBalancerClient creates a new mock_computemanagement instance.
func NewMockNetworkLoadBalancerClient(ctrl *gomock.Controller) *MockNetworkLoadBalancerClient <span class="cov0" title="0">{
        mock := &amp;MockNetworkLoadBalancerClient{ctrl: ctrl}
        mock.recorder = &amp;MockNetworkLoadBalancerClientMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockNetworkLoadBalancerClient) EXPECT() *MockNetworkLoadBalancerClientMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// CreateBackend mocks base method.
func (m *MockNetworkLoadBalancerClient) CreateBackend(ctx context.Context, request networkloadbalancer.CreateBackendRequest) (networkloadbalancer.CreateBackendResponse, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "CreateBackend", ctx, request)
        ret0, _ := ret[0].(networkloadbalancer.CreateBackendResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// CreateBackend indicates an expected call of CreateBackend.
func (mr *MockNetworkLoadBalancerClientMockRecorder) CreateBackend(ctx, request interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateBackend", reflect.TypeOf((*MockNetworkLoadBalancerClient)(nil).CreateBackend), ctx, request)
}</span>

// CreateNetworkLoadBalancer mocks base method.
func (m *MockNetworkLoadBalancerClient) CreateNetworkLoadBalancer(ctx context.Context, request networkloadbalancer.CreateNetworkLoadBalancerRequest) (networkloadbalancer.CreateNetworkLoadBalancerResponse, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "CreateNetworkLoadBalancer", ctx, request)
        ret0, _ := ret[0].(networkloadbalancer.CreateNetworkLoadBalancerResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// CreateNetworkLoadBalancer indicates an expected call of CreateNetworkLoadBalancer.
func (mr *MockNetworkLoadBalancerClientMockRecorder) CreateNetworkLoadBalancer(ctx, request interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateNetworkLoadBalancer", reflect.TypeOf((*MockNetworkLoadBalancerClient)(nil).CreateNetworkLoadBalancer), ctx, request)
}</span>

// DeleteBackend mocks base method.
func (m *MockNetworkLoadBalancerClient) DeleteBackend(ctx context.Context, request networkloadbalancer.DeleteBackendRequest) (networkloadbalancer.DeleteBackendResponse, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "DeleteBackend", ctx, request)
        ret0, _ := ret[0].(networkloadbalancer.DeleteBackendResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// DeleteBackend indicates an expected call of DeleteBackend.
func (mr *MockNetworkLoadBalancerClientMockRecorder) DeleteBackend(ctx, request interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteBackend", reflect.TypeOf((*MockNetworkLoadBalancerClient)(nil).DeleteBackend), ctx, request)
}</span>

// DeleteNetworkLoadBalancer mocks base method.
func (m *MockNetworkLoadBalancerClient) DeleteNetworkLoadBalancer(ctx context.Context, request networkloadbalancer.DeleteNetworkLoadBalancerRequest) (networkloadbalancer.DeleteNetworkLoadBalancerResponse, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "DeleteNetworkLoadBalancer", ctx, request)
        ret0, _ := ret[0].(networkloadbalancer.DeleteNetworkLoadBalancerResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// DeleteNetworkLoadBalancer indicates an expected call of DeleteNetworkLoadBalancer.
func (mr *MockNetworkLoadBalancerClientMockRecorder) DeleteNetworkLoadBalancer(ctx, request interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteNetworkLoadBalancer", reflect.TypeOf((*MockNetworkLoadBalancerClient)(nil).DeleteNetworkLoadBalancer), ctx, request)
}</span>

// GetNetworkLoadBalancer mocks base method.
func (m *MockNetworkLoadBalancerClient) GetNetworkLoadBalancer(ctx context.Context, request networkloadbalancer.GetNetworkLoadBalancerRequest) (networkloadbalancer.GetNetworkLoadBalancerResponse, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetNetworkLoadBalancer", ctx, request)
        ret0, _ := ret[0].(networkloadbalancer.GetNetworkLoadBalancerResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetNetworkLoadBalancer indicates an expected call of GetNetworkLoadBalancer.
func (mr *MockNetworkLoadBalancerClientMockRecorder) GetNetworkLoadBalancer(ctx, request interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetNetworkLoadBalancer", reflect.TypeOf((*MockNetworkLoadBalancerClient)(nil).GetNetworkLoadBalancer), ctx, request)
}</span>

// GetWorkRequest mocks base method.
func (m *MockNetworkLoadBalancerClient) GetWorkRequest(ctx context.Context, request networkloadbalancer.GetWorkRequestRequest) (networkloadbalancer.GetWorkRequestResponse, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetWorkRequest", ctx, request)
        ret0, _ := ret[0].(networkloadbalancer.GetWorkRequestResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetWorkRequest indicates an expected call of GetWorkRequest.
func (mr *MockNetworkLoadBalancerClientMockRecorder) GetWorkRequest(ctx, request interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetWorkRequest", reflect.TypeOf((*MockNetworkLoadBalancerClient)(nil).GetWorkRequest), ctx, request)
}</span>

// ListWorkRequestErrors mocks base method.
func (m *MockNetworkLoadBalancerClient) ListWorkRequestErrors(ctx context.Context, request networkloadbalancer.ListWorkRequestErrorsRequest) (networkloadbalancer.ListWorkRequestErrorsResponse, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "ListWorkRequestErrors", ctx, request)
        ret0, _ := ret[0].(networkloadbalancer.ListWorkRequestErrorsResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// ListWorkRequestErrors indicates an expected call of GetWorkRequest.
func (mr *MockNetworkLoadBalancerClientMockRecorder) ListWorkRequestErrors(ctx, request interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListWorkRequestErrors", reflect.TypeOf((*MockNetworkLoadBalancerClient)(nil).ListWorkRequestErrors), ctx, request)
}</span>

// ListNetworkLoadBalancers mocks base method.
func (m *MockNetworkLoadBalancerClient) ListNetworkLoadBalancers(ctx context.Context, request networkloadbalancer.ListNetworkLoadBalancersRequest) (networkloadbalancer.ListNetworkLoadBalancersResponse, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "ListNetworkLoadBalancers", ctx, request)
        ret0, _ := ret[0].(networkloadbalancer.ListNetworkLoadBalancersResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// ListNetworkLoadBalancers indicates an expected call of ListNetworkLoadBalancers.
func (mr *MockNetworkLoadBalancerClientMockRecorder) ListNetworkLoadBalancers(ctx, request interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListNetworkLoadBalancers", reflect.TypeOf((*MockNetworkLoadBalancerClient)(nil).ListNetworkLoadBalancers), ctx, request)
}</span>

// UpdateNetworkLoadBalancer mocks base method.
func (m *MockNetworkLoadBalancerClient) UpdateNetworkLoadBalancer(ctx context.Context, request networkloadbalancer.UpdateNetworkLoadBalancerRequest) (networkloadbalancer.UpdateNetworkLoadBalancerResponse, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "UpdateNetworkLoadBalancer", ctx, request)
        ret0, _ := ret[0].(networkloadbalancer.UpdateNetworkLoadBalancerResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// UpdateNetworkLoadBalancer indicates an expected call of UpdateNetworkLoadBalancer.
func (mr *MockNetworkLoadBalancerClientMockRecorder) UpdateNetworkLoadBalancer(ctx, request interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateNetworkLoadBalancer", reflect.TypeOf((*MockNetworkLoadBalancerClient)(nil).UpdateNetworkLoadBalancer), ctx, request)
}</span>
</pre>
		
		<pre class="file" id="file71" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: client.go

// Package mock_vcn is a generated GoMock package.
package mock_vcn

import (
        context "context"
        reflect "reflect"

        gomock "github.com/golang/mock/gomock"
        core "github.com/oracle/oci-go-sdk/v65/core"
)

// MockClient is a mock_computemanagement of Client interface.
type MockClient struct {
        ctrl     *gomock.Controller
        recorder *MockClientMockRecorder
}

// MockClientMockRecorder is the mock_computemanagement recorder for MockClient.
type MockClientMockRecorder struct {
        mock *MockClient
}

// NewMockClient creates a new mock_computemanagement instance.
func NewMockClient(ctrl *gomock.Controller) *MockClient <span class="cov0" title="0">{
        mock := &amp;MockClient{ctrl: ctrl}
        mock.recorder = &amp;MockClientMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockClient) EXPECT() *MockClientMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// AddNetworkSecurityGroupSecurityRules mocks base method.
func (m *MockClient) AddNetworkSecurityGroupSecurityRules(ctx context.Context, request core.AddNetworkSecurityGroupSecurityRulesRequest) (core.AddNetworkSecurityGroupSecurityRulesResponse, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "AddNetworkSecurityGroupSecurityRules", ctx, request)
        ret0, _ := ret[0].(core.AddNetworkSecurityGroupSecurityRulesResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// AddNetworkSecurityGroupSecurityRules indicates an expected call of AddNetworkSecurityGroupSecurityRules.
func (mr *MockClientMockRecorder) AddNetworkSecurityGroupSecurityRules(ctx, request interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddNetworkSecurityGroupSecurityRules", reflect.TypeOf((*MockClient)(nil).AddNetworkSecurityGroupSecurityRules), ctx, request)
}</span>

// ConnectRemotePeeringConnections mocks base method.
func (m *MockClient) ConnectRemotePeeringConnections(ctx context.Context, request core.ConnectRemotePeeringConnectionsRequest) (core.ConnectRemotePeeringConnectionsResponse, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "ConnectRemotePeeringConnections", ctx, request)
        ret0, _ := ret[0].(core.ConnectRemotePeeringConnectionsResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// ConnectRemotePeeringConnections indicates an expected call of ConnectRemotePeeringConnections.
func (mr *MockClientMockRecorder) ConnectRemotePeeringConnections(ctx, request interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ConnectRemotePeeringConnections", reflect.TypeOf((*MockClient)(nil).ConnectRemotePeeringConnections), ctx, request)
}</span>

// CreateDrg mocks base method.
func (m *MockClient) CreateDrg(ctx context.Context, request core.CreateDrgRequest) (core.CreateDrgResponse, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "CreateDrg", ctx, request)
        ret0, _ := ret[0].(core.CreateDrgResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// CreateDrg indicates an expected call of CreateDrg.
func (mr *MockClientMockRecorder) CreateDrg(ctx, request interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateDrg", reflect.TypeOf((*MockClient)(nil).CreateDrg), ctx, request)
}</span>

// CreateDrgAttachment mocks base method.
func (m *MockClient) CreateDrgAttachment(ctx context.Context, request core.CreateDrgAttachmentRequest) (core.CreateDrgAttachmentResponse, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "CreateDrgAttachment", ctx, request)
        ret0, _ := ret[0].(core.CreateDrgAttachmentResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// CreateDrgAttachment indicates an expected call of CreateDrgAttachment.
func (mr *MockClientMockRecorder) CreateDrgAttachment(ctx, request interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateDrgAttachment", reflect.TypeOf((*MockClient)(nil).CreateDrgAttachment), ctx, request)
}</span>

// CreateInternetGateway mocks base method.
func (m *MockClient) CreateInternetGateway(ctx context.Context, request core.CreateInternetGatewayRequest) (core.CreateInternetGatewayResponse, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "CreateInternetGateway", ctx, request)
        ret0, _ := ret[0].(core.CreateInternetGatewayResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// CreateInternetGateway indicates an expected call of CreateInternetGateway.
func (mr *MockClientMockRecorder) CreateInternetGateway(ctx, request interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateInternetGateway", reflect.TypeOf((*MockClient)(nil).CreateInternetGateway), ctx, request)
}</span>

// CreateNatGateway mocks base method.
func (m *MockClient) CreateNatGateway(ctx context.Context, request core.CreateNatGatewayRequest) (core.CreateNatGatewayResponse, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "CreateNatGateway", ctx, request)
        ret0, _ := ret[0].(core.CreateNatGatewayResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// CreateNatGateway indicates an expected call of CreateNatGateway.
func (mr *MockClientMockRecorder) CreateNatGateway(ctx, request interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateNatGateway", reflect.TypeOf((*MockClient)(nil).CreateNatGateway), ctx, request)
}</span>

// CreateNetworkSecurityGroup mocks base method.
func (m *MockClient) CreateNetworkSecurityGroup(ctx context.Context, request core.CreateNetworkSecurityGroupRequest) (core.CreateNetworkSecurityGroupResponse, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "CreateNetworkSecurityGroup", ctx, request)
        ret0, _ := ret[0].(core.CreateNetworkSecurityGroupResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// CreateNetworkSecurityGroup indicates an expected call of CreateNetworkSecurityGroup.
func (mr *MockClientMockRecorder) CreateNetworkSecurityGroup(ctx, request interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateNetworkSecurityGroup", reflect.TypeOf((*MockClient)(nil).CreateNetworkSecurityGroup), ctx, request)
}</span>

// CreateRemotePeeringConnection mocks base method.
func (m *MockClient) CreateRemotePeeringConnection(ctx context.Context, request core.CreateRemotePeeringConnectionRequest) (core.CreateRemotePeeringConnectionResponse, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "CreateRemotePeeringConnection", ctx, request)
        ret0, _ := ret[0].(core.CreateRemotePeeringConnectionResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// CreateRemotePeeringConnection indicates an expected call of CreateRemotePeeringConnection.
func (mr *MockClientMockRecorder) CreateRemotePeeringConnection(ctx, request interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateRemotePeeringConnection", reflect.TypeOf((*MockClient)(nil).CreateRemotePeeringConnection), ctx, request)
}</span>

// CreateRouteTable mocks base method.
func (m *MockClient) CreateRouteTable(ctx context.Context, request core.CreateRouteTableRequest) (core.CreateRouteTableResponse, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "CreateRouteTable", ctx, request)
        ret0, _ := ret[0].(core.CreateRouteTableResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// CreateRouteTable indicates an expected call of CreateRouteTable.
func (mr *MockClientMockRecorder) CreateRouteTable(ctx, request interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateRouteTable", reflect.TypeOf((*MockClient)(nil).CreateRouteTable), ctx, request)
}</span>

// CreateSecurityList mocks base method.
func (m *MockClient) CreateSecurityList(ctx context.Context, request core.CreateSecurityListRequest) (core.CreateSecurityListResponse, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "CreateSecurityList", ctx, request)
        ret0, _ := ret[0].(core.CreateSecurityListResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// CreateSecurityList indicates an expected call of CreateSecurityList.
func (mr *MockClientMockRecorder) CreateSecurityList(ctx, request interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateSecurityList", reflect.TypeOf((*MockClient)(nil).CreateSecurityList), ctx, request)
}</span>

// CreateServiceGateway mocks base method.
func (m *MockClient) CreateServiceGateway(ctx context.Context, request core.CreateServiceGatewayRequest) (core.CreateServiceGatewayResponse, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "CreateServiceGateway", ctx, request)
        ret0, _ := ret[0].(core.CreateServiceGatewayResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// CreateServiceGateway indicates an expected call of CreateServiceGateway.
func (mr *MockClientMockRecorder) CreateServiceGateway(ctx, request interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateServiceGateway", reflect.TypeOf((*MockClient)(nil).CreateServiceGateway), ctx, request)
}</span>

// CreateSubnet mocks base method.
func (m *MockClient) CreateSubnet(ctx context.Context, request core.CreateSubnetRequest) (core.CreateSubnetResponse, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "CreateSubnet", ctx, request)
        ret0, _ := ret[0].(core.CreateSubnetResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// CreateSubnet indicates an expected call of CreateSubnet.
func (mr *MockClientMockRecorder) CreateSubnet(ctx, request interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateSubnet", reflect.TypeOf((*MockClient)(nil).CreateSubnet), ctx, request)
}</span>

// CreateVcn mocks base method.
func (m *MockClient) CreateVcn(ctx context.Context, request core.CreateVcnRequest) (core.CreateVcnResponse, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "CreateVcn", ctx, request)
        ret0, _ := ret[0].(core.CreateVcnResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// CreateVcn indicates an expected call of CreateVcn.
func (mr *MockClientMockRecorder) CreateVcn(ctx, request interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateVcn", reflect.TypeOf((*MockClient)(nil).CreateVcn), ctx, request)
}</span>

// DeleteDrg mocks base method.
func (m *MockClient) DeleteDrg(ctx context.Context, request core.DeleteDrgRequest) (core.DeleteDrgResponse, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "DeleteDrg", ctx, request)
        ret0, _ := ret[0].(core.DeleteDrgResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// DeleteDrg indicates an expected call of DeleteDrg.
func (mr *MockClientMockRecorder) DeleteDrg(ctx, request interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteDrg", reflect.TypeOf((*MockClient)(nil).DeleteDrg), ctx, request)
}</span>

// DeleteDrgAttachment mocks base method.
func (m *MockClient) DeleteDrgAttachment(ctx context.Context, request core.DeleteDrgAttachmentRequest) (core.DeleteDrgAttachmentResponse, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "DeleteDrgAttachment", ctx, request)
        ret0, _ := ret[0].(core.DeleteDrgAttachmentResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// DeleteDrgAttachment indicates an expected call of DeleteDrgAttachment.
func (mr *MockClientMockRecorder) DeleteDrgAttachment(ctx, request interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteDrgAttachment", reflect.TypeOf((*MockClient)(nil).DeleteDrgAttachment), ctx, request)
}</span>

// DeleteInternetGateway mocks base method.
func (m *MockClient) DeleteInternetGateway(ctx context.Context, request core.DeleteInternetGatewayRequest) (core.DeleteInternetGatewayResponse, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "DeleteInternetGateway", ctx, request)
        ret0, _ := ret[0].(core.DeleteInternetGatewayResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// DeleteInternetGateway indicates an expected call of DeleteInternetGateway.
func (mr *MockClientMockRecorder) DeleteInternetGateway(ctx, request interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteInternetGateway", reflect.TypeOf((*MockClient)(nil).DeleteInternetGateway), ctx, request)
}</span>

// DeleteNatGateway mocks base method.
func (m *MockClient) DeleteNatGateway(ctx context.Context, request core.DeleteNatGatewayRequest) (core.DeleteNatGatewayResponse, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "DeleteNatGateway", ctx, request)
        ret0, _ := ret[0].(core.DeleteNatGatewayResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// DeleteNatGateway indicates an expected call of DeleteNatGateway.
func (mr *MockClientMockRecorder) DeleteNatGateway(ctx, request interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteNatGateway", reflect.TypeOf((*MockClient)(nil).DeleteNatGateway), ctx, request)
}</span>

// DeleteNetworkSecurityGroup mocks base method.
func (m *MockClient) DeleteNetworkSecurityGroup(ctx context.Context, request core.DeleteNetworkSecurityGroupRequest) (core.DeleteNetworkSecurityGroupResponse, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "DeleteNetworkSecurityGroup", ctx, request)
        ret0, _ := ret[0].(core.DeleteNetworkSecurityGroupResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// DeleteNetworkSecurityGroup indicates an expected call of DeleteNetworkSecurityGroup.
func (mr *MockClientMockRecorder) DeleteNetworkSecurityGroup(ctx, request interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteNetworkSecurityGroup", reflect.TypeOf((*MockClient)(nil).DeleteNetworkSecurityGroup), ctx, request)
}</span>

// DeleteRemotePeeringConnection mocks base method.
func (m *MockClient) DeleteRemotePeeringConnection(ctx context.Context, request core.DeleteRemotePeeringConnectionRequest) (core.DeleteRemotePeeringConnectionResponse, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "DeleteRemotePeeringConnection", ctx, request)
        ret0, _ := ret[0].(core.DeleteRemotePeeringConnectionResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// DeleteRemotePeeringConnection indicates an expected call of DeleteRemotePeeringConnection.
func (mr *MockClientMockRecorder) DeleteRemotePeeringConnection(ctx, request interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteRemotePeeringConnection", reflect.TypeOf((*MockClient)(nil).DeleteRemotePeeringConnection), ctx, request)
}</span>

// DeleteRouteTable mocks base method.
func (m *MockClient) DeleteRouteTable(ctx context.Context, request core.DeleteRouteTableRequest) (core.DeleteRouteTableResponse, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "DeleteRouteTable", ctx, request)
        ret0, _ := ret[0].(core.DeleteRouteTableResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// DeleteRouteTable indicates an expected call of DeleteRouteTable.
func (mr *MockClientMockRecorder) DeleteRouteTable(ctx, request interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteRouteTable", reflect.TypeOf((*MockClient)(nil).DeleteRouteTable), ctx, request)
}</span>

// DeleteSecurityList mocks base method.
func (m *MockClient) DeleteSecurityList(ctx context.Context, request core.DeleteSecurityListRequest) (core.DeleteSecurityListResponse, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "DeleteSecurityList", ctx, request)
        ret0, _ := ret[0].(core.DeleteSecurityListResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// DeleteSecurityList indicates an expected call of DeleteSecurityList.
func (mr *MockClientMockRecorder) DeleteSecurityList(ctx, request interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteSecurityList", reflect.TypeOf((*MockClient)(nil).DeleteSecurityList), ctx, request)
}</span>

// DeleteServiceGateway mocks base method.
func (m *MockClient) DeleteServiceGateway(ctx context.Context, request core.DeleteServiceGatewayRequest) (core.DeleteServiceGatewayResponse, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "DeleteServiceGateway", ctx, request)
        ret0, _ := ret[0].(core.DeleteServiceGatewayResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// DeleteServiceGateway indicates an expected call of DeleteServiceGateway.
func (mr *MockClientMockRecorder) DeleteServiceGateway(ctx, request interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteServiceGateway", reflect.TypeOf((*MockClient)(nil).DeleteServiceGateway), ctx, request)
}</span>

// DeleteSubnet mocks base method.
func (m *MockClient) DeleteSubnet(ctx context.Context, request core.DeleteSubnetRequest) (core.DeleteSubnetResponse, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "DeleteSubnet", ctx, request)
        ret0, _ := ret[0].(core.DeleteSubnetResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// DeleteSubnet indicates an expected call of DeleteSubnet.
func (mr *MockClientMockRecorder) DeleteSubnet(ctx, request interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteSubnet", reflect.TypeOf((*MockClient)(nil).DeleteSubnet), ctx, request)
}</span>

// DeleteVcn mocks base method.
func (m *MockClient) DeleteVcn(ctx context.Context, request core.DeleteVcnRequest) (core.DeleteVcnResponse, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "DeleteVcn", ctx, request)
        ret0, _ := ret[0].(core.DeleteVcnResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// DeleteVcn indicates an expected call of DeleteVcn.
func (mr *MockClientMockRecorder) DeleteVcn(ctx, request interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteVcn", reflect.TypeOf((*MockClient)(nil).DeleteVcn), ctx, request)
}</span>

// GetDrg mocks base method.
func (m *MockClient) GetDrg(ctx context.Context, request core.GetDrgRequest) (core.GetDrgResponse, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetDrg", ctx, request)
        ret0, _ := ret[0].(core.GetDrgResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetDrg indicates an expected call of GetDrg.
func (mr *MockClientMockRecorder) GetDrg(ctx, request interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetDrg", reflect.TypeOf((*MockClient)(nil).GetDrg), ctx, request)
}</span>

// GetDrgAttachment mocks base method.
func (m *MockClient) GetDrgAttachment(ctx context.Context, request core.GetDrgAttachmentRequest) (core.GetDrgAttachmentResponse, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetDrgAttachment", ctx, request)
        ret0, _ := ret[0].(core.GetDrgAttachmentResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetDrgAttachment indicates an expected call of GetDrgAttachment.
func (mr *MockClientMockRecorder) GetDrgAttachment(ctx, request interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetDrgAttachment", reflect.TypeOf((*MockClient)(nil).GetDrgAttachment), ctx, request)
}</span>

// GetInternetGateway mocks base method.
func (m *MockClient) GetInternetGateway(ctx context.Context, request core.GetInternetGatewayRequest) (core.GetInternetGatewayResponse, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetInternetGateway", ctx, request)
        ret0, _ := ret[0].(core.GetInternetGatewayResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetInternetGateway indicates an expected call of GetInternetGateway.
func (mr *MockClientMockRecorder) GetInternetGateway(ctx, request interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetInternetGateway", reflect.TypeOf((*MockClient)(nil).GetInternetGateway), ctx, request)
}</span>

// GetNatGateway mocks base method.
func (m *MockClient) GetNatGateway(ctx context.Context, request core.GetNatGatewayRequest) (core.GetNatGatewayResponse, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetNatGateway", ctx, request)
        ret0, _ := ret[0].(core.GetNatGatewayResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetNatGateway indicates an expected call of GetNatGateway.
func (mr *MockClientMockRecorder) GetNatGateway(ctx, request interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetNatGateway", reflect.TypeOf((*MockClient)(nil).GetNatGateway), ctx, request)
}</span>

// GetNetworkSecurityGroup mocks base method.
func (m *MockClient) GetNetworkSecurityGroup(ctx context.Context, request core.GetNetworkSecurityGroupRequest) (core.GetNetworkSecurityGroupResponse, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetNetworkSecurityGroup", ctx, request)
        ret0, _ := ret[0].(core.GetNetworkSecurityGroupResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetNetworkSecurityGroup indicates an expected call of GetNetworkSecurityGroup.
func (mr *MockClientMockRecorder) GetNetworkSecurityGroup(ctx, request interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetNetworkSecurityGroup", reflect.TypeOf((*MockClient)(nil).GetNetworkSecurityGroup), ctx, request)
}</span>

// GetRemotePeeringConnection mocks base method.
func (m *MockClient) GetRemotePeeringConnection(ctx context.Context, request core.GetRemotePeeringConnectionRequest) (core.GetRemotePeeringConnectionResponse, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetRemotePeeringConnection", ctx, request)
        ret0, _ := ret[0].(core.GetRemotePeeringConnectionResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetRemotePeeringConnection indicates an expected call of GetRemotePeeringConnection.
func (mr *MockClientMockRecorder) GetRemotePeeringConnection(ctx, request interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetRemotePeeringConnection", reflect.TypeOf((*MockClient)(nil).GetRemotePeeringConnection), ctx, request)
}</span>

// GetRouteTable mocks base method.
func (m *MockClient) GetRouteTable(ctx context.Context, request core.GetRouteTableRequest) (core.GetRouteTableResponse, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetRouteTable", ctx, request)
        ret0, _ := ret[0].(core.GetRouteTableResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetRouteTable indicates an expected call of GetRouteTable.
func (mr *MockClientMockRecorder) GetRouteTable(ctx, request interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetRouteTable", reflect.TypeOf((*MockClient)(nil).GetRouteTable), ctx, request)
}</span>

// GetSecurityList mocks base method.
func (m *MockClient) GetSecurityList(ctx context.Context, request core.GetSecurityListRequest) (core.GetSecurityListResponse, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetSecurityList", ctx, request)
        ret0, _ := ret[0].(core.GetSecurityListResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetSecurityList indicates an expected call of GetSecurityList.
func (mr *MockClientMockRecorder) GetSecurityList(ctx, request interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetSecurityList", reflect.TypeOf((*MockClient)(nil).GetSecurityList), ctx, request)
}</span>

// GetServiceGateway mocks base method.
func (m *MockClient) GetServiceGateway(ctx context.Context, request core.GetServiceGatewayRequest) (core.GetServiceGatewayResponse, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetServiceGateway", ctx, request)
        ret0, _ := ret[0].(core.GetServiceGatewayResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetServiceGateway indicates an expected call of GetServiceGateway.
func (mr *MockClientMockRecorder) GetServiceGateway(ctx, request interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetServiceGateway", reflect.TypeOf((*MockClient)(nil).GetServiceGateway), ctx, request)
}</span>

// GetSubnet mocks base method.
func (m *MockClient) GetSubnet(ctx context.Context, request core.GetSubnetRequest) (core.GetSubnetResponse, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetSubnet", ctx, request)
        ret0, _ := ret[0].(core.GetSubnetResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetSubnet indicates an expected call of GetSubnet.
func (mr *MockClientMockRecorder) GetSubnet(ctx, request interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetSubnet", reflect.TypeOf((*MockClient)(nil).GetSubnet), ctx, request)
}</span>

// GetVcn mocks base method.
func (m *MockClient) GetVcn(ctx context.Context, request core.GetVcnRequest) (core.GetVcnResponse, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetVcn", ctx, request)
        ret0, _ := ret[0].(core.GetVcnResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetVcn indicates an expected call of GetVcn.
func (mr *MockClientMockRecorder) GetVcn(ctx, request interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetVcn", reflect.TypeOf((*MockClient)(nil).GetVcn), ctx, request)
}</span>

// GetVnic mocks base method.
func (m *MockClient) GetVnic(ctx context.Context, request core.GetVnicRequest) (core.GetVnicResponse, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetVnic", ctx, request)
        ret0, _ := ret[0].(core.GetVnicResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetVnic indicates an expected call of GetVnic.
func (mr *MockClientMockRecorder) GetVnic(ctx, request interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetVnic", reflect.TypeOf((*MockClient)(nil).GetVnic), ctx, request)
}</span>

// UpdateVnic mocks base method.
func (m *MockClient) UpdateVnic(ctx context.Context, request core.UpdateVnicRequest) (core.UpdateVnicResponse, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "UpdateVnic", ctx, request)
        ret0, _ := ret[0].(core.UpdateVnicResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// UpdateVnic indicates an expected call of UpdateVnic.
func (mr *MockClientMockRecorder) UpdateVnic(ctx, request interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateVnic", reflect.TypeOf((*MockClient)(nil).UpdateVnic), ctx, request)
}</span>

// ListDrgAttachments mocks base method.
func (m *MockClient) ListDrgAttachments(ctx context.Context, request core.ListDrgAttachmentsRequest) (core.ListDrgAttachmentsResponse, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "ListDrgAttachments", ctx, request)
        ret0, _ := ret[0].(core.ListDrgAttachmentsResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// ListDrgAttachments indicates an expected call of ListDrgAttachments.
func (mr *MockClientMockRecorder) ListDrgAttachments(ctx, request interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListDrgAttachments", reflect.TypeOf((*MockClient)(nil).ListDrgAttachments), ctx, request)
}</span>

// ListDrgs mocks base method.
func (m *MockClient) ListDrgs(ctx context.Context, request core.ListDrgsRequest) (core.ListDrgsResponse, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "ListDrgs", ctx, request)
        ret0, _ := ret[0].(core.ListDrgsResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// ListDrgs indicates an expected call of ListDrgs.
func (mr *MockClientMockRecorder) ListDrgs(ctx, request interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListDrgs", reflect.TypeOf((*MockClient)(nil).ListDrgs), ctx, request)
}</span>

// ListInternetGateways mocks base method.
func (m *MockClient) ListInternetGateways(ctx context.Context, request core.ListInternetGatewaysRequest) (core.ListInternetGatewaysResponse, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "ListInternetGateways", ctx, request)
        ret0, _ := ret[0].(core.ListInternetGatewaysResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// ListInternetGateways indicates an expected call of ListInternetGateways.
func (mr *MockClientMockRecorder) ListInternetGateways(ctx, request interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListInternetGateways", reflect.TypeOf((*MockClient)(nil).ListInternetGateways), ctx, request)
}</span>

// ListNatGateways mocks base method.
func (m *MockClient) ListNatGateways(ctx context.Context, request core.ListNatGatewaysRequest) (core.ListNatGatewaysResponse, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "ListNatGateways", ctx, request)
        ret0, _ := ret[0].(core.ListNatGatewaysResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// ListNatGateways indicates an expected call of ListNatGateways.
func (mr *MockClientMockRecorder) ListNatGateways(ctx, request interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListNatGateways", reflect.TypeOf((*MockClient)(nil).ListNatGateways), ctx, request)
}</span>

// ListNetworkSecurityGroupSecurityRules mocks base method.
func (m *MockClient) ListNetworkSecurityGroupSecurityRules(ctx context.Context, request core.ListNetworkSecurityGroupSecurityRulesRequest) (core.ListNetworkSecurityGroupSecurityRulesResponse, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "ListNetworkSecurityGroupSecurityRules", ctx, request)
        ret0, _ := ret[0].(core.ListNetworkSecurityGroupSecurityRulesResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// ListNetworkSecurityGroupSecurityRules indicates an expected call of ListNetworkSecurityGroupSecurityRules.
func (mr *MockClientMockRecorder) ListNetworkSecurityGroupSecurityRules(ctx, request interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListNetworkSecurityGroupSecurityRules", reflect.TypeOf((*MockClient)(nil).ListNetworkSecurityGroupSecurityRules), ctx, request)
}</span>

// ListNetworkSecurityGroups mocks base method.
func (m *MockClient) ListNetworkSecurityGroups(ctx context.Context, request core.ListNetworkSecurityGroupsRequest) (core.ListNetworkSecurityGroupsResponse, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "ListNetworkSecurityGroups", ctx, request)
        ret0, _ := ret[0].(core.ListNetworkSecurityGroupsResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// ListNetworkSecurityGroups indicates an expected call of ListNetworkSecurityGroups.
func (mr *MockClientMockRecorder) ListNetworkSecurityGroups(ctx, request interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListNetworkSecurityGroups", reflect.TypeOf((*MockClient)(nil).ListNetworkSecurityGroups), ctx, request)
}</span>

// ListRemotePeeringConnections mocks base method.
func (m *MockClient) ListRemotePeeringConnections(ctx context.Context, request core.ListRemotePeeringConnectionsRequest) (core.ListRemotePeeringConnectionsResponse, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "ListRemotePeeringConnections", ctx, request)
        ret0, _ := ret[0].(core.ListRemotePeeringConnectionsResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// ListRemotePeeringConnections indicates an expected call of ListRemotePeeringConnections.
func (mr *MockClientMockRecorder) ListRemotePeeringConnections(ctx, request interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListRemotePeeringConnections", reflect.TypeOf((*MockClient)(nil).ListRemotePeeringConnections), ctx, request)
}</span>

// ListRouteTables mocks base method.
func (m *MockClient) ListRouteTables(ctx context.Context, request core.ListRouteTablesRequest) (core.ListRouteTablesResponse, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "ListRouteTables", ctx, request)
        ret0, _ := ret[0].(core.ListRouteTablesResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// ListRouteTables indicates an expected call of ListRouteTables.
func (mr *MockClientMockRecorder) ListRouteTables(ctx, request interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListRouteTables", reflect.TypeOf((*MockClient)(nil).ListRouteTables), ctx, request)
}</span>

// ListSecurityLists mocks base method.
func (m *MockClient) ListSecurityLists(ctx context.Context, request core.ListSecurityListsRequest) (core.ListSecurityListsResponse, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "ListSecurityLists", ctx, request)
        ret0, _ := ret[0].(core.ListSecurityListsResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// ListSecurityLists indicates an expected call of ListSecurityLists.
func (mr *MockClientMockRecorder) ListSecurityLists(ctx, request interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListSecurityLists", reflect.TypeOf((*MockClient)(nil).ListSecurityLists), ctx, request)
}</span>

// ListServiceGateways mocks base method.
func (m *MockClient) ListServiceGateways(ctx context.Context, request core.ListServiceGatewaysRequest) (core.ListServiceGatewaysResponse, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "ListServiceGateways", ctx, request)
        ret0, _ := ret[0].(core.ListServiceGatewaysResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// ListServiceGateways indicates an expected call of ListServiceGateways.
func (mr *MockClientMockRecorder) ListServiceGateways(ctx, request interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListServiceGateways", reflect.TypeOf((*MockClient)(nil).ListServiceGateways), ctx, request)
}</span>

// ListServices mocks base method.
func (m *MockClient) ListServices(ctx context.Context, request core.ListServicesRequest) (core.ListServicesResponse, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "ListServices", ctx, request)
        ret0, _ := ret[0].(core.ListServicesResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// ListServices indicates an expected call of ListServices.
func (mr *MockClientMockRecorder) ListServices(ctx, request interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListServices", reflect.TypeOf((*MockClient)(nil).ListServices), ctx, request)
}</span>

// ListSubnets mocks base method.
func (m *MockClient) ListSubnets(ctx context.Context, request core.ListSubnetsRequest) (core.ListSubnetsResponse, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "ListSubnets", ctx, request)
        ret0, _ := ret[0].(core.ListSubnetsResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// ListSubnets indicates an expected call of ListSubnets.
func (mr *MockClientMockRecorder) ListSubnets(ctx, request interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListSubnets", reflect.TypeOf((*MockClient)(nil).ListSubnets), ctx, request)
}</span>

// ListVcns mocks base method.
func (m *MockClient) ListVcns(ctx context.Context, request core.ListVcnsRequest) (core.ListVcnsResponse, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "ListVcns", ctx, request)
        ret0, _ := ret[0].(core.ListVcnsResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// ListVcns indicates an expected call of ListVcns.
func (mr *MockClientMockRecorder) ListVcns(ctx, request interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListVcns", reflect.TypeOf((*MockClient)(nil).ListVcns), ctx, request)
}</span>

// RemoveNetworkSecurityGroupSecurityRules mocks base method.
func (m *MockClient) RemoveNetworkSecurityGroupSecurityRules(ctx context.Context, request core.RemoveNetworkSecurityGroupSecurityRulesRequest) (core.RemoveNetworkSecurityGroupSecurityRulesResponse, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "RemoveNetworkSecurityGroupSecurityRules", ctx, request)
        ret0, _ := ret[0].(core.RemoveNetworkSecurityGroupSecurityRulesResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// RemoveNetworkSecurityGroupSecurityRules indicates an expected call of RemoveNetworkSecurityGroupSecurityRules.
func (mr *MockClientMockRecorder) RemoveNetworkSecurityGroupSecurityRules(ctx, request interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RemoveNetworkSecurityGroupSecurityRules", reflect.TypeOf((*MockClient)(nil).RemoveNetworkSecurityGroupSecurityRules), ctx, request)
}</span>

// UpdateDrg mocks base method.
func (m *MockClient) UpdateDrg(ctx context.Context, request core.UpdateDrgRequest) (core.UpdateDrgResponse, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "UpdateDrg", ctx, request)
        ret0, _ := ret[0].(core.UpdateDrgResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// UpdateDrg indicates an expected call of UpdateDrg.
func (mr *MockClientMockRecorder) UpdateDrg(ctx, request interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateDrg", reflect.TypeOf((*MockClient)(nil).UpdateDrg), ctx, request)
}</span>

// UpdateDrgAttachment mocks base method.
func (m *MockClient) UpdateDrgAttachment(ctx context.Context, request core.UpdateDrgAttachmentRequest) (core.UpdateDrgAttachmentResponse, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "UpdateDrgAttachment", ctx, request)
        ret0, _ := ret[0].(core.UpdateDrgAttachmentResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// UpdateDrgAttachment indicates an expected call of UpdateDrgAttachment.
func (mr *MockClientMockRecorder) UpdateDrgAttachment(ctx, request interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateDrgAttachment", reflect.TypeOf((*MockClient)(nil).UpdateDrgAttachment), ctx, request)
}</span>

// UpdateInternetGateway mocks base method.
func (m *MockClient) UpdateInternetGateway(ctx context.Context, request core.UpdateInternetGatewayRequest) (core.UpdateInternetGatewayResponse, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "UpdateInternetGateway", ctx, request)
        ret0, _ := ret[0].(core.UpdateInternetGatewayResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// UpdateInternetGateway indicates an expected call of UpdateInternetGateway.
func (mr *MockClientMockRecorder) UpdateInternetGateway(ctx, request interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateInternetGateway", reflect.TypeOf((*MockClient)(nil).UpdateInternetGateway), ctx, request)
}</span>

// UpdateNatGateway mocks base method.
func (m *MockClient) UpdateNatGateway(ctx context.Context, request core.UpdateNatGatewayRequest) (core.UpdateNatGatewayResponse, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "UpdateNatGateway", ctx, request)
        ret0, _ := ret[0].(core.UpdateNatGatewayResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// UpdateNatGateway indicates an expected call of UpdateNatGateway.
func (mr *MockClientMockRecorder) UpdateNatGateway(ctx, request interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateNatGateway", reflect.TypeOf((*MockClient)(nil).UpdateNatGateway), ctx, request)
}</span>

// UpdateNetworkSecurityGroup mocks base method.
func (m *MockClient) UpdateNetworkSecurityGroup(ctx context.Context, request core.UpdateNetworkSecurityGroupRequest) (core.UpdateNetworkSecurityGroupResponse, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "UpdateNetworkSecurityGroup", ctx, request)
        ret0, _ := ret[0].(core.UpdateNetworkSecurityGroupResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// UpdateNetworkSecurityGroup indicates an expected call of UpdateNetworkSecurityGroup.
func (mr *MockClientMockRecorder) UpdateNetworkSecurityGroup(ctx, request interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateNetworkSecurityGroup", reflect.TypeOf((*MockClient)(nil).UpdateNetworkSecurityGroup), ctx, request)
}</span>

// UpdateNetworkSecurityGroupSecurityRules mocks base method.
func (m *MockClient) UpdateNetworkSecurityGroupSecurityRules(ctx context.Context, request core.UpdateNetworkSecurityGroupSecurityRulesRequest) (core.UpdateNetworkSecurityGroupSecurityRulesResponse, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "UpdateNetworkSecurityGroupSecurityRules", ctx, request)
        ret0, _ := ret[0].(core.UpdateNetworkSecurityGroupSecurityRulesResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// UpdateNetworkSecurityGroupSecurityRules indicates an expected call of UpdateNetworkSecurityGroupSecurityRules.
func (mr *MockClientMockRecorder) UpdateNetworkSecurityGroupSecurityRules(ctx, request interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateNetworkSecurityGroupSecurityRules", reflect.TypeOf((*MockClient)(nil).UpdateNetworkSecurityGroupSecurityRules), ctx, request)
}</span>

// UpdateRemotePeeringConnection mocks base method.
func (m *MockClient) UpdateRemotePeeringConnection(ctx context.Context, request core.UpdateRemotePeeringConnectionRequest) (core.UpdateRemotePeeringConnectionResponse, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "UpdateRemotePeeringConnection", ctx, request)
        ret0, _ := ret[0].(core.UpdateRemotePeeringConnectionResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// UpdateRemotePeeringConnection indicates an expected call of UpdateRemotePeeringConnection.
func (mr *MockClientMockRecorder) UpdateRemotePeeringConnection(ctx, request interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateRemotePeeringConnection", reflect.TypeOf((*MockClient)(nil).UpdateRemotePeeringConnection), ctx, request)
}</span>

// UpdateRouteTable mocks base method.
func (m *MockClient) UpdateRouteTable(ctx context.Context, request core.UpdateRouteTableRequest) (core.UpdateRouteTableResponse, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "UpdateRouteTable", ctx, request)
        ret0, _ := ret[0].(core.UpdateRouteTableResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// UpdateRouteTable indicates an expected call of UpdateRouteTable.
func (mr *MockClientMockRecorder) UpdateRouteTable(ctx, request interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateRouteTable", reflect.TypeOf((*MockClient)(nil).UpdateRouteTable), ctx, request)
}</span>

// UpdateSecurityList mocks base method.
func (m *MockClient) UpdateSecurityList(ctx context.Context, request core.UpdateSecurityListRequest) (core.UpdateSecurityListResponse, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "UpdateSecurityList", ctx, request)
        ret0, _ := ret[0].(core.UpdateSecurityListResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// UpdateSecurityList indicates an expected call of UpdateSecurityList.
func (mr *MockClientMockRecorder) UpdateSecurityList(ctx, request interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateSecurityList", reflect.TypeOf((*MockClient)(nil).UpdateSecurityList), ctx, request)
}</span>

// UpdateServiceGateway mocks base method.
func (m *MockClient) UpdateServiceGateway(ctx context.Context, request core.UpdateServiceGatewayRequest) (core.UpdateServiceGatewayResponse, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "UpdateServiceGateway", ctx, request)
        ret0, _ := ret[0].(core.UpdateServiceGatewayResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// UpdateServiceGateway indicates an expected call of UpdateServiceGateway.
func (mr *MockClientMockRecorder) UpdateServiceGateway(ctx, request interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateServiceGateway", reflect.TypeOf((*MockClient)(nil).UpdateServiceGateway), ctx, request)
}</span>

// UpdateSubnet mocks base method.
func (m *MockClient) UpdateSubnet(ctx context.Context, request core.UpdateSubnetRequest) (core.UpdateSubnetResponse, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "UpdateSubnet", ctx, request)
        ret0, _ := ret[0].(core.UpdateSubnetResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// UpdateSubnet indicates an expected call of UpdateSubnet.
func (mr *MockClientMockRecorder) UpdateSubnet(ctx, request interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateSubnet", reflect.TypeOf((*MockClient)(nil).UpdateSubnet), ctx, request)
}</span>

// UpdateVcn mocks base method.
func (m *MockClient) UpdateVcn(ctx context.Context, request core.UpdateVcnRequest) (core.UpdateVcnResponse, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "UpdateVcn", ctx, request)
        ret0, _ := ret[0].(core.UpdateVcnResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// UpdateVcn indicates an expected call of UpdateVcn.
func (mr *MockClientMockRecorder) UpdateVcn(ctx, request interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateVcn", reflect.TypeOf((*MockClient)(nil).UpdateVcn), ctx, request)
}</span>
</pre>
		
		<pre class="file" id="file72" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: client.go

// Package mock_containerengine is a generated GoMock package.
package mock_workrequests

import (
        context "context"
        reflect "reflect"

        gomock "github.com/golang/mock/gomock"
        wr "github.com/oracle/oci-go-sdk/v65/workrequests"
)

// MockClient is a mock of Client interface.
type MockClient struct {
        ctrl     *gomock.Controller
        recorder *MockClientMockRecorder
}

// MockClientMockRecorder is the mock recorder for MockClient.
type MockClientMockRecorder struct {
        mock *MockClient
}

// NewMockClient creates a new mock instance.
func NewMockClient(ctrl *gomock.Controller) *MockClient <span class="cov0" title="0">{
        mock := &amp;MockClient{ctrl: ctrl}
        mock.recorder = &amp;MockClientMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockClient) EXPECT() *MockClientMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// ListWorkRequests mocks base method.
func (m *MockClient) ListWorkRequests(ctx context.Context, request wr.ListWorkRequestsRequest) (wr.ListWorkRequestsResponse, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "ListWorkRequests", ctx, request)
        ret0, _ := ret[0].(wr.ListWorkRequestsResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// ListWorkRequests indicates an expected call of ListWorkRequests.
func (mr *MockClientMockRecorder) ListWorkRequests(ctx, request interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListWorkRequests", reflect.TypeOf((*MockClient)(nil).ListWorkRequests), ctx, request)
}</span>

// ListWorkRequestErrors mocks base method.
func (m *MockClient) ListWorkRequestErrors(ctx context.Context, request wr.ListWorkRequestErrorsRequest) (wr.ListWorkRequestErrorsResponse, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "ListWorkRequestErrors", ctx, request)
        ret0, _ := ret[0].(wr.ListWorkRequestErrorsResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// ListWorkRequestErrors indicates an expected call of ListWorkRequestErrors.
func (mr *MockClientMockRecorder) ListWorkRequestErrors(ctx, request interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListWorkRequestErrors", reflect.TypeOf((*MockClient)(nil).ListWorkRequestErrors), ctx, request)
}</span>
</pre>
		
		<pre class="file" id="file73" style="display: none">/*
Copyright (c) 2021, 2022 Oracle and/or its affiliates.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package util

import (
        "encoding/json"

        "github.com/pkg/errors"
        clusterv1 "sigs.k8s.io/cluster-api/api/core/v1beta1"
        clusterv1beta2 "sigs.k8s.io/cluster-api/api/core/v1beta2"
)

// ConvertClusterV1Beta2ToV1Beta1 converts a v1beta2 Cluster to v1beta1
func ConvertClusterV1Beta2ToV1Beta1(cluster *clusterv1beta2.Cluster) (*clusterv1.Cluster, error) <span class="cov0" title="0">{
        if cluster == nil </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        <span class="cov0" title="0">clusterV1Beta1 := &amp;clusterv1.Cluster{}
        data, err := json.Marshal(cluster)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "failed to marshal v1beta2 cluster")
        }</span>

        <span class="cov0" title="0">if err := json.Unmarshal(data, clusterV1Beta1); err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "failed to unmarshal to v1beta1 cluster")
        }</span>

        <span class="cov0" title="0">return clusterV1Beta1, nil</span>
}

// ConvertMachineV1Beta2ToV1Beta1 converts a v1beta2 Machine to v1beta1
func ConvertMachineV1Beta2ToV1Beta1(machine *clusterv1beta2.Machine) (*clusterv1.Machine, error) <span class="cov0" title="0">{
        if machine == nil </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        <span class="cov0" title="0">machineV1Beta1 := &amp;clusterv1.Machine{}
        data, err := json.Marshal(machine)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "failed to marshal v1beta2 machine")
        }</span>

        <span class="cov0" title="0">if err := json.Unmarshal(data, machineV1Beta1); err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "failed to unmarshal to v1beta1 machine")
        }</span>

        <span class="cov0" title="0">return machineV1Beta1, nil</span>
}

// ConvertMachinePoolV1Beta2ToV1Beta1 converts a v1beta2 MachinePool to v1beta1
func ConvertMachinePoolV1Beta2ToV1Beta1(machinePool *clusterv1beta2.MachinePool) (*clusterv1.MachinePool, error) <span class="cov0" title="0">{
        if machinePool == nil </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        <span class="cov0" title="0">machinePoolV1Beta1 := &amp;clusterv1.MachinePool{}
        data, err := json.Marshal(machinePool)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "failed to marshal v1beta2 machinepool")
        }</span>

        <span class="cov0" title="0">if err := json.Unmarshal(data, machinePoolV1Beta1); err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "failed to unmarshal to v1beta1 machinepool")
        }</span>

        <span class="cov0" title="0">return machinePoolV1Beta1, nil</span>
}
</pre>
		
		<pre class="file" id="file74" style="display: none">/*
 Copyright (c) 2021, 2022 Oracle and/or its affiliates.

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

      https://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
*/

package util

import (
        "context"
        "crypto/x509"
        "fmt"
        "io"
        "net/http"
        "os"
        "reflect"
        "time"

        "github.com/go-logr/logr"
        "github.com/oracle/cluster-api-provider-oci/api/v1beta2"
        infrastructurev1beta2 "github.com/oracle/cluster-api-provider-oci/api/v1beta2"
        "github.com/oracle/cluster-api-provider-oci/cloud/config"
        "github.com/oracle/cluster-api-provider-oci/cloud/scope"
        infrav2exp "github.com/oracle/cluster-api-provider-oci/exp/api/v1beta2"
        "github.com/oracle/oci-go-sdk/v65/common"
        "github.com/oracle/oci-go-sdk/v65/common/auth"
        "github.com/pkg/errors"
        corev1 "k8s.io/api/core/v1"
        apierrors "k8s.io/apimachinery/pkg/api/errors"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/types"
        clusterv1 "sigs.k8s.io/cluster-api/api/core/v1beta1"
        expclusterv1 "sigs.k8s.io/cluster-api/api/core/v1beta1"
        "sigs.k8s.io/cluster-api/util"
        "sigs.k8s.io/cluster-api/util/labels/format"
        "sigs.k8s.io/cluster-api/util/patch"
        "sigs.k8s.io/controller-runtime/pkg/client"
        "sigs.k8s.io/controller-runtime/pkg/controller/controllerutil"
        "sigs.k8s.io/controller-runtime/pkg/log"
)

const (
        instanceMetadataRegionInfoURLV2 = "http://169.254.169.254/opc/v2/instance/regionInfo/regionIdentifier"
)

var (
        currentRegion *string
)

// GetClusterIdentityFromRef returns the OCIClusterIdentity referenced by the OCICluster.
// nolint:nilnil
func GetClusterIdentityFromRef(ctx context.Context, c client.Client, ociClusterNamespace string, ref *corev1.ObjectReference) (*infrastructurev1beta2.OCIClusterIdentity, error) <span class="cov8" title="1">{
        identity := &amp;infrastructurev1beta2.OCIClusterIdentity{}
        if ref != nil </span><span class="cov8" title="1">{
                namespace := ref.Namespace
                if namespace == "" </span><span class="cov0" title="0">{
                        namespace = ociClusterNamespace
                }</span>
                <span class="cov8" title="1">key := client.ObjectKey{Name: ref.Name, Namespace: namespace}
                if err := c.Get(ctx, key, identity); err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">return identity, nil</span>
        }
        <span class="cov0" title="0">return nil, nil</span>
}

// getOCIClientCertFromSecret returns the cert referenced by the OCICluster.
func getOCIClientCertFromSecret(ctx context.Context, c client.Client, ociClusterNamespace string, overrides *infrastructurev1beta2.ClientOverrides) (*corev1.Secret, error) <span class="cov8" title="1">{
        secret := &amp;corev1.Secret{}
        if overrides != nil &amp;&amp; overrides.CertOverride != nil </span><span class="cov8" title="1">{
                certSecretRef := overrides.CertOverride
                namespace := certSecretRef.Namespace
                if namespace == "" </span><span class="cov0" title="0">{
                        namespace = ociClusterNamespace
                }</span>
                <span class="cov8" title="1">key := types.NamespacedName{Namespace: namespace, Name: certSecretRef.Name}
                if err := c.Get(ctx, key, secret); err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">return secret, nil</span>
        }
        <span class="cov8" title="1">return nil, errors.New("OCI Client Cert not found")</span>
}

func getOCIClientCertPool(ctx context.Context, c client.Client, namespace string, clientOverrides *infrastructurev1beta2.ClientOverrides) (*x509.CertPool, error) <span class="cov8" title="1">{
        var pool *x509.CertPool = nil
        if clientOverrides != nil &amp;&amp; clientOverrides.CertOverride != nil </span><span class="cov8" title="1">{
                cert, err := getOCIClientCertFromSecret(ctx, c, namespace, clientOverrides)
                if err != nil </span><span class="cov8" title="1">{
                        return nil, errors.Wrap(err, "Unable to fetch CertOverrideSecret")
                }</span>
                <span class="cov8" title="1">pool = x509.NewCertPool()
                if cert == nil </span><span class="cov0" title="0">{
                        return nil, errors.New("Cert Secret is nil")
                }</span>
                <span class="cov8" title="1">if cert, ok := cert.Data["cert"]; ok </span><span class="cov8" title="1">{
                        pool.AppendCertsFromPEM(cert)
                }</span> else<span class="cov8" title="1"> {
                        return nil, errors.New("Cert Secret didn't contain 'cert' data")
                }</span>
        }
        <span class="cov8" title="1">return pool, nil</span>
}

// GetOrBuildClientFromIdentity creates ClientProvider from OCIClusterIdentity object
// nolint:nilaway
func GetOrBuildClientFromIdentity(ctx context.Context, c client.Client, identity *infrastructurev1beta2.OCIClusterIdentity, defaultRegion string, clientOverrides *infrastructurev1beta2.ClientOverrides, namespace string) (*scope.ClientProvider, error) <span class="cov8" title="1">{
        logger := log.FromContext(ctx)
        if !reflect.DeepEqual(identity.Spec, v1beta2.OCIClusterIdentitySpec{}) &amp;&amp; identity.Spec.Type == infrastructurev1beta2.UserPrincipal </span><span class="cov8" title="1">{
                secretRef := identity.Spec.PrincipalSecret
                key := types.NamespacedName{
                        Namespace: secretRef.Namespace,
                        Name:      secretRef.Name,
                }
                secret := &amp;corev1.Secret{}

                if err := c.Get(ctx, key, secret); err != nil </span><span class="cov8" title="1">{
                        return nil, errors.Wrap(err, "Unable to fetch ClientSecret")
                }</span>

                <span class="cov8" title="1">tenancyId := string(secret.Data[config.Tenancy])
                userId := string(secret.Data[config.User])
                fingerPrint := string(secret.Data[config.Fingerprint])
                passphrase := string(secret.Data[config.Passphrase])
                privatekey := string(secret.Data[config.Key])
                region := string(secret.Data[config.Region])
                // set the default region if not provided in the secret
                if region == "" </span><span class="cov0" title="0">{
                        region = defaultRegion
                }</span>
                <span class="cov8" title="1">conf := common.NewRawConfigurationProvider(
                        tenancyId,
                        userId,
                        region,
                        fingerPrint,
                        privatekey,
                        common.String(passphrase))

                pool, err := getOCIClientCertPool(ctx, c, namespace, clientOverrides)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">clientProvider, err := scope.NewClientProvider(scope.ClientProviderParams{
                        CertOverride:          pool,
                        OciAuthConfigProvider: conf,
                        ClientOverrides:       clientOverrides})

                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">return clientProvider, nil</span>
        } else<span class="cov8" title="1"> if identity.Spec.Type == infrastructurev1beta2.InstancePrincipal </span><span class="cov0" title="0">{
                provider, err := auth.InstancePrincipalConfigurationProvider()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">pool, err := getOCIClientCertPool(ctx, c, namespace, clientOverrides)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">clientProvider, err := scope.NewClientProvider(scope.ClientProviderParams{
                        CertOverride:          pool,
                        OciAuthConfigProvider: provider,
                        ClientOverrides:       clientOverrides})

                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return clientProvider, nil</span>
        } else<span class="cov8" title="1"> if identity.Spec.Type == infrastructurev1beta2.WorkloadPrincipal </span><span class="cov0" title="0">{
                _, containsVersion := os.LookupEnv(auth.ResourcePrincipalVersionEnvVar)
                if !containsVersion </span><span class="cov0" title="0">{
                        os.Setenv(auth.ResourcePrincipalVersionEnvVar, auth.ResourcePrincipalVersion2_2)
                }</span>
                <span class="cov0" title="0">_, containsRegion := os.LookupEnv(auth.ResourcePrincipalRegionEnvVar)
                if !containsRegion </span><span class="cov0" title="0">{
                        // initialize the current region from region metadata
                        if currentRegion == nil </span><span class="cov0" title="0">{
                                regionByte, err := getRegionInfoFromInstanceMetadataServiceProd()
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, err
                                }</span>
                                <span class="cov0" title="0">currentRegion = common.String(string(regionByte))</span>
                        }
                        <span class="cov0" title="0">logger.Info(fmt.Sprintf("Looked up region %s from instance metadata", *currentRegion))
                        os.Setenv(auth.ResourcePrincipalRegionEnvVar, *currentRegion)</span>
                }

                <span class="cov0" title="0">provider, err := auth.OkeWorkloadIdentityConfigurationProvider()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">pool, err := getOCIClientCertPool(ctx, c, namespace, clientOverrides)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">clientProvider, err := scope.NewClientProvider(scope.ClientProviderParams{
                        CertOverride:          pool,
                        OciAuthConfigProvider: provider,
                        ClientOverrides:       clientOverrides})

                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return clientProvider, nil</span>
        }
        <span class="cov8" title="1">return nil, errors.New(fmt.Sprintf("invalid oci principal format type: %s", identity.Spec.Type))</span>
}

// IsClusterNamespaceAllowed indicates if the cluster namespace is allowed.
func IsClusterNamespaceAllowed(ctx context.Context, k8sClient client.Client, allowedNamespaces *infrastructurev1beta2.AllowedNamespaces, namespace string) bool <span class="cov8" title="1">{
        if allowedNamespaces == nil </span><span class="cov8" title="1">{
                return false
        }</span>

        // empty value matches with all namespaces
        <span class="cov8" title="1">if reflect.DeepEqual(*allowedNamespaces, infrastructurev1beta2.AllowedNamespaces{}) </span><span class="cov8" title="1">{
                return true
        }</span>

        <span class="cov8" title="1">for _, v := range allowedNamespaces.NamespaceList </span><span class="cov8" title="1">{
                if v == namespace </span><span class="cov8" title="1">{
                        return true
                }</span>
        }

        // Check if clusterNamespace is in the namespaces selected by the identity's allowedNamespaces selector.
        <span class="cov8" title="1">namespaces := &amp;corev1.NamespaceList{}
        selector, err := metav1.LabelSelectorAsSelector(allowedNamespaces.Selector)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>

        // If a Selector has a nil or empty selector, it should match nothing.
        <span class="cov8" title="1">if selector.Empty() </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">if err := k8sClient.List(ctx, namespaces, client.MatchingLabelsSelector{Selector: selector}); err != nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">for _, n := range namespaces.Items </span><span class="cov8" title="1">{
                if n.Name == namespace </span><span class="cov8" title="1">{
                        return true
                }</span>
        }

        <span class="cov8" title="1">return false</span>
}

// InitClientsAndRegion initializes the OCI Clients and Region based on various parameters
func InitClientsAndRegion(ctx context.Context, client client.Client, defaultRegion string, clusterAccessor scope.OCIClusterAccessor, defaultClientProvider *scope.ClientProvider) (*scope.ClientProvider, string, scope.OCIClients, error) <span class="cov8" title="1">{
        var clientProvider *scope.ClientProvider
        var err error
        // Region is calculated as follows
        // 1) If region is set in the cluster spec, that takes highest priority
        // 2) If region is set in the cluster identity, that takes the next priority
        // 3) Last priority is for region set at the Pod initialization time OCI identity
        clusterRegion := defaultRegion

        identityRef := clusterAccessor.GetIdentityRef()
        // If Cluster identity is set, OCI Clients should be created using the identity
        if identityRef != nil </span><span class="cov0" title="0">{
                clientProvider, err = CreateClientProviderFromClusterIdentity(ctx, client, clusterAccessor.GetNameSpace(), defaultRegion, clusterAccessor, identityRef)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, "", scope.OCIClients{}, err
                }</span>
                <span class="cov0" title="0">region, err := clientProvider.GetRegion()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, "", scope.OCIClients{}, err
                }</span>
                <span class="cov0" title="0">clusterRegion = region</span>
        } else<span class="cov8" title="1"> if clusterAccessor.GetClientOverrides() != nil </span><span class="cov8" title="1">{
                pool, err := getOCIClientCertPool(ctx, client, clusterAccessor.GetNameSpace(), clusterAccessor.GetClientOverrides())
                if err != nil </span><span class="cov8" title="1">{
                        return nil, "", scope.OCIClients{}, err
                }</span>
                // IdentityRef provider will be created with client host url overrides
                // but if no identityRef we will want to create a new client provider with the overrides
                <span class="cov8" title="1">clientProvider, err = scope.NewClientProvider(scope.ClientProviderParams{
                        CertOverride:          pool,
                        OciAuthConfigProvider: defaultClientProvider.GetAuthProvider(),
                        ClientOverrides:       clusterAccessor.GetClientOverrides()})
                if err != nil </span><span class="cov0" title="0">{
                        return nil, "", scope.OCIClients{}, err
                }</span>
        } else<span class="cov0" title="0"> {
                clientProvider = defaultClientProvider
        }</span>

        <span class="cov8" title="1">if clientProvider == nil </span><span class="cov0" title="0">{
                return nil, "", scope.OCIClients{}, errors.New("OCI authentication credentials could not be retrieved from pod or cluster level," +
                        "please install Cluster API Provider for OCI with OCI authentication credentials or set Cluster Identity in the OCICluster")
        }</span>

        // Region set at cluster takes highest precedence
        <span class="cov8" title="1">if len(clusterAccessor.GetRegion()) &gt; 0 </span><span class="cov0" title="0">{
                clusterRegion = clusterAccessor.GetRegion()
        }</span>
        <span class="cov8" title="1">if len(clusterRegion) &lt;= 0 </span><span class="cov0" title="0">{
                return nil, "", scope.OCIClients{}, errors.New("OCI Region could not be identified for the cluster")
        }</span>
        <span class="cov8" title="1">clients, err := clientProvider.GetOrBuildClient(clusterRegion)
        if err != nil </span><span class="cov0" title="0">{
                return nil, "", scope.OCIClients{}, err
        }</span>
        <span class="cov8" title="1">return clientProvider, clusterRegion, clients, nil</span>
}

// CreateClientProviderFromClusterIdentity creates scope.ClientProvider from Cluster Identity
// nolint:nilaway
func CreateClientProviderFromClusterIdentity(ctx context.Context, client client.Client, namespace string, defaultRegion string, clusterAccessor scope.OCIClusterAccessor, identityRef *corev1.ObjectReference) (*scope.ClientProvider, error) <span class="cov8" title="1">{
        identity, err := GetClusterIdentityFromRef(ctx, client, namespace, identityRef)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if !IsClusterNamespaceAllowed(ctx, client, identity.Spec.AllowedNamespaces, namespace) </span><span class="cov8" title="1">{
                clusterAccessor.MarkConditionFalse(infrastructurev1beta2.ClusterReadyCondition, infrastructurev1beta2.NamespaceNotAllowedByIdentity, clusterv1.ConditionSeverityError, "")
                return nil, errors.Errorf("OCIClusterIdentity list of allowed namespaces doesn't include current cluster namespace %s", namespace)
        }</span>
        <span class="cov0" title="0">clientProvider, err := GetOrBuildClientFromIdentity(ctx, client, identity, defaultRegion, clusterAccessor.GetClientOverrides(), namespace)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return clientProvider, nil</span>
}

// CreateMachinePoolMachinesIfNotExists creates the machine pool machines if not exists. This method lists the existing
// machines in the clusters and does a diff, and creates any missing machines based ont he spec provided.
func CreateMachinePoolMachinesIfNotExists(ctx context.Context, params MachineParams) error <span class="cov8" title="1">{

        machineList, err := getMachinepoolMachines(ctx, params.Client, params.MachinePool, params.Cluster, params.Namespace)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">instanceNameToMachinePoolMachine := make(map[string]infrav2exp.OCIMachinePoolMachine)
        for _, machine := range machineList.Items </span><span class="cov8" title="1">{
                instanceNameToMachinePoolMachine[*machine.Spec.OCID] = machine
        }</span>

        <span class="cov8" title="1">for _, specMachine := range params.SpecInfraMachines </span><span class="cov8" title="1">{
                if actualMachine, exists := instanceNameToMachinePoolMachine[*specMachine.Spec.OCID]; exists </span><span class="cov8" title="1">{
                        if !reflect.DeepEqual(specMachine.Status.Ready, actualMachine.Status.Ready) </span><span class="cov8" title="1">{
                                params.Logger.Info("Setting status of machine to active", "machine", actualMachine.Name)

                                helper, err := patch.NewHelper(&amp;actualMachine, params.Client)
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                                <span class="cov8" title="1">actualMachine.Status.Ready = true
                                err = helper.Patch(ctx, &amp;actualMachine)
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                        }
                        <span class="cov8" title="1">continue</span>
                }

                <span class="cov8" title="1">labels := map[string]string{
                        clusterv1.ClusterNameLabel:     params.Cluster.Name,
                        clusterv1.MachinePoolNameLabel: format.MustFormatValue(params.MachinePool.Name),
                }
                infraMachine := &amp;infrav2exp.OCIMachinePoolMachine{
                        ObjectMeta: metav1.ObjectMeta{
                                Namespace:    params.Namespace,
                                GenerateName: params.MachinePool.Name,
                                Labels:       labels,
                                Annotations:  make(map[string]string),
                                // set the parent to infra machinepool till the capi machine reconciler changes it to capi machinepool machine
                                OwnerReferences: []metav1.OwnerReference{
                                        {
                                                Kind:       params.InfraMachinePoolKind,
                                                Name:       params.InfraMachinePoolName,
                                                APIVersion: infrav2exp.GroupVersion.String(),
                                                UID:        params.InfraMachinePoolUID,
                                        },
                                },
                        },
                        Spec: infrav2exp.OCIMachinePoolMachineSpec{
                                OCID:         specMachine.Spec.OCID,
                                ProviderID:   specMachine.Spec.ProviderID,
                                InstanceName: specMachine.Spec.InstanceName,
                                MachineType:  specMachine.Spec.MachineType,
                        },
                }
                infraMachine.Status.Ready = specMachine.Status.Ready
                controllerutil.AddFinalizer(infraMachine, infrav2exp.MachinePoolMachineFinalizer)
                params.Logger.Info("Creating machinepool  machine", "machine", infraMachine.Name, "instanceName", specMachine.Name)

                if err := params.Client.Create(ctx, infraMachine); err != nil </span><span class="cov0" title="0">{
                        return errors.Wrap(err, "failed to create machine")
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func getMachinepoolMachines(ctx context.Context, c client.Client, machinePool *expclusterv1.MachinePool, cluster *clusterv1.Cluster, namespace string) (*infrav2exp.OCIMachinePoolMachineList, error) <span class="cov8" title="1">{
        machineList := &amp;infrav2exp.OCIMachinePoolMachineList{}
        labels := map[string]string{
                clusterv1.ClusterNameLabel:     cluster.Name,
                clusterv1.MachinePoolNameLabel: format.MustFormatValue(machinePool.Name),
        }
        if err := c.List(ctx, machineList, client.InNamespace(namespace), client.MatchingLabels(labels)); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return machineList, nil</span>
}

// DeleteOrphanedMachinePoolMachines deletes the machine pool machines which are not required. This method lists the
// existing machines in the clusters and does a diff with the spec and deletes any machines which are missing from the spec.
func DeleteOrphanedMachinePoolMachines(ctx context.Context, params MachineParams) error <span class="cov8" title="1">{
        machineList, err := getMachinepoolMachines(ctx, params.Client, params.MachinePool, params.Cluster, params.Namespace)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // create a set of instances in the spec, which will be used for lookup later
        <span class="cov8" title="1">instanceSpecSet := map[string]struct{}{}
        for _, specMachine := range params.SpecInfraMachines </span><span class="cov0" title="0">{
                instanceSpecSet[*specMachine.Spec.OCID] = struct{}{}
        }</span>

        <span class="cov8" title="1">for i := range machineList.Items </span><span class="cov8" title="1">{
                machinePoolMachine := &amp;machineList.Items[i]
                // lookup if the machinepool machine is not in the spec, if not delete the underlying machine
                if _, ok := instanceSpecSet[*machinePoolMachine.Spec.OCID]; !ok </span><span class="cov8" title="1">{
                        machine, err := util.GetOwnerMachine(ctx, params.Client, machinePoolMachine.ObjectMeta)
                        if err != nil </span><span class="cov8" title="1">{
                                if apierrors.IsNotFound(err) </span><span class="cov8" title="1">{
                                        params.Logger.Info("Machinepool machine has not been created", "machine", machinePoolMachine.Name)
                                        continue</span>
                                }
                                <span class="cov8" title="1">return errors.Wrapf(err, "failed to get owner Machine for machinepool machine %s/%s", machinePoolMachine.Namespace, machinePoolMachine.Name)</span>
                        }
                        <span class="cov8" title="1">if machine == nil </span><span class="cov0" title="0">{
                                return errors.Errorf("Machinepool %s/%s has no parent Machine, will reattempt deletion once parent Machine is present", machinePoolMachine.Namespace, machinePoolMachine.Name)
                        }</span>
                        <span class="cov8" title="1">params.Logger.Info("Deleting machinepool machine", "machine", machine.Name)
                        if err := params.Client.Delete(ctx, machine); err != nil </span><span class="cov0" title="0">{
                                return errors.Wrapf(err, "failed to delete machinepool machine %s/%s", machine.Namespace, machine.Name)
                        }</span>
                } else<span class="cov0" title="0"> {
                        params.Logger.Info("Keeping machinepool, nothing to do", "machine", machinePoolMachine.Name, "namespace", machinePoolMachine.Namespace)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}
func getRegionInfoFromInstanceMetadataServiceProd() ([]byte, error) <span class="cov0" title="0">{
        request, err := http.NewRequest(http.MethodGet, instanceMetadataRegionInfoURLV2, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">request.Header.Add("Authorization", "Bearer Oracle")

        client := &amp;http.Client{
                Timeout: time.Second * 10,
        }
        resp, err := client.Do(request)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "failed to call instance metadata service")
        }</span>

        <span class="cov0" title="0">statusCode := resp.StatusCode

        defer resp.Body.Close()

        content, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "failed to get region information from response body")
        }</span>

        <span class="cov0" title="0">if statusCode != http.StatusOK </span><span class="cov0" title="0">{
                err = fmt.Errorf("HTTP Get failed: URL: %s, Status: %s, Message: %s",
                        instanceMetadataRegionInfoURLV2, resp.Status, string(content))
                return nil, err
        }</span>

        <span class="cov0" title="0">return content, nil</span>
}

// MachineParams specifies the params required to create or delete machinepool machines.
// Infra machine pool specifed below refers to OCIManagedMachinePool/OCIMachinePool/OCIVirtualMachinePool
type MachineParams struct {
        Client               client.Client                      // the kubernetes client
        MachinePool          *expclusterv1.MachinePool          // the corresponding machinepool
        Cluster              *clusterv1.Cluster                 // the corresponding cluster
        InfraMachinePoolName string                             // the name of the infra machinepool corresponding(can be managed/self managed/virtual)
        InfraMachinePoolKind string                             // the kind of infra machinepool(can be managed/self managed/virtual)
        InfraMachinePoolUID  types.UID                          // the UID of the infra machinepool
        Namespace            string                             // the namespace in which machinepool machine has to be created
        SpecInfraMachines    []infrav2exp.OCIMachinePoolMachine // the spec of actual machines in the pool
        Logger               *logr.Logger                       // the logger which has to be used
}
</pre>
		
		<pre class="file" id="file75" style="display: none">/*
Copyright (c) 2021, 2022 Oracle and/or its affiliates.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package controllers

import (
        "context"
        "fmt"
        "strings"

        "github.com/go-logr/logr"
        "github.com/oracle/cluster-api-provider-oci/api/v1beta2"
        infrastructurev1beta2 "github.com/oracle/cluster-api-provider-oci/api/v1beta2"
        "github.com/oracle/cluster-api-provider-oci/cloud/scope"
        cloudutil "github.com/oracle/cluster-api-provider-oci/cloud/util"
        "github.com/pkg/errors"
        corev1 "k8s.io/api/core/v1"
        apierrors "k8s.io/apimachinery/pkg/api/errors"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/runtime"
        "k8s.io/apimachinery/pkg/types"
        "k8s.io/client-go/tools/record"
        clusterv1 "sigs.k8s.io/cluster-api/api/core/v1beta1"
        "sigs.k8s.io/cluster-api/util"
        "sigs.k8s.io/cluster-api/util/annotations"
        "sigs.k8s.io/cluster-api/util/deprecated/v1beta1/conditions"
        "sigs.k8s.io/cluster-api/util/patch"
        "sigs.k8s.io/cluster-api/util/predicates"
        ctrl "sigs.k8s.io/controller-runtime"
        "sigs.k8s.io/controller-runtime/pkg/builder"
        "sigs.k8s.io/controller-runtime/pkg/client"
        "sigs.k8s.io/controller-runtime/pkg/controller"
        "sigs.k8s.io/controller-runtime/pkg/controller/controllerutil"
        "sigs.k8s.io/controller-runtime/pkg/handler"
        "sigs.k8s.io/controller-runtime/pkg/log"
        "sigs.k8s.io/controller-runtime/pkg/reconcile"
)

// OCIClusterReconciler reconciles a OciCluster object
type OCIClusterReconciler struct {
        client.Client
        Scheme         *runtime.Scheme
        Recorder       record.EventRecorder
        Region         string
        ClientProvider *scope.ClientProvider
}

//+kubebuilder:rbac:groups=infrastructure.cluster.x-k8s.io,resources=ociclusters,verbs=get;list;watch;create;update;patch;delete
//+kubebuilder:rbac:groups=infrastructure.cluster.x-k8s.io,resources=ociclusters/status,verbs=get;update;patch
//+kubebuilder:rbac:groups=infrastructure.cluster.x-k8s.io,resources=ociclusters/finalizers,verbs=update

// Reconcile is part of the main kubernetes reconciliation loop which aims to
// move the current state of the machine closer to the desired state.
//
// For more details, check Reconcile and its Result here:
// - https://pkg.go.dev/sigs.k8s.io/controller-runtime@v0.8.3/pkg/reconcile
func (r *OCIClusterReconciler) Reconcile(ctx context.Context, req ctrl.Request) (result ctrl.Result, reterr error) <span class="cov8" title="1">{
        logger := log.FromContext(ctx)
        logger = logger.WithValues(scope.OCIClusterKind, req.NamespacedName)

        logger.Info("Inside cluster reconciler")

        // Fetch the OCICluster instance
        ociCluster := &amp;infrastructurev1beta2.OCICluster{}
        err := r.Get(ctx, req.NamespacedName, ociCluster)
        if err != nil </span><span class="cov8" title="1">{
                if apierrors.IsNotFound(err) </span><span class="cov8" title="1">{
                        return ctrl.Result{}, nil
                }</span>
                <span class="cov0" title="0">return ctrl.Result{}, err</span>
        }

        // Fetch the Cluster.
        <span class="cov8" title="1">cluster, err := util.GetOwnerCluster(ctx, r.Client, ociCluster.ObjectMeta)
        if err != nil </span><span class="cov0" title="0">{
                return ctrl.Result{}, err
        }</span>
        <span class="cov8" title="1">if cluster == nil </span><span class="cov8" title="1">{
                r.Recorder.Eventf(ociCluster, corev1.EventTypeNormal, "OwnerRefNotSet", "Cluster Controller has not yet set OwnerRef")
                logger.Info("Cluster Controller has not yet set OwnerRef")
                return ctrl.Result{}, nil
        }</span>
        // Convert v1beta2 Cluster to v1beta1 for scope compatibility
        <span class="cov8" title="1">clusterV1beta1, err := cloudutil.ConvertClusterV1Beta2ToV1Beta1(cluster)
        if err != nil </span><span class="cov0" title="0">{
                return ctrl.Result{}, errors.Wrap(err, "failed to convert cluster to v1beta1")
        }</span>

        // Return early if the object or Cluster is paused.
        <span class="cov8" title="1">if annotations.IsPaused(cluster, ociCluster) </span><span class="cov8" title="1">{
                r.Recorder.Eventf(ociCluster, corev1.EventTypeNormal, "ClusterPaused", "Cluster is paused")
                logger.Info("OCICluster or linked Cluster is marked as paused. Won't reconcile")
                return ctrl.Result{}, nil
        }</span>

        <span class="cov0" title="0">var clusterScope scope.ClusterScopeClient
        var clients scope.OCIClients
        var clientProvider *scope.ClientProvider
        clusterAccessor := scope.OCISelfManagedCluster{
                OCICluster: ociCluster,
        }
        clientProvider, clusterRegion, clients, err := cloudutil.InitClientsAndRegion(ctx, r.Client, r.Region, clusterAccessor, r.ClientProvider)
        if err != nil </span><span class="cov0" title="0">{
                return ctrl.Result{}, err
        }</span>
        <span class="cov0" title="0">helper, err := patch.NewHelper(ociCluster, r.Client)
        if err != nil </span><span class="cov0" title="0">{
                return ctrl.Result{}, errors.Wrap(err, "failed to init patch helper")
        }</span>
        <span class="cov0" title="0">clusterScope, err = scope.NewClusterScope(scope.ClusterScopeParams{
                Client:                    r.Client,
                Logger:                    &amp;logger,
                Cluster:                   clusterV1beta1,
                OCIClusterAccessor:        clusterAccessor,
                ClientProvider:            clientProvider,
                VCNClient:                 clients.VCNClient,
                NetworkLoadBalancerClient: clients.NetworkLoadBalancerClient,
                LoadBalancerClient:        clients.LoadBalancerClient,
                IdentityClient:            clients.IdentityClient,
                RegionIdentifier:          clusterRegion,
        })
        if err != nil </span><span class="cov0" title="0">{
                logger.Error(err, "Couldn't create cluster scope")
                return ctrl.Result{}, err
        }</span>

        // Always close the scope when exiting this function so we can persist any OCICluster changes.
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                logger.Info("Closing cluster scope")
                conditions.SetSummary(ociCluster)

                if err := helper.Patch(ctx, ociCluster); err != nil &amp;&amp; reterr == nil </span><span class="cov0" title="0">{
                        reterr = err
                }</span>
        }()

        // Handle deleted clusters
        <span class="cov0" title="0">if !ociCluster.DeletionTimestamp.IsZero() </span><span class="cov0" title="0">{
                return r.reconcileDelete(ctx, logger, clusterScope, ociCluster)
        }</span>

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return reconcile.Result{}, errors.Errorf("failed to create scope: %+v", err)
        }</span> else<span class="cov0" title="0"> {
                return r.reconcile(ctx, logger, clusterScope, ociCluster)
        }</span>

}

func (r *OCIClusterReconciler) reconcileComponent(ctx context.Context, cluster *v1beta2.OCICluster,
        reconciler func(context.Context) error,
        componentName string, failReason string, readyEventtype string) error <span class="cov8" title="1">{

        err := reconciler(ctx)
        if err != nil </span><span class="cov8" title="1">{
                r.Recorder.Event(cluster, corev1.EventTypeWarning, "ReconcileError", errors.Wrapf(err, "%s",
                        fmt.Sprintf("failed to reconcile %s", componentName)).Error())
                conditions.MarkFalse(cluster, infrastructurev1beta2.ClusterReadyCondition, failReason, clusterv1.ConditionSeverityError, "")
                return errors.Wrapf(err, "failed to reconcile %s for OCICluster %s/%s", componentName, cluster.Namespace,
                        cluster.Name)
        }</span>

        <span class="cov8" title="1">trimmedComponentName := strings.ReplaceAll(componentName, " ", "")
        r.Recorder.Eventf(cluster, corev1.EventTypeNormal, readyEventtype,
                fmt.Sprintf("%s is in ready state", trimmedComponentName))

        return nil</span>
}

// SkipApiserverManagement is a hack to check for the annotation "cluster.x-k8s.io/skip-apiserver-management"
func skipApiserverManagement(o metav1.Object) bool <span class="cov8" title="1">{
        annotations := o.GetAnnotations()
        if annotations == nil </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov0" title="0">_, ok := annotations["cluster.x-k8s.io/skip-apiserver-lb-management"]
        return ok</span>
}

func (r *OCIClusterReconciler) reconcile(ctx context.Context, logger logr.Logger, clusterScope scope.ClusterScopeClient, cluster *infrastructurev1beta2.OCICluster) (ctrl.Result, error) <span class="cov8" title="1">{
        // If the OCICluster doesn't have our finalizer, add it.
        controllerutil.AddFinalizer(cluster, infrastructurev1beta2.ClusterFinalizer)

        // This below if condition specifies if the network related infrastructure needs to be reconciled. Any new
        // network related reconcilication should happen in this if condition
        if !cluster.Spec.NetworkSpec.SkipNetworkManagement </span><span class="cov8" title="1">{
                err := clusterScope.SetRegionKey(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error(err, "Couldn't get region code")
                        return ctrl.Result{}, err
                }</span>

                <span class="cov8" title="1">if err := r.reconcileComponent(ctx, cluster, clusterScope.ReconcileDRG, "DRG",
                        infrastructurev1beta2.DrgReconciliationFailedReason, infrastructurev1beta2.DrgEventReady); err != nil </span><span class="cov8" title="1">{
                        return ctrl.Result{}, err
                }</span>

                <span class="cov8" title="1">if err := r.reconcileComponent(ctx, cluster, clusterScope.ReconcileVCN, "VCN",
                        infrastructurev1beta2.VcnReconciliationFailedReason, infrastructurev1beta2.VcnEventReady); err != nil </span><span class="cov8" title="1">{
                        return ctrl.Result{}, err
                }</span>

                <span class="cov8" title="1">if err := r.reconcileComponent(ctx, cluster, clusterScope.ReconcileInternetGateway, "Internet Gateway",
                        infrastructurev1beta2.InternetGatewayReconciliationFailedReason, infrastructurev1beta2.InternetGatewayEventReady); err != nil </span><span class="cov8" title="1">{
                        return ctrl.Result{}, err
                }</span>

                <span class="cov8" title="1">if err := r.reconcileComponent(ctx, cluster, clusterScope.ReconcileNatGateway, "NAT Gateway",
                        infrastructurev1beta2.NatGatewayReconciliationFailedReason, infrastructurev1beta2.NatEventReady); err != nil </span><span class="cov8" title="1">{
                        return ctrl.Result{}, err
                }</span>

                <span class="cov8" title="1">if err := r.reconcileComponent(ctx, cluster, clusterScope.ReconcileServiceGateway, "Service Gateway",
                        infrastructurev1beta2.ServiceGatewayReconciliationFailedReason, infrastructurev1beta2.ServiceGatewayEventReady); err != nil </span><span class="cov8" title="1">{
                        return ctrl.Result{}, err
                }</span>

                <span class="cov8" title="1">if err := r.reconcileComponent(ctx, cluster, clusterScope.ReconcileNSG, "Network Security Group",
                        infrastructurev1beta2.NSGReconciliationFailedReason, infrastructurev1beta2.NetworkSecurityEventReady); err != nil </span><span class="cov8" title="1">{
                        return ctrl.Result{}, err
                }</span>

                <span class="cov8" title="1">if err := r.reconcileComponent(ctx, cluster, clusterScope.ReconcileRouteTable, "Route Table",
                        infrastructurev1beta2.RouteTableReconciliationFailedReason, infrastructurev1beta2.RouteTableEventReady); err != nil </span><span class="cov8" title="1">{
                        return ctrl.Result{}, err
                }</span>

                <span class="cov8" title="1">if err := r.reconcileComponent(ctx, cluster, clusterScope.ReconcileSubnet, "Subnet",
                        infrastructurev1beta2.SubnetReconciliationFailedReason, infrastructurev1beta2.SubnetEventReady); err != nil </span><span class="cov8" title="1">{
                        return ctrl.Result{}, err
                }</span>

                <span class="cov8" title="1">if err := r.reconcileComponent(ctx, cluster, clusterScope.ReconcileDRGVCNAttachment, "DRGVCNAttachment",
                        infrastructurev1beta2.DRGVCNAttachmentReconciliationFailedReason, infrastructurev1beta2.DRGVCNAttachmentEventReady); err != nil </span><span class="cov8" title="1">{
                        return ctrl.Result{}, err
                }</span>

                <span class="cov8" title="1">if err := r.reconcileComponent(ctx, cluster, clusterScope.ReconcileDRGRPCAttachment, "DRGRPCAttachment",
                        infrastructurev1beta2.DRGRPCAttachmentReconciliationFailedReason, infrastructurev1beta2.DRGRPCAttachmentEventReady); err != nil </span><span class="cov8" title="1">{
                        return ctrl.Result{}, err
                }</span>
        } else<span class="cov8" title="1"> {
                logger.Info("VCN Reconciliation is skipped")
        }</span>

        <span class="cov8" title="1">if err := r.reconcileComponent(ctx, cluster, clusterScope.ReconcileFailureDomains, "Failure Domain",
                infrastructurev1beta2.FailureDomainFailedReason, infrastructurev1beta2.FailureDomainEventReady); err != nil </span><span class="cov8" title="1">{
                return ctrl.Result{}, err
        }</span>

        <span class="cov8" title="1">if !skipApiserverManagement(cluster) </span><span class="cov8" title="1">{
                // Reconcile the API Server LoadBalancer based on the specified LoadBalancerType.
                loadBalancerType := cluster.Spec.NetworkSpec.APIServerLB.LoadBalancerType
                if loadBalancerType == infrastructurev1beta2.LoadBalancerTypeLB </span><span class="cov0" title="0">{
                        if err := r.reconcileComponent(ctx, cluster, clusterScope.ReconcileApiServerLB, "Api Server Loadbalancer",
                                infrastructurev1beta2.APIServerLoadBalancerFailedReason, infrastructurev1beta2.ApiServerLoadBalancerEventReady); err != nil </span><span class="cov0" title="0">{
                                return ctrl.Result{}, err
                        }</span>
                } else<span class="cov8" title="1"> {
                        if err := r.reconcileComponent(ctx, cluster, clusterScope.ReconcileApiServerNLB, "Api Server Network Loadbalancer",
                                infrastructurev1beta2.APIServerLoadBalancerFailedReason, infrastructurev1beta2.ApiServerLoadBalancerEventReady); err != nil </span><span class="cov8" title="1">{
                                return ctrl.Result{}, err
                        }</span>
                }
        } else<span class="cov0" title="0"> {
                logger.Info("ApiServer Loadbalancer Reconciliation is skipped")
        }</span>

        <span class="cov8" title="1">conditions.MarkTrue(cluster, infrastructurev1beta2.ClusterReadyCondition)
        cluster.Status.Ready = true
        return ctrl.Result{}, nil</span>
}

// SetupWithManager sets up the controller with the Manager.
func (r *OCIClusterReconciler) SetupWithManager(ctx context.Context, mgr ctrl.Manager, options controller.Options) error <span class="cov0" title="0">{
        log := ctrl.LoggerFrom(ctx)
        err := ctrl.NewControllerManagedBy(mgr).
                WithOptions(options).
                For(&amp;infrastructurev1beta2.OCICluster{}).
                WithEventFilter(predicates.ResourceNotPaused(mgr.GetScheme(), log)).              // don't queue reconcile if resource is paused
                WithEventFilter(predicates.ResourceIsNotExternallyManaged(mgr.GetScheme(), log)). //the externally managed cluster won't be reconciled
                Watches(
                        &amp;clusterv1.Cluster{},
                        handler.EnqueueRequestsFromMapFunc(r.clusterToInfrastructureMapFunc(log)),
                        builder.WithPredicates(
                                predicates.ClusterUnpaused(mgr.GetScheme(), log),
                                predicates.ResourceNotPausedAndHasFilterLabel(mgr.GetScheme(), log, ""),
                        ),
                ).
                Complete(r)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrapf(err, "error creating controller")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// ClusterToInfrastructureMapFunc returns a handler.ToRequestsFunc that watches for
// Cluster events and returns reconciliation requests for an infrastructure provider object.
func (r *OCIClusterReconciler) clusterToInfrastructureMapFunc(log logr.Logger) handler.MapFunc <span class="cov0" title="0">{
        return func(ctx context.Context, o client.Object) []reconcile.Request </span><span class="cov0" title="0">{
                c, ok := o.(*clusterv1.Cluster)
                if !ok </span><span class="cov0" title="0">{
                        return nil
                }</span>

                // Make sure the ref is set
                <span class="cov0" title="0">if c.Spec.InfrastructureRef == nil </span><span class="cov0" title="0">{
                        log.V(4).Info("Cluster does not have an InfrastructureRef, skipping mapping.")
                        return nil
                }</span>

                <span class="cov0" title="0">if c.Spec.InfrastructureRef.GroupVersionKind().Kind != "OCICluster" </span><span class="cov0" title="0">{
                        log.V(4).Info("Cluster has an InfrastructureRef for a different type, skipping mapping.")
                        return nil
                }</span>

                <span class="cov0" title="0">ociCluster := &amp;infrastructurev1beta2.OCICluster{}
                key := types.NamespacedName{Namespace: c.Spec.InfrastructureRef.Namespace, Name: c.Spec.InfrastructureRef.Name}

                if err := r.Get(ctx, key, ociCluster); err != nil </span><span class="cov0" title="0">{
                        log.V(4).Error(err, "Failed to get OCI cluster")
                        return nil
                }</span>

                <span class="cov0" title="0">if annotations.IsExternallyManaged(ociCluster) </span><span class="cov0" title="0">{
                        log.V(4).Info("OCICluster is externally managed, skipping mapping.")
                        return nil
                }</span>

                <span class="cov0" title="0">log.V(4).Info("Adding request.", "ociCluster", c.Spec.InfrastructureRef.Name)

                return []reconcile.Request{
                        {
                                NamespacedName: client.ObjectKey{
                                        Namespace: c.Namespace,
                                        Name:      c.Spec.InfrastructureRef.Name,
                                },
                        },
                }</span>
        }
}

func (r *OCIClusterReconciler) reconcileDelete(ctx context.Context, logger logr.Logger, clusterScope scope.ClusterScopeClient, cluster *infrastructurev1beta2.OCICluster) (ctrl.Result, error) <span class="cov8" title="1">{
        // Declare the err variable before the if-else block
        var err error

        if !skipApiserverManagement(cluster) </span><span class="cov8" title="1">{
                // Delete API Server LoadBalancer based on the specified LoadBalancerType
                // If the type is LB, it calls DeleteApiServerLbsLB(),
                // If no specific type is provided, it defaults to calling DeleteApiServerLB().
                loadBalancerType := cluster.Spec.NetworkSpec.APIServerLB.LoadBalancerType
                if loadBalancerType == infrastructurev1beta2.LoadBalancerTypeLB </span><span class="cov0" title="0">{
                        err = clusterScope.DeleteApiServerLB(ctx)
                }</span> else<span class="cov8" title="1"> {
                        err = clusterScope.DeleteApiServerNLB(ctx)
                }</span>

                <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                        r.Recorder.Event(cluster, corev1.EventTypeWarning, "ReconcileError", errors.Wrapf(err, "failed to delete Api Server Loadbalancer").Error())
                        conditions.MarkFalse(cluster, infrastructurev1beta2.ClusterReadyCondition, infrastructurev1beta2.APIServerLoadBalancerFailedReason, clusterv1.ConditionSeverityError, "")
                        return ctrl.Result{}, errors.Wrapf(err, "failed to delete apiserver LB for OCICluster %s/%s", cluster.Namespace, cluster.Name)
                }</span>
        } else<span class="cov0" title="0"> {
                logger.Info("ApiServer LB Reconciliation is skipped, the ApiServer Loadbalancer will not be deleted")
        }</span>

        // This below if condition specifies if the network related infrastructure needs to be reconciled. Any new
        // network related reconcilication should happen in this if condition
        <span class="cov8" title="1">if !cluster.Spec.NetworkSpec.SkipNetworkManagement </span><span class="cov8" title="1">{
                err = clusterScope.DeleteDRGRPCAttachment(ctx)
                if err != nil </span><span class="cov8" title="1">{
                        r.Recorder.Event(cluster, corev1.EventTypeWarning, "ReconcileError", errors.Wrapf(err, "failed to delete DRG RPC attachment").Error())
                        conditions.MarkFalse(cluster, infrastructurev1beta2.ClusterReadyCondition, infrastructurev1beta2.DRGRPCAttachmentReconciliationFailedReason, clusterv1.ConditionSeverityError, "")
                        return ctrl.Result{}, errors.Wrapf(err, "failed to delete DRG RPC Attachment  for OCICluster %s/%s", cluster.Namespace, cluster.Name)
                }</span>

                <span class="cov8" title="1">err = clusterScope.DeleteDRGVCNAttachment(ctx)
                if err != nil </span><span class="cov8" title="1">{
                        r.Recorder.Event(cluster, corev1.EventTypeWarning, "ReconcileError", errors.Wrapf(err, "failed to delete DRG VCN attachment").Error())
                        conditions.MarkFalse(cluster, infrastructurev1beta2.ClusterReadyCondition, infrastructurev1beta2.DRGVCNAttachmentReconciliationFailedReason, clusterv1.ConditionSeverityError, "")
                        return ctrl.Result{}, errors.Wrapf(err, "failed to delete DRG VCN Attachment  for OCICluster %s/%s", cluster.Namespace, cluster.Name)
                }</span>

                <span class="cov8" title="1">err = clusterScope.DeleteNSGs(ctx)
                if err != nil </span><span class="cov8" title="1">{
                        r.Recorder.Event(cluster, corev1.EventTypeWarning, "ReconcileError", errors.Wrapf(err, "failed to delete Network Security Group").Error())
                        conditions.MarkFalse(cluster, infrastructurev1beta2.ClusterReadyCondition, infrastructurev1beta2.NSGReconciliationFailedReason, clusterv1.ConditionSeverityError, "")
                        return ctrl.Result{}, errors.Wrapf(err, "failed to delete Network Security Groups for OCICluster %s/%s", cluster.Namespace, cluster.Name)
                }</span>

                <span class="cov8" title="1">err = clusterScope.DeleteSubnets(ctx)
                if err != nil </span><span class="cov8" title="1">{
                        r.Recorder.Event(cluster, corev1.EventTypeWarning, "ReconcileError", errors.Wrapf(err, "failed to delete Subnet").Error())
                        conditions.MarkFalse(cluster, infrastructurev1beta2.ClusterReadyCondition, infrastructurev1beta2.SubnetReconciliationFailedReason, clusterv1.ConditionSeverityError, "")
                        return ctrl.Result{}, errors.Wrapf(err, "failed to delete subnet for OCICluster %s/%s", cluster.Namespace, cluster.Name)
                }</span>

                <span class="cov8" title="1">err = clusterScope.DeleteRouteTables(ctx)
                if err != nil </span><span class="cov8" title="1">{
                        r.Recorder.Event(cluster, corev1.EventTypeWarning, "ReconcileError", errors.Wrapf(err, "failed to delete Route Table").Error())
                        conditions.MarkFalse(cluster, infrastructurev1beta2.ClusterReadyCondition, infrastructurev1beta2.RouteTableReconciliationFailedReason, clusterv1.ConditionSeverityError, "")
                        return ctrl.Result{}, errors.Wrapf(err, "failed to delete RouteTables for OCICluster %s/%s", cluster.Namespace, cluster.Name)
                }</span>

                <span class="cov8" title="1">err = clusterScope.DeleteSecurityLists(ctx)
                if err != nil </span><span class="cov8" title="1">{
                        r.Recorder.Event(cluster, corev1.EventTypeWarning, "ReconcileError", errors.Wrapf(err, "failed to delete Security Lists").Error())
                        conditions.MarkFalse(cluster, infrastructurev1beta2.ClusterReadyCondition, infrastructurev1beta2.SecurityListReconciliationFailedReason, clusterv1.ConditionSeverityError, "")
                        return ctrl.Result{}, errors.Wrapf(err, "failed to delete SecurityLists for OCICluster %s/%s", cluster.Namespace, cluster.Name)
                }</span>

                <span class="cov8" title="1">err = clusterScope.DeleteServiceGateway(ctx)
                if err != nil </span><span class="cov8" title="1">{
                        r.Recorder.Event(cluster, corev1.EventTypeWarning, "ReconcileError", errors.Wrapf(err, "failed to delete Service Gateway").Error())
                        conditions.MarkFalse(cluster, infrastructurev1beta2.ClusterReadyCondition, infrastructurev1beta2.ServiceGatewayReconciliationFailedReason, clusterv1.ConditionSeverityError, "")
                        return ctrl.Result{}, errors.Wrapf(err, "failed to delete ServiceGateway for OCICluster %s/%s", cluster.Namespace, cluster.Name)
                }</span>

                <span class="cov8" title="1">err = clusterScope.DeleteNatGateway(ctx)
                if err != nil </span><span class="cov8" title="1">{
                        r.Recorder.Event(cluster, corev1.EventTypeWarning, "ReconcileError", errors.Wrapf(err, "failed to delete NAT Gateway").Error())
                        conditions.MarkFalse(cluster, infrastructurev1beta2.ClusterReadyCondition, infrastructurev1beta2.NatGatewayReconciliationFailedReason, clusterv1.ConditionSeverityError, "")
                        return ctrl.Result{}, errors.Wrapf(err, "failed to delete NatGateway for OCICluster %s/%s", cluster.Namespace, cluster.Name)
                }</span>

                <span class="cov8" title="1">err = clusterScope.DeleteInternetGateway(ctx)
                if err != nil </span><span class="cov8" title="1">{
                        r.Recorder.Event(cluster, corev1.EventTypeWarning, "ReconcileError", errors.Wrapf(err, "failed to delete Internet Gateway").Error())
                        conditions.MarkFalse(cluster, infrastructurev1beta2.ClusterReadyCondition, infrastructurev1beta2.InternetGatewayReconciliationFailedReason, clusterv1.ConditionSeverityError, "")
                        return ctrl.Result{}, errors.Wrapf(err, "failed to delete InternetGateway for OCICluster %s/%s", cluster.Namespace, cluster.Name)
                }</span>

                <span class="cov8" title="1">err = clusterScope.DeleteVCN(ctx)
                if err != nil </span><span class="cov8" title="1">{
                        r.Recorder.Event(cluster, corev1.EventTypeWarning, "ReconcileError", errors.Wrapf(err, "failed to delete VCN").Error())
                        conditions.MarkFalse(cluster, infrastructurev1beta2.ClusterReadyCondition, infrastructurev1beta2.VcnReconciliationFailedReason, clusterv1.ConditionSeverityError, "")
                        return ctrl.Result{}, errors.Wrapf(err, "failed to delete VCN for OCICluster %s/%s", cluster.Namespace, cluster.Name)
                }</span>

                <span class="cov8" title="1">err = clusterScope.DeleteDRG(ctx)
                if err != nil </span><span class="cov8" title="1">{
                        r.Recorder.Event(cluster, corev1.EventTypeWarning, "ReconcileError", errors.Wrapf(err, "failed to delete DRG").Error())
                        conditions.MarkFalse(cluster, infrastructurev1beta2.ClusterReadyCondition, infrastructurev1beta2.DrgReconciliationFailedReason, clusterv1.ConditionSeverityError, "")
                        return ctrl.Result{}, errors.Wrapf(err, "failed to delete DRG for OCICluster %s/%s", cluster.Namespace, cluster.Name)
                }</span>

        } else<span class="cov8" title="1"> {
                logger.Info("VCN Reconciliation is skipped, none of the VCN related resources will be deleted")
        }</span>
        <span class="cov8" title="1">controllerutil.RemoveFinalizer(cluster, v1beta2.ClusterFinalizer)

        return reconcile.Result{}, nil</span>
}
</pre>
		
		<pre class="file" id="file76" style="display: none">/*
Copyright (c) 2021, 2022 Oracle and/or its affiliates.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package controllers

import (
        "context"
        "fmt"
        "time"

        "github.com/go-logr/logr"
        infrastructurev1beta2 "github.com/oracle/cluster-api-provider-oci/api/v1beta2"
        "github.com/oracle/cluster-api-provider-oci/cloud/ociutil"
        "github.com/oracle/cluster-api-provider-oci/cloud/scope"
        cloudutil "github.com/oracle/cluster-api-provider-oci/cloud/util"
        "github.com/oracle/oci-go-sdk/v65/common"
        "github.com/oracle/oci-go-sdk/v65/core"
        "github.com/oracle/oci-go-sdk/v65/workrequests"
        "github.com/pkg/errors"
        corev1 "k8s.io/api/core/v1"
        apierrors "k8s.io/apimachinery/pkg/api/errors"
        "k8s.io/apimachinery/pkg/runtime"
        "k8s.io/client-go/tools/record"
        clusterv1 "sigs.k8s.io/cluster-api/api/core/v1beta1"
        "sigs.k8s.io/cluster-api/util"
        "sigs.k8s.io/cluster-api/util/annotations"
        "sigs.k8s.io/cluster-api/util/deprecated/v1beta1/conditions"
        "sigs.k8s.io/cluster-api/util/predicates"
        ctrl "sigs.k8s.io/controller-runtime"
        "sigs.k8s.io/controller-runtime/pkg/builder"
        "sigs.k8s.io/controller-runtime/pkg/client"
        "sigs.k8s.io/controller-runtime/pkg/controller"
        "sigs.k8s.io/controller-runtime/pkg/controller/controllerutil"
        "sigs.k8s.io/controller-runtime/pkg/handler"
        "sigs.k8s.io/controller-runtime/pkg/log"
        "sigs.k8s.io/controller-runtime/pkg/reconcile"
)

// OCIMachineReconciler reconciles a OciMachine object
type OCIMachineReconciler struct {
        client.Client
        Scheme         *runtime.Scheme
        Recorder       record.EventRecorder
        ClientProvider *scope.ClientProvider
        Region         string
}

//+kubebuilder:rbac:groups=infrastructure.cluster.x-k8s.io,resources=ocimachines,verbs=get;list;watch;create;update;patch;delete
//+kubebuilder:rbac:groups=infrastructure.cluster.x-k8s.io,resources=ocimachines/status,verbs=get;update;patch
//+kubebuilder:rbac:groups=infrastructure.cluster.x-k8s.io,resources=ocimachines/finalizers,verbs=update

// Reconcile is part of the main kubernetes reconciliation loop which aims to
// move the current state of the machine closer to the desired state.
//
// For more details, check Reconcile and its Result here:
// - https://pkg.go.dev/sigs.k8s.io/controller-runtime@v0.8.3/pkg/reconcile
func (r *OCIMachineReconciler) Reconcile(ctx context.Context, req ctrl.Request) (result ctrl.Result, reterr error) <span class="cov8" title="1">{
        logger := log.FromContext(ctx)
        logger.Info("Got reconciliation event for machine")

        ociMachine := &amp;infrastructurev1beta2.OCIMachine{}
        err := r.Get(ctx, req.NamespacedName, ociMachine)

        if err != nil </span><span class="cov8" title="1">{
                if apierrors.IsNotFound(err) </span><span class="cov8" title="1">{
                        return ctrl.Result{}, nil
                }</span>
                <span class="cov0" title="0">return ctrl.Result{}, err</span>
        }
        // Fetch the Machine.
        <span class="cov8" title="1">machine, err := util.GetOwnerMachine(ctx, r.Client, ociMachine.ObjectMeta)

        if err != nil </span><span class="cov0" title="0">{
                return ctrl.Result{}, err
        }</span>
        <span class="cov8" title="1">if machine == nil </span><span class="cov8" title="1">{
                r.Recorder.Eventf(ociMachine, corev1.EventTypeNormal, "OwnerRefNotSet", "Cluster Controller has not yet set OwnerRef")
                logger.Info("Machine Controller has not yet set OwnerRef")
                return ctrl.Result{}, nil
        }</span>
        // Convert v1beta2 Machine to v1beta1 for scope compatibility
        <span class="cov8" title="1">machineV1beta1, err := cloudutil.ConvertMachineV1Beta2ToV1Beta1(machine)
        if err != nil </span><span class="cov0" title="0">{
                return ctrl.Result{}, errors.Wrap(err, "failed to convert machine to v1beta1")
        }</span>

        <span class="cov8" title="1">logger = logger.WithValues("machine-name", ociMachine.Name)

        // Fetch the Cluster.
        cluster, err := util.GetClusterFromMetadata(ctx, r.Client, ociMachine.ObjectMeta)
        if err != nil </span><span class="cov8" title="1">{
                r.Recorder.Eventf(ociMachine, corev1.EventTypeWarning, "ClusterDoesNotExist", "Machine is missing cluster label or cluster does not exist")
                logger.Info("Machine is missing cluster label or cluster does not exist")
                return ctrl.Result{}, nil
        }</span>

        // Return early if the object or Cluster is paused.
        <span class="cov8" title="1">if annotations.IsPaused(cluster, ociMachine) </span><span class="cov8" title="1">{
                logger.Info("OCIMachine or linked Cluster is marked as paused. Won't reconcile")
                return ctrl.Result{}, nil
        }</span>
        // Convert v1beta2 Cluster to v1beta1 for scope compatibility
        <span class="cov8" title="1">clusterV1beta1, err := cloudutil.ConvertClusterV1Beta2ToV1Beta1(cluster)
        if err != nil </span><span class="cov0" title="0">{
                return ctrl.Result{}, errors.Wrap(err, "failed to convert cluster to v1beta1")
        }</span>

        <span class="cov8" title="1">ociCluster := &amp;infrastructurev1beta2.OCICluster{}
        ociClusterName := client.ObjectKey{
                Namespace: cluster.Namespace,
                Name:      cluster.Spec.InfrastructureRef.Name,
        }

        var clusterAccessor scope.OCIClusterAccessor
        if cluster.Spec.InfrastructureRef.Kind == "OCICluster" </span><span class="cov8" title="1">{
                if err := r.Client.Get(ctx, ociClusterName, ociCluster); err != nil </span><span class="cov8" title="1">{
                        logger.Info("Cluster is not available yet")
                        r.Recorder.Eventf(ociMachine, corev1.EventTypeWarning, "ClusterNotAvailable", "Cluster is not available yet")
                        return ctrl.Result{}, nil
                }</span>
                <span class="cov8" title="1">clusterAccessor = scope.OCISelfManagedCluster{
                        OCICluster: ociCluster,
                }</span>
        } else<span class="cov0" title="0"> if cluster.Spec.InfrastructureRef.Kind == "OCIManagedCluster" </span><span class="cov0" title="0">{
                // check for oci managed cluster
                ociManagedCluster := &amp;infrastructurev1beta2.OCIManagedCluster{}
                ociManagedClusterName := client.ObjectKey{
                        Namespace: clusterV1beta1.Namespace,
                        Name:      clusterV1beta1.Spec.InfrastructureRef.Name,
                }
                if err := r.Client.Get(ctx, ociManagedClusterName, ociManagedCluster); err != nil </span>{<span class="cov0" title="0">

                }</span>
                <span class="cov0" title="0">clusterAccessor = scope.OCIManagedCluster{
                        OCIManagedCluster: ociManagedCluster,
                }</span>
        } else<span class="cov0" title="0"> {
                r.Recorder.Eventf(ociMachine, corev1.EventTypeWarning, "InfrastructureClusterTypeNotSupported", fmt.Sprintf("Infrastructure Cluster Type %s is not supported", cluster.Spec.InfrastructureRef.Kind))
                return ctrl.Result{}, errors.New(fmt.Sprintf("Infrastructure Cluster Type %s is not supported", clusterV1beta1.Spec.InfrastructureRef.Kind))
        }</span>

        <span class="cov8" title="1">_, _, clients, err := cloudutil.InitClientsAndRegion(ctx, r.Client, r.Region, clusterAccessor, r.ClientProvider)
        if err != nil </span><span class="cov0" title="0">{
                return ctrl.Result{}, err
        }</span>

        // Create the machine scope
        <span class="cov8" title="1">machineScope, err := scope.NewMachineScope(scope.MachineScopeParams{
                Client:                    r.Client,
                ComputeClient:             clients.ComputeClient,
                Logger:                    &amp;logger,
                Cluster:                   clusterV1beta1,
                OCIClusterAccessor:        clusterAccessor,
                Machine:                   machineV1beta1,
                OCIMachine:                ociMachine,
                VCNClient:                 clients.VCNClient,
                NetworkLoadBalancerClient: clients.NetworkLoadBalancerClient,
                LoadBalancerClient:        clients.LoadBalancerClient,
                WorkRequestsClient:        clients.WorkRequestsClient,
        })
        if err != nil </span><span class="cov0" title="0">{
                return ctrl.Result{}, errors.Errorf("failed to create scope: %+v", err)
        }</span>
        // Always close the scope when exiting this function so we can persist any GCPMachine changes.
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                if err := machineScope.Close(ctx); err != nil &amp;&amp; reterr == nil </span><span class="cov0" title="0">{
                        reterr = err
                }</span>
        }()

        // Handle deleted machines
        <span class="cov8" title="1">if !ociMachine.DeletionTimestamp.IsZero() </span><span class="cov8" title="1">{
                return r.reconcileDelete(ctx, machineScope)
        }</span>

        // Handle non-deleted machines
        <span class="cov8" title="1">return r.reconcileNormal(ctx, logger, machineScope)</span>
}

// SetupWithManager sets up the controller with the Manager.
func (r *OCIMachineReconciler) SetupWithManager(ctx context.Context, mgr ctrl.Manager, options controller.Options) error <span class="cov0" title="0">{
        clusterToObjectFunc, err := util.ClusterToTypedObjectsMapper(r.Client, &amp;infrastructurev1beta2.OCIMachineList{}, mgr.GetScheme())
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrapf(err, "failed to create mapper for Cluster to OCIMachines")
        }</span>
        <span class="cov0" title="0">err = ctrl.NewControllerManagedBy(mgr).
                WithOptions(options).
                For(&amp;infrastructurev1beta2.OCIMachine{}).
                WithEventFilter(predicates.ResourceNotPaused(mgr.GetScheme(), ctrl.LoggerFrom(ctx))).
                Watches(
                        &amp;clusterv1.Machine{},
                        handler.EnqueueRequestsFromMapFunc(util.MachineToInfrastructureMapFunc(infrastructurev1beta2.
                                GroupVersion.WithKind(scope.OCIMachineKind))),
                ).
                Watches(
                        &amp;infrastructurev1beta2.OCICluster{},
                        handler.EnqueueRequestsFromMapFunc(r.OCIClusterToOCIMachines()),
                ).
                Watches(
                        &amp;infrastructurev1beta2.OCIManagedCluster{},
                        handler.EnqueueRequestsFromMapFunc(r.OCIManagedClusterToOCIMachines()),
                ).
                Watches(
                        &amp;clusterv1.Cluster{},
                        handler.EnqueueRequestsFromMapFunc(clusterToObjectFunc),
                        builder.WithPredicates(
                                predicates.ClusterPausedTransitionsOrInfrastructureProvisioned(mgr.GetScheme(), ctrl.LoggerFrom(ctx)),
                        ),
                ).
                // don't queue reconcile if resource is paused
                Complete(r)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrapf(err, "error creating controller")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (r *OCIMachineReconciler) OCIClusterToOCIMachines() handler.MapFunc <span class="cov0" title="0">{
        return func(ctx context.Context, o client.Object) []ctrl.Request </span><span class="cov0" title="0">{
                log := ctrl.LoggerFrom(ctx)
                result := []ctrl.Request{}

                c, ok := o.(*infrastructurev1beta2.OCICluster)
                if !ok </span><span class="cov0" title="0">{
                        log.Error(errors.Errorf("expected a OCICluster but got a %T", o), "failed to get OCIMachine for OCICluster")
                        return nil
                }</span>

                <span class="cov0" title="0">cluster, err := util.GetOwnerCluster(ctx, r.Client, c.ObjectMeta)
                switch </span>{
                case apierrors.IsNotFound(err) || cluster == nil:<span class="cov0" title="0">
                        return result</span>
                case err != nil:<span class="cov0" title="0">
                        log.Error(err, "failed to get owning cluster")
                        return result</span>
                }

                <span class="cov0" title="0">labels := map[string]string{clusterv1.ClusterNameLabel: cluster.Name}
                machineList := &amp;clusterv1.MachineList{}
                if err := r.List(ctx, machineList, client.InNamespace(c.Namespace), client.MatchingLabels(labels)); err != nil </span><span class="cov0" title="0">{
                        log.Error(err, "failed to list Machines")
                        return nil
                }</span>
                <span class="cov0" title="0">for _, m := range machineList.Items </span><span class="cov0" title="0">{
                        if m.Spec.InfrastructureRef.Name == "" </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">name := client.ObjectKey{Namespace: m.Namespace, Name: m.Spec.InfrastructureRef.Name}
                        result = append(result, ctrl.Request{NamespacedName: name})</span>
                }

                <span class="cov0" title="0">return result</span>
        }
}

func (r *OCIMachineReconciler) OCIManagedClusterToOCIMachines() handler.MapFunc <span class="cov0" title="0">{
        return func(ctx context.Context, o client.Object) []ctrl.Request </span><span class="cov0" title="0">{
                log := ctrl.LoggerFrom(ctx)
                result := []ctrl.Request{}

                c, ok := o.(*infrastructurev1beta2.OCIManagedCluster)
                if !ok </span><span class="cov0" title="0">{
                        log.Error(errors.Errorf("expected a OCICluster but got a %T", o), "failed to get OCIMachine for OCICluster")
                        return nil
                }</span>

                <span class="cov0" title="0">cluster, err := util.GetOwnerCluster(ctx, r.Client, c.ObjectMeta)
                switch </span>{
                case apierrors.IsNotFound(err) || cluster == nil:<span class="cov0" title="0">
                        return result</span>
                case err != nil:<span class="cov0" title="0">
                        log.Error(err, "failed to get owning cluster")
                        return result</span>
                }

                <span class="cov0" title="0">labels := map[string]string{clusterv1.ClusterNameLabel: cluster.Name}
                machineList := &amp;clusterv1.MachineList{}
                if err := r.List(ctx, machineList, client.InNamespace(c.Namespace), client.MatchingLabels(labels)); err != nil </span><span class="cov0" title="0">{
                        log.Error(err, "failed to list Machines")
                        return nil
                }</span>
                <span class="cov0" title="0">for _, m := range machineList.Items </span><span class="cov0" title="0">{
                        if m.Spec.InfrastructureRef.Name == "" </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">name := client.ObjectKey{Namespace: m.Namespace, Name: m.Spec.InfrastructureRef.Name}
                        result = append(result, ctrl.Request{NamespacedName: name})</span>
                }

                <span class="cov0" title="0">return result</span>
        }
}

func (r *OCIMachineReconciler) recordErrorsOnFailedWorkRequest(ctx context.Context, logger logr.Logger, machineScope *scope.MachineScope, instance *core.Instance) (ctrl.Result, error) <span class="cov8" title="1">{
        machine := machineScope.OCIMachine
        wrequest := workrequests.ListWorkRequestsRequest{
                CompartmentId: instance.CompartmentId,
                ResourceId:    instance.Id,
        }
        wresp, err := machineScope.WorkRequestsClient.ListWorkRequests(ctx, wrequest)
        if err != nil </span><span class="cov0" title="0">{
                r.Recorder.Event(machine, corev1.EventTypeWarning, "ReconcileError", errors.Wrapf(err, "Failed to reconcile OCIMachine").Error())
                return reconcile.Result{}, errors.Wrapf(err, "failed to list workrequests for OCI Machine %s/%s", machineScope.OCIMachine.Namespace, machineScope.OCIMachine.Name)
        }</span>
        <span class="cov8" title="1">final_error := ""
        for _, wrqst := range wresp.Items </span><span class="cov8" title="1">{
                if wrqst.Status == "FAILED" </span><span class="cov8" title="1">{
                        logger.Info("Fetching work-request errors for the all failed work-requests for the instance")
                        wreq := workrequests.ListWorkRequestErrorsRequest{
                                WorkRequestId: wrqst.Id,
                        }
                        wr_errs, err := machineScope.WorkRequestsClient.ListWorkRequestErrors(ctx, wreq)
                        if err != nil </span><span class="cov0" title="0">{
                                r.Recorder.Event(machine, corev1.EventTypeWarning, "ReconcileError", errors.Wrapf(err, "Failed to normal reconcile OCIMachine").Error())
                                return reconcile.Result{}, errors.Wrapf(err, "failed to normal reconcile OCI Machine %s/%s", machineScope.OCIMachine.Namespace, machineScope.OCIMachine.Name)
                        }</span>
                        <span class="cov8" title="1">final_error = fmt.Sprintf("%s Workrequest %s failed.", final_error, *wrqst.Id)
                        for _, wr_err := range wr_errs.Items </span><span class="cov8" title="1">{
                                final_error = fmt.Sprintf("%s %s", final_error, *wr_err.Message)
                        }</span>
                }
        }
        <span class="cov8" title="1">r.Recorder.Eventf(machine, corev1.EventTypeWarning, "ReconcileError", "%s. Instance  has invalid lifecycle state %s", final_error, instance.LifecycleState)
        return reconcile.Result{}, errors.New(fmt.Sprintf("instance  has invalid lifecycle state %s", instance.LifecycleState))</span>
}

func (r *OCIMachineReconciler) reconcileNormal(ctx context.Context, logger logr.Logger, machineScope *scope.MachineScope) (ctrl.Result, error) <span class="cov8" title="1">{
        controllerutil.AddFinalizer(machineScope.OCIMachine, infrastructurev1beta2.MachineFinalizer)
        machine := machineScope.OCIMachine
        infraMachine := machineScope.Machine

        annotations := infraMachine.GetAnnotations()
        deleteMachineOnTermination := false
        if annotations != nil </span><span class="cov8" title="1">{
                _, deleteMachineOnTermination = annotations[infrastructurev1beta2.DeleteMachineOnInstanceTermination]
        }</span>
        // Make sure bootstrap data is available and populated.
        <span class="cov8" title="1">if machineScope.Machine.Spec.Bootstrap.DataSecretName == nil </span><span class="cov8" title="1">{
                r.Recorder.Event(machine, corev1.EventTypeNormal, infrastructurev1beta2.WaitingForBootstrapDataReason, "Bootstrap data secret reference is not yet available")
                conditions.MarkFalse(machine, infrastructurev1beta2.InstanceReadyCondition, infrastructurev1beta2.WaitingForBootstrapDataReason, clusterv1.ConditionSeverityInfo, "")
                logger.Info("Bootstrap data secret reference is not yet available")
                return ctrl.Result{}, nil
        }</span>

        <span class="cov8" title="1">instance, err := r.getOrCreate(ctx, machineScope)
        if err != nil </span><span class="cov0" title="0">{
                r.Recorder.Event(machine, corev1.EventTypeWarning, "ReconcileError", errors.Wrapf(err, "Failed to reconcile OCIMachine").Error())
                conditions.MarkFalse(machine, infrastructurev1beta2.InstanceReadyCondition, infrastructurev1beta2.InstanceProvisionFailedReason, clusterv1.ConditionSeverityError, "")
                return ctrl.Result{}, errors.Wrapf(err, "failed to reconcile OCI Machine %s/%s", machineScope.OCIMachine.Namespace, machineScope.OCIMachine.Name)
        }</span>

        <span class="cov8" title="1">machineScope.Info("OCI Compute Instance found", "InstanceID", *instance.Id)
        machine.Spec.InstanceId = instance.Id

        machine.Spec.ProviderID = common.String(machineScope.OCIClusterAccessor.GetProviderID(*instance.Id))

        // Proceed to reconcile the DOMachine state.
        switch instance.LifecycleState </span>{
        case core.InstanceLifecycleStateProvisioning, core.InstanceLifecycleStateStarting:<span class="cov8" title="1">
                machineScope.Info("Instance is pending")
                conditions.MarkFalse(machineScope.OCIMachine, infrastructurev1beta2.InstanceReadyCondition, infrastructurev1beta2.InstanceNotReadyReason, clusterv1.ConditionSeverityInfo, "")
                return reconcile.Result{RequeueAfter: 10 * time.Second}, nil</span>
        case core.InstanceLifecycleStateStopping, core.InstanceLifecycleStateStopped, core.InstanceLifecycleStateMoving:<span class="cov8" title="1">
                machineScope.SetNotReady()
                machineScope.Info(fmt.Sprintf("Instance is in %s state and not ready", instance.LifecycleState))
                conditions.MarkFalse(machineScope.OCIMachine, infrastructurev1beta2.InstanceReadyCondition, infrastructurev1beta2.InstanceNotReadyReason, clusterv1.ConditionSeverityInfo, "")
                return reconcile.Result{}, nil</span>
        case core.InstanceLifecycleStateRunning:<span class="cov8" title="1">
                machineScope.Info("Instance is active")
                if machine.Status.Addresses == nil || len(machine.Status.Addresses) == 0 </span><span class="cov8" title="1">{
                        machineScope.Info("IP address is not set on the instance, looking up the address")
                        ipAddress, err := machineScope.GetInstanceIp(ctx)
                        if err != nil </span><span class="cov8" title="1">{
                                r.Recorder.Event(machine, corev1.EventTypeWarning, "ReconcileError", errors.Wrapf(err, "failed to reconcile OCIMachine").Error())
                                conditions.MarkFalse(machineScope.OCIMachine, infrastructurev1beta2.InstanceReadyCondition, infrastructurev1beta2.InstanceIPAddressNotFound, clusterv1.ConditionSeverityError, "")
                                return ctrl.Result{}, err
                        }</span>
                        <span class="cov8" title="1">machine.Status.Addresses = []clusterv1.MachineAddress{
                                {
                                        Address: *ipAddress,
                                        Type:    clusterv1.MachineInternalIP,
                                },
                        }</span>
                }
                <span class="cov8" title="1">if machineScope.IsControlPlane() </span><span class="cov8" title="1">{
                        err := machineScope.ReconcileCreateInstanceOnLB(ctx)
                        if err != nil </span><span class="cov8" title="1">{
                                r.Recorder.Event(machine, corev1.EventTypeWarning, "ReconcileError", errors.Wrapf(err, "failed to reconcile OCIMachine").Error())
                                conditions.MarkFalse(machineScope.OCIMachine, infrastructurev1beta2.InstanceReadyCondition, infrastructurev1beta2.InstanceLBBackendAdditionFailedReason, clusterv1.ConditionSeverityError, "")
                                return ctrl.Result{}, err
                        }</span>
                        <span class="cov8" title="1">machineScope.Info("Instance is added to the control plane LB")</span>
                }

                <span class="cov8" title="1">if len(machine.Spec.VnicAttachments) &gt; 0 </span><span class="cov0" title="0">{
                        err := machineScope.ReconcileVnicAttachments(ctx)
                        if err != nil </span><span class="cov0" title="0">{
                                r.Recorder.Event(machine, corev1.EventTypeWarning, "ReconcileError", errors.Wrapf(err, "failed to reconcile OCIMachine").Error())
                                conditions.MarkFalse(machineScope.OCIMachine, infrastructurev1beta2.InstanceReadyCondition,
                                        infrastructurev1beta2.InstanceVnicAttachmentFailedReason, clusterv1.ConditionSeverityError, "")
                                return ctrl.Result{}, err
                        }</span>
                        <span class="cov0" title="0">machineScope.Info("Instance vnic attachment success")
                        r.Recorder.Eventf(machineScope.OCIMachine, corev1.EventTypeNormal, infrastructurev1beta2.InstanceVnicAttachmentReady,
                                "VNICs have been attached to instance.")</span>
                }

                // record the event only when machine goes from not ready to ready state
                <span class="cov8" title="1">r.Recorder.Eventf(machine, corev1.EventTypeNormal, "InstanceReady",
                        "Instance is in ready state")
                conditions.MarkTrue(machineScope.OCIMachine, infrastructurev1beta2.InstanceReadyCondition)
                machineScope.SetReady()
                if deleteMachineOnTermination </span><span class="cov8" title="1">{
                        // typically, if the VM is terminated, we should get machine events, so ideally, the 300 seconds
                        // requeue time is not required, but in case, the event is missed, adding the requeue time
                        return reconcile.Result{RequeueAfter: 300 * time.Second}, nil
                }</span> else<span class="cov8" title="1"> {
                        return reconcile.Result{}, nil
                }</span>
        case core.InstanceLifecycleStateTerminated:<span class="cov8" title="1">
                if deleteMachineOnTermination &amp;&amp; infraMachine.DeletionTimestamp == nil </span><span class="cov8" title="1">{
                        logger.Info("Deleting underlying machine as instance is terminated")
                        if err := machineScope.Client.Delete(ctx, infraMachine); err != nil </span><span class="cov0" title="0">{
                                return reconcile.Result{}, errors.Wrapf(err, "failed to delete machine %s/%s", infraMachine.Namespace, infraMachine.Name)
                        }</span>
                }
                <span class="cov8" title="1">fallthrough</span>
        default:<span class="cov8" title="1">
                machineScope.SetNotReady()
                conditions.MarkFalse(machineScope.OCIMachine, infrastructurev1beta2.InstanceReadyCondition, infrastructurev1beta2.InstanceProvisionFailedReason, clusterv1.ConditionSeverityError, "")
                machineScope.SetFailureReason(cloudutil.CreateError)
                machineScope.SetFailureMessage(errors.Errorf("Instance status %q is unexpected", instance.LifecycleState))
                return r.recordErrorsOnFailedWorkRequest(ctx, logger, machineScope, instance)</span>
        }
}

func (r *OCIMachineReconciler) getOrCreate(ctx context.Context, scope *scope.MachineScope) (*core.Instance, error) <span class="cov8" title="1">{
        instance, err := scope.GetOrCreateMachine(ctx)
        return instance, err
}</span>

func (r *OCIMachineReconciler) reconcileDelete(ctx context.Context, machineScope *scope.MachineScope) (_ ctrl.Result, reterr error) <span class="cov8" title="1">{
        machineScope.Info("Handling deleted OCIMachine")

        instance, err := machineScope.GetMachine(ctx)
        if err != nil </span><span class="cov8" title="1">{
                if ociutil.IsNotFound(err) </span><span class="cov8" title="1">{
                        err := r.deleteInstanceFromControlPlaneLB(ctx, machineScope)
                        if err != nil </span><span class="cov0" title="0">{
                                return reconcile.Result{}, err
                        }</span>
                        <span class="cov8" title="1">conditions.MarkFalse(machineScope.OCIMachine, infrastructurev1beta2.InstanceReadyCondition, infrastructurev1beta2.InstanceNotFoundReason, clusterv1.ConditionSeverityInfo, "")
                        machineScope.Info("Instance is not found, may have been deleted")
                        controllerutil.RemoveFinalizer(machineScope.OCIMachine, infrastructurev1beta2.MachineFinalizer)
                        return reconcile.Result{}, nil</span>
                } else<span class="cov0" title="0"> {
                        return reconcile.Result{}, err
                }</span>
        }
        <span class="cov8" title="1">if instance == nil </span><span class="cov0" title="0">{
                machineScope.Info("Instance is not found, may have been deleted")
                controllerutil.RemoveFinalizer(machineScope.OCIMachine, infrastructurev1beta2.MachineFinalizer)
                return reconcile.Result{}, nil
        }</span>

        <span class="cov8" title="1">machineScope.Info("OCI Compute Instance found", "InstanceID", *instance.Id)

        switch instance.LifecycleState </span>{
        case core.InstanceLifecycleStateTerminating:<span class="cov0" title="0">
                machineScope.Info("Instance is terminating")
                return reconcile.Result{RequeueAfter: 30 * time.Second}, nil</span>
        case core.InstanceLifecycleStateTerminated:<span class="cov8" title="1">
                conditions.MarkFalse(machineScope.OCIMachine, infrastructurev1beta2.InstanceReadyCondition, infrastructurev1beta2.InstanceTerminatedReason, clusterv1.ConditionSeverityInfo, "")
                controllerutil.RemoveFinalizer(machineScope.OCIMachine, infrastructurev1beta2.MachineFinalizer)
                machineScope.Info("Instance is deleted")
                r.Recorder.Eventf(machineScope.OCIMachine, corev1.EventTypeNormal,
                        "InstanceTerminated", "Deleted the instance")
                return reconcile.Result{}, nil</span>
        default:<span class="cov8" title="1">
                if !machineScope.IsResourceCreatedByClusterAPI(instance.FreeformTags) </span><span class="cov0" title="0">{
                        return reconcile.Result{}, errors.New("instance is not created by current cluster")
                }</span>
                <span class="cov8" title="1">err := r.deleteInstanceFromControlPlaneLB(ctx, machineScope)
                if err != nil </span><span class="cov0" title="0">{
                        return reconcile.Result{}, err
                }</span>
                <span class="cov8" title="1">if err := machineScope.DeleteMachine(ctx, instance); err != nil </span><span class="cov0" title="0">{
                        machineScope.Error(err, "Error deleting Instance")
                        return ctrl.Result{}, errors.Wrapf(err, "error deleting instance %s", machineScope.Name())
                }</span>
                <span class="cov8" title="1">conditions.MarkFalse(machineScope.OCIMachine, infrastructurev1beta2.InstanceReadyCondition, infrastructurev1beta2.InstanceTerminatingReason, clusterv1.ConditionSeverityInfo, "")
                r.Recorder.Eventf(machineScope.OCIMachine, corev1.EventTypeNormal,
                        "InstanceTerminating", "Terminating the instance")
                return reconcile.Result{RequeueAfter: 30 * time.Second}, nil</span>
        }
}

func (r *OCIMachineReconciler) deleteInstanceFromControlPlaneLB(ctx context.Context, machineScope *scope.MachineScope) error <span class="cov8" title="1">{
        if machineScope.IsControlPlane() </span><span class="cov8" title="1">{
                err := machineScope.ReconcileDeleteInstanceOnLB(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">machineScope.Info("Instance is removed from the control plane LB")
                r.Recorder.Eventf(machineScope.OCIMachine, corev1.EventTypeNormal, "OCIMachineRemovedFromLB",
                        "Instance has been removed from the control plane LB")</span>
        }
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file77" style="display: none">/*
Copyright (c) 2021, 2022 Oracle and/or its affiliates.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package controllers

import (
        "context"
        "fmt"
        "strings"

        "github.com/go-logr/logr"
        infrastructurev1beta2 "github.com/oracle/cluster-api-provider-oci/api/v1beta2"
        "github.com/oracle/cluster-api-provider-oci/cloud/scope"
        cloudutil "github.com/oracle/cluster-api-provider-oci/cloud/util"
        "github.com/pkg/errors"
        corev1 "k8s.io/api/core/v1"
        apierrors "k8s.io/apimachinery/pkg/api/errors"
        "k8s.io/apimachinery/pkg/runtime"
        "k8s.io/apimachinery/pkg/types"
        "k8s.io/client-go/tools/record"
        clusterv1 "sigs.k8s.io/cluster-api/api/core/v1beta1"
        "sigs.k8s.io/cluster-api/util"
        "sigs.k8s.io/cluster-api/util/annotations"
        "sigs.k8s.io/cluster-api/util/deprecated/v1beta1/conditions"
        "sigs.k8s.io/cluster-api/util/patch"
        "sigs.k8s.io/cluster-api/util/predicates"
        ctrl "sigs.k8s.io/controller-runtime"
        "sigs.k8s.io/controller-runtime/pkg/builder"
        "sigs.k8s.io/controller-runtime/pkg/client"
        "sigs.k8s.io/controller-runtime/pkg/controller"
        "sigs.k8s.io/controller-runtime/pkg/controller/controllerutil"
        "sigs.k8s.io/controller-runtime/pkg/handler"
        "sigs.k8s.io/controller-runtime/pkg/log"
        "sigs.k8s.io/controller-runtime/pkg/reconcile"
)

// OCIManagedClusterReconciler reconciles a OciCluster object
type OCIManagedClusterReconciler struct {
        client.Client
        Scheme         *runtime.Scheme
        Recorder       record.EventRecorder
        Region         string
        ClientProvider *scope.ClientProvider
}

//+kubebuilder:rbac:groups=infrastructure.cluster.x-k8s.io,resources=ocimanagedclusters,verbs=get;list;watch;create;update;patch;delete
//+kubebuilder:rbac:groups=infrastructure.cluster.x-k8s.io,resources=ocimanagedclusters/status,verbs=get;update;patch
//+kubebuilder:rbac:groups=infrastructure.cluster.x-k8s.io,resources=ocimanagedclusters/finalizers,verbs=update

// Reconcile is part of the main kubernetes reconciliation loop which aims to
// move the current state of the machine closer to the desired state.
//
// For more details, check Reconcile and its Result here:
// - https://pkg.go.dev/sigs.k8s.io/controller-runtime@v0.8.3/pkg/reconcile
func (r *OCIManagedClusterReconciler) Reconcile(ctx context.Context, req ctrl.Request) (result ctrl.Result, reterr error) <span class="cov8" title="1">{
        logger := log.FromContext(ctx)
        logger = logger.WithValues(scope.OCIManagedClusterKind, req.NamespacedName)

        logger.Info("Inside cluster reconciler")

        // Fetch the OCIManagedCluster instance
        ociCluster := &amp;infrastructurev1beta2.OCIManagedCluster{}
        err := r.Get(ctx, req.NamespacedName, ociCluster)
        if err != nil </span><span class="cov8" title="1">{
                if apierrors.IsNotFound(err) </span><span class="cov8" title="1">{
                        return ctrl.Result{}, nil
                }</span>
                <span class="cov0" title="0">return ctrl.Result{}, err</span>
        }

        // Fetch the Cluster.
        <span class="cov8" title="1">cluster, err := util.GetOwnerCluster(ctx, r.Client, ociCluster.ObjectMeta)
        if err != nil </span><span class="cov0" title="0">{
                return ctrl.Result{}, err
        }</span>
        <span class="cov8" title="1">if cluster == nil </span><span class="cov8" title="1">{
                r.Recorder.Eventf(ociCluster, corev1.EventTypeNormal, "OwnerRefNotSet", "Cluster Controller has not yet set OwnerRef")
                logger.Info("Cluster Controller has not yet set OwnerRef")
                return ctrl.Result{}, nil
        }</span>

        // Return early if the object or Cluster is paused.
        <span class="cov8" title="1">if annotations.IsPaused(cluster, ociCluster) </span><span class="cov8" title="1">{
                r.Recorder.Eventf(ociCluster, corev1.EventTypeNormal, "ClusterPaused", "Cluster is paused")
                logger.Info("OCIManagedCluster or linked Cluster is marked as paused. Won't reconcile")
                return ctrl.Result{}, nil
        }</span>

        // Return early if the object or Cluster is paused.
        <span class="cov0" title="0">if annotations.IsPaused(cluster, ociCluster) </span><span class="cov0" title="0">{
                logger.Info("OCIManagedCluster or linked Cluster is marked as paused. Won't reconcile")
                return ctrl.Result{}, nil
        }</span>
        // Convert v1beta2 Cluster to v1beta1 for scope compatibility
        <span class="cov0" title="0">clusterV1beta1, err := cloudutil.ConvertClusterV1Beta2ToV1Beta1(cluster)
        if err != nil </span><span class="cov0" title="0">{
                return ctrl.Result{}, errors.Wrap(err, "failed to convert cluster to v1beta1")
        }</span>

        <span class="cov0" title="0">clusterAccessor := scope.OCIManagedCluster{
                OCIManagedCluster: ociCluster,
        }
        clientProvider, clusterRegion, clients, err := cloudutil.InitClientsAndRegion(ctx, r.Client, r.Region, clusterAccessor, r.ClientProvider)
        if err != nil </span><span class="cov0" title="0">{
                return ctrl.Result{}, err
        }</span>

        <span class="cov0" title="0">helper, err := patch.NewHelper(ociCluster, r.Client)
        if err != nil </span><span class="cov0" title="0">{
                return ctrl.Result{}, errors.Wrap(err, "failed to init patch helper")
        }</span>

        <span class="cov0" title="0">clusterScope, err := scope.NewClusterScope(scope.ClusterScopeParams{
                Client:             r.Client,
                Logger:             &amp;logger,
                Cluster:            clusterV1beta1,
                OCIClusterAccessor: clusterAccessor,
                ClientProvider:     clientProvider,
                VCNClient:          clients.VCNClient,
                LoadBalancerClient: clients.LoadBalancerClient,
                IdentityClient:     clients.IdentityClient,
                RegionIdentifier:   clusterRegion,
        })
        if err != nil </span><span class="cov0" title="0">{
                logger.Error(err, "Couldn't create cluster scope")
                return ctrl.Result{}, err
        }</span>
        <span class="cov0" title="0">err = clusterScope.SetRegionKey(ctx)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error(err, "Couldn't get region code")
                return ctrl.Result{}, err
        }</span>

        // Always close the scope when exiting this function so we can persist any OCIManagedCluster changes.
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                logger.Info("Closing managed cluster scope")
                conditions.SetSummary(ociCluster)

                if err := helper.Patch(ctx, ociCluster); err != nil &amp;&amp; reterr == nil </span><span class="cov0" title="0">{
                        reterr = err
                }</span>
        }()

        // Handle deleted clusters
        <span class="cov0" title="0">if !ociCluster.DeletionTimestamp.IsZero() </span><span class="cov0" title="0">{
                return r.reconcileDelete(ctx, logger, clusterScope, ociCluster)
        }</span>

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return reconcile.Result{}, errors.Errorf("failed to create scope: %+v", err)
        }</span> else<span class="cov0" title="0"> {
                return r.reconcile(ctx, logger, clusterScope, ociCluster, clusterV1beta1)
        }</span>

}

func (r *OCIManagedClusterReconciler) reconcileComponent(ctx context.Context, cluster *infrastructurev1beta2.OCIManagedCluster,
        reconciler func(context.Context) error,
        componentName string, failReason string, readyEventtype string) error <span class="cov8" title="1">{

        err := reconciler(ctx)
        if err != nil </span><span class="cov8" title="1">{
                r.Recorder.Event(cluster, corev1.EventTypeWarning, "ReconcileError", errors.Wrapf(err, "%s",
                        fmt.Sprintf("failed to reconcile %s", componentName)).Error())
                conditions.MarkFalse(cluster, infrastructurev1beta2.ClusterReadyCondition, failReason, clusterv1.ConditionSeverityError, "")
                return errors.Wrapf(err, "failed to reconcile %s for OCIManagedCluster %s/%s", componentName, cluster.Namespace,
                        cluster.Name)
        }</span>

        <span class="cov8" title="1">trimmedComponentName := strings.ReplaceAll(componentName, " ", "")
        r.Recorder.Eventf(cluster, corev1.EventTypeNormal, readyEventtype,
                fmt.Sprintf("%s is in ready state", trimmedComponentName))

        return nil</span>
}

func (r *OCIManagedClusterReconciler) reconcile(ctx context.Context, logger logr.Logger, clusterScope scope.ClusterScopeClient, ociManagedCluster *infrastructurev1beta2.OCIManagedCluster, cluster *clusterv1.Cluster) (ctrl.Result, error) <span class="cov8" title="1">{
        // If the OCIManagedCluster doesn't have our finalizer, add it.
        controllerutil.AddFinalizer(ociManagedCluster, infrastructurev1beta2.ManagedClusterFinalizer)

        controlPlane := &amp;infrastructurev1beta2.OCIManagedControlPlane{}
        controlPlaneRef := types.NamespacedName{
                Name:      cluster.Spec.ControlPlaneRef.Name,
                Namespace: cluster.Namespace,
        }

        if err := r.Get(ctx, controlPlaneRef, controlPlane); err != nil </span><span class="cov0" title="0">{
                logger.Info("Failed to get control plane ref")
                return reconcile.Result{}, errors.Wrap(err, "failed to get control plane ref")
        }</span>

        // This below if condition specifies if the network related infrastructure needs to be reconciled. Any new
        // network related reconcilication should happen in this if condition
        <span class="cov8" title="1">if !ociManagedCluster.Spec.NetworkSpec.SkipNetworkManagement </span><span class="cov8" title="1">{
                err := clusterScope.SetRegionKey(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error(err, "Couldn't get region code")
                        return ctrl.Result{}, err
                }</span>

                <span class="cov8" title="1">if err := r.reconcileComponent(ctx, ociManagedCluster, clusterScope.ReconcileDRG, "DRG",
                        infrastructurev1beta2.DrgReconciliationFailedReason, infrastructurev1beta2.DrgEventReady); err != nil </span><span class="cov8" title="1">{
                        return ctrl.Result{}, err
                }</span>

                <span class="cov8" title="1">if err := r.reconcileComponent(ctx, ociManagedCluster, clusterScope.ReconcileVCN, "VCN",
                        infrastructurev1beta2.VcnReconciliationFailedReason, infrastructurev1beta2.VcnEventReady); err != nil </span><span class="cov8" title="1">{
                        return ctrl.Result{}, err
                }</span>

                <span class="cov8" title="1">if err := r.reconcileComponent(ctx, ociManagedCluster, clusterScope.ReconcileInternetGateway, "Internet Gateway",
                        infrastructurev1beta2.InternetGatewayReconciliationFailedReason, infrastructurev1beta2.InternetGatewayEventReady); err != nil </span><span class="cov8" title="1">{
                        return ctrl.Result{}, err
                }</span>

                <span class="cov8" title="1">if err := r.reconcileComponent(ctx, ociManagedCluster, clusterScope.ReconcileNatGateway, "NAT Gateway",
                        infrastructurev1beta2.NatGatewayReconciliationFailedReason, infrastructurev1beta2.NatEventReady); err != nil </span><span class="cov8" title="1">{
                        return ctrl.Result{}, err
                }</span>

                <span class="cov8" title="1">if err := r.reconcileComponent(ctx, ociManagedCluster, clusterScope.ReconcileServiceGateway, "Service Gateway",
                        infrastructurev1beta2.ServiceGatewayReconciliationFailedReason, infrastructurev1beta2.ServiceGatewayEventReady); err != nil </span><span class="cov8" title="1">{
                        return ctrl.Result{}, err
                }</span>

                <span class="cov8" title="1">if err := r.reconcileComponent(ctx, ociManagedCluster, clusterScope.ReconcileNSG, "Network Security Group",
                        infrastructurev1beta2.NSGReconciliationFailedReason, infrastructurev1beta2.NetworkSecurityEventReady); err != nil </span><span class="cov8" title="1">{
                        return ctrl.Result{}, err
                }</span>

                <span class="cov8" title="1">if err := r.reconcileComponent(ctx, ociManagedCluster, clusterScope.ReconcileRouteTable, "Route Table",
                        infrastructurev1beta2.RouteTableReconciliationFailedReason, infrastructurev1beta2.RouteTableEventReady); err != nil </span><span class="cov8" title="1">{
                        return ctrl.Result{}, err
                }</span>

                <span class="cov8" title="1">if err := r.reconcileComponent(ctx, ociManagedCluster, clusterScope.ReconcileSubnet, "Subnet",
                        infrastructurev1beta2.SubnetReconciliationFailedReason, infrastructurev1beta2.SubnetEventReady); err != nil </span><span class="cov8" title="1">{
                        return ctrl.Result{}, err
                }</span>

                <span class="cov8" title="1">if err := r.reconcileComponent(ctx, ociManagedCluster, clusterScope.ReconcileDRGVCNAttachment, "DRGVCNAttachment",
                        infrastructurev1beta2.DRGVCNAttachmentReconciliationFailedReason, infrastructurev1beta2.DRGVCNAttachmentEventReady); err != nil </span><span class="cov8" title="1">{
                        return ctrl.Result{}, err
                }</span>

                <span class="cov8" title="1">if err := r.reconcileComponent(ctx, ociManagedCluster, clusterScope.ReconcileDRGRPCAttachment, "DRGRPCAttachment",
                        infrastructurev1beta2.DRGRPCAttachmentReconciliationFailedReason, infrastructurev1beta2.DRGRPCAttachmentEventReady); err != nil </span><span class="cov8" title="1">{
                        return ctrl.Result{}, err
                }</span>
        } else<span class="cov0" title="0"> {
                logger.Info("VCN Reconciliation is skipped")
        }</span>

        <span class="cov8" title="1">if err := r.reconcileComponent(ctx, ociManagedCluster, clusterScope.ReconcileFailureDomains, "Failure Domain",
                infrastructurev1beta2.FailureDomainFailedReason, infrastructurev1beta2.FailureDomainEventReady); err != nil </span><span class="cov8" title="1">{
                return ctrl.Result{}, err
        }</span>

        <span class="cov8" title="1">conditions.MarkTrue(ociManagedCluster, infrastructurev1beta2.ClusterReadyCondition)
        ociManagedCluster.Status.Ready = true
        if controlPlane.Status.Ready </span><span class="cov0" title="0">{
                ociManagedCluster.Spec.ControlPlaneEndpoint = controlPlane.Spec.ControlPlaneEndpoint
        }</span>
        <span class="cov8" title="1">return ctrl.Result{}, nil</span>
}

// SetupWithManager sets up the controller with the Manager.
func (r *OCIManagedClusterReconciler) SetupWithManager(ctx context.Context, mgr ctrl.Manager, options controller.Options) error <span class="cov0" title="0">{
        log := ctrl.LoggerFrom(ctx)
        ociManagedControlPlaneMapper, err := OCIManagedControlPlaneToOCIManagedClusterMapper(r.Client, log)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">err = ctrl.NewControllerManagedBy(mgr).
                WithOptions(options).
                For(&amp;infrastructurev1beta2.OCIManagedCluster{}).
                WithEventFilter(predicates.ResourceNotPaused(mgr.GetScheme(), log)). // don't queue reconcile if resource is paused
                // watch OCIManagedControlPlane resources
                Watches(
                        &amp;infrastructurev1beta2.OCIManagedControlPlane{},
                        handler.EnqueueRequestsFromMapFunc(ociManagedControlPlaneMapper),
                ).
                Watches(
                        &amp;clusterv1.Cluster{},
                        handler.EnqueueRequestsFromMapFunc(r.clusterToInfrastructureMapFunc(log)),
                        builder.WithPredicates(
                                predicates.ClusterUnpaused(mgr.GetScheme(), log),
                                predicates.ResourceNotPausedAndHasFilterLabel(mgr.GetScheme(), log, ""),
                        ),
                ).
                Complete(r)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrapf(err, "error creating controller")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// ClusterToInfrastructureMapFunc returns a handler.ToRequestsFunc that watches for
// Cluster events and returns reconciliation requests for an infrastructure provider object.
func (r *OCIManagedClusterReconciler) clusterToInfrastructureMapFunc(log logr.Logger) handler.MapFunc <span class="cov0" title="0">{
        return func(ctx context.Context, o client.Object) []reconcile.Request </span><span class="cov0" title="0">{
                c, ok := o.(*clusterv1.Cluster)
                if !ok </span><span class="cov0" title="0">{
                        return nil
                }</span>

                // Make sure the ref is set
                <span class="cov0" title="0">if c.Spec.InfrastructureRef == nil </span><span class="cov0" title="0">{
                        log.V(4).Info("Cluster does not have an InfrastructureRef, skipping mapping.")
                        return nil
                }</span>

                <span class="cov0" title="0">if c.Spec.InfrastructureRef.GroupVersionKind().Kind != "OCIManagedCluster" </span><span class="cov0" title="0">{
                        log.V(4).Info("Cluster has an InfrastructureRef for a different type, skipping mapping.")
                        return nil
                }</span>

                <span class="cov0" title="0">ociCluster := &amp;infrastructurev1beta2.OCIManagedCluster{}
                key := types.NamespacedName{Namespace: c.Spec.InfrastructureRef.Namespace, Name: c.Spec.InfrastructureRef.Name}

                if err := r.Get(ctx, key, ociCluster); err != nil </span><span class="cov0" title="0">{
                        log.V(4).Error(err, "Failed to get OCI cluster")
                        return nil
                }</span>

                <span class="cov0" title="0">if annotations.IsExternallyManaged(ociCluster) </span><span class="cov0" title="0">{
                        log.V(4).Info("OCIManagedCluster is externally managed, skipping mapping.")
                        return nil
                }</span>

                <span class="cov0" title="0">log.V(4).Info("Adding request.", "ociCluster", c.Spec.InfrastructureRef.Name)

                return []reconcile.Request{
                        {
                                NamespacedName: client.ObjectKey{
                                        Namespace: c.Namespace,
                                        Name:      c.Spec.InfrastructureRef.Name,
                                },
                        },
                }</span>
        }
}

func (r *OCIManagedClusterReconciler) reconcileDelete(ctx context.Context, logger logr.Logger, clusterScope scope.ClusterScopeClient, cluster *infrastructurev1beta2.OCIManagedCluster) (ctrl.Result, error) <span class="cov8" title="1">{
        // This below if condition specifies if the network related infrastructure needs to be reconciled. Any new
        // network related reconcilication should happen in this if condition
        if !cluster.Spec.NetworkSpec.SkipNetworkManagement </span><span class="cov8" title="1">{
                err := clusterScope.DeleteDRGRPCAttachment(ctx)
                if err != nil </span><span class="cov8" title="1">{
                        r.Recorder.Event(cluster, corev1.EventTypeWarning, "ReconcileError", errors.Wrapf(err, "failed to delete DRG RPC attachment").Error())
                        conditions.MarkFalse(cluster, infrastructurev1beta2.ClusterReadyCondition, infrastructurev1beta2.DRGRPCAttachmentReconciliationFailedReason, clusterv1.ConditionSeverityError, "")
                        return ctrl.Result{}, errors.Wrapf(err, "failed to delete DRG RPC Attachment  for OCIManagedCluster %s/%s", cluster.Namespace, cluster.Name)
                }</span>

                <span class="cov8" title="1">err = clusterScope.DeleteDRGVCNAttachment(ctx)
                if err != nil </span><span class="cov8" title="1">{
                        r.Recorder.Event(cluster, corev1.EventTypeWarning, "ReconcileError", errors.Wrapf(err, "failed to delete DRG VCN attachment").Error())
                        conditions.MarkFalse(cluster, infrastructurev1beta2.ClusterReadyCondition, infrastructurev1beta2.DRGVCNAttachmentReconciliationFailedReason, clusterv1.ConditionSeverityError, "")
                        return ctrl.Result{}, errors.Wrapf(err, "failed to delete DRG VCN Attachment  for OCIManagedCluster %s/%s", cluster.Namespace, cluster.Name)
                }</span>

                <span class="cov8" title="1">err = clusterScope.DeleteNSGs(ctx)
                if err != nil </span><span class="cov8" title="1">{
                        r.Recorder.Event(cluster, corev1.EventTypeWarning, "ReconcileError", errors.Wrapf(err, "failed to delete Network Security Group").Error())
                        conditions.MarkFalse(cluster, infrastructurev1beta2.ClusterReadyCondition, infrastructurev1beta2.NSGReconciliationFailedReason, clusterv1.ConditionSeverityError, "")
                        return ctrl.Result{}, errors.Wrapf(err, "failed to delete Network Security Groups for OCIManagedCluster %s/%s", cluster.Namespace, cluster.Name)
                }</span>

                <span class="cov8" title="1">err = clusterScope.DeleteSubnets(ctx)
                if err != nil </span><span class="cov8" title="1">{
                        r.Recorder.Event(cluster, corev1.EventTypeWarning, "ReconcileError", errors.Wrapf(err, "failed to delete Subnet").Error())
                        conditions.MarkFalse(cluster, infrastructurev1beta2.ClusterReadyCondition, infrastructurev1beta2.SubnetReconciliationFailedReason, clusterv1.ConditionSeverityError, "")
                        return ctrl.Result{}, errors.Wrapf(err, "failed to delete subnet for OCIManagedCluster %s/%s", cluster.Namespace, cluster.Name)
                }</span>

                <span class="cov8" title="1">err = clusterScope.DeleteRouteTables(ctx)
                if err != nil </span><span class="cov8" title="1">{
                        r.Recorder.Event(cluster, corev1.EventTypeWarning, "ReconcileError", errors.Wrapf(err, "failed to delete Route Table").Error())
                        conditions.MarkFalse(cluster, infrastructurev1beta2.ClusterReadyCondition, infrastructurev1beta2.RouteTableReconciliationFailedReason, clusterv1.ConditionSeverityError, "")
                        return ctrl.Result{}, errors.Wrapf(err, "failed to delete RouteTables for OCIManagedCluster %s/%s", cluster.Namespace, cluster.Name)
                }</span>

                <span class="cov8" title="1">err = clusterScope.DeleteSecurityLists(ctx)
                if err != nil </span><span class="cov8" title="1">{
                        r.Recorder.Event(cluster, corev1.EventTypeWarning, "ReconcileError", errors.Wrapf(err, "failed to delete Security Lists").Error())
                        conditions.MarkFalse(cluster, infrastructurev1beta2.ClusterReadyCondition, infrastructurev1beta2.SecurityListReconciliationFailedReason, clusterv1.ConditionSeverityError, "")
                        return ctrl.Result{}, errors.Wrapf(err, "failed to delete SecurityLists for OCIManagedCluster %s/%s", cluster.Namespace, cluster.Name)
                }</span>

                <span class="cov8" title="1">err = clusterScope.DeleteServiceGateway(ctx)
                if err != nil </span><span class="cov8" title="1">{
                        r.Recorder.Event(cluster, corev1.EventTypeWarning, "ReconcileError", errors.Wrapf(err, "failed to delete Service Gateway").Error())
                        conditions.MarkFalse(cluster, infrastructurev1beta2.ClusterReadyCondition, infrastructurev1beta2.ServiceGatewayReconciliationFailedReason, clusterv1.ConditionSeverityError, "")
                        return ctrl.Result{}, errors.Wrapf(err, "failed to delete ServiceGateway for OCIManagedCluster %s/%s", cluster.Namespace, cluster.Name)
                }</span>

                <span class="cov8" title="1">err = clusterScope.DeleteNatGateway(ctx)
                if err != nil </span><span class="cov8" title="1">{
                        r.Recorder.Event(cluster, corev1.EventTypeWarning, "ReconcileError", errors.Wrapf(err, "failed to delete NAT Gateway").Error())
                        conditions.MarkFalse(cluster, infrastructurev1beta2.ClusterReadyCondition, infrastructurev1beta2.NatGatewayReconciliationFailedReason, clusterv1.ConditionSeverityError, "")
                        return ctrl.Result{}, errors.Wrapf(err, "failed to delete NatGateway for OCIManagedCluster %s/%s", cluster.Namespace, cluster.Name)
                }</span>

                <span class="cov8" title="1">err = clusterScope.DeleteInternetGateway(ctx)
                if err != nil </span><span class="cov8" title="1">{
                        r.Recorder.Event(cluster, corev1.EventTypeWarning, "ReconcileError", errors.Wrapf(err, "failed to delete Internet Gateway").Error())
                        conditions.MarkFalse(cluster, infrastructurev1beta2.ClusterReadyCondition, infrastructurev1beta2.InternetGatewayReconciliationFailedReason, clusterv1.ConditionSeverityError, "")
                        return ctrl.Result{}, errors.Wrapf(err, "failed to delete InternetGateway for OCIManagedCluster %s/%s", cluster.Namespace, cluster.Name)
                }</span>

                <span class="cov8" title="1">err = clusterScope.DeleteVCN(ctx)
                if err != nil </span><span class="cov8" title="1">{
                        r.Recorder.Event(cluster, corev1.EventTypeWarning, "ReconcileError", errors.Wrapf(err, "failed to delete VCN").Error())
                        conditions.MarkFalse(cluster, infrastructurev1beta2.ClusterReadyCondition, infrastructurev1beta2.VcnReconciliationFailedReason, clusterv1.ConditionSeverityError, "")
                        return ctrl.Result{}, errors.Wrapf(err, "failed to delete VCN for OCIManagedCluster %s/%s", cluster.Namespace, cluster.Name)
                }</span>

                <span class="cov8" title="1">err = clusterScope.DeleteDRG(ctx)
                if err != nil </span><span class="cov8" title="1">{
                        r.Recorder.Event(cluster, corev1.EventTypeWarning, "ReconcileError", errors.Wrapf(err, "failed to delete DRG").Error())
                        conditions.MarkFalse(cluster, infrastructurev1beta2.ClusterReadyCondition, infrastructurev1beta2.DrgReconciliationFailedReason, clusterv1.ConditionSeverityError, "")
                        return ctrl.Result{}, errors.Wrapf(err, "failed to delete DRG for OCIManagedCluster %s/%s", cluster.Namespace, cluster.Name)
                }</span>

        } else<span class="cov0" title="0"> {
                logger.Info("VCN Reconciliation is skipped, none of the VCN related resources will be deleted")
        }</span>
        <span class="cov8" title="1">controllerutil.RemoveFinalizer(cluster, infrastructurev1beta2.ManagedClusterFinalizer)

        return reconcile.Result{}, nil</span>
}

func OCIManagedControlPlaneToOCIManagedClusterMapper(c client.Client, log logr.Logger) (handler.MapFunc, error) <span class="cov0" title="0">{
        return func(ctx context.Context, o client.Object) []ctrl.Request </span><span class="cov0" title="0">{
                ociManagedControlPlane, ok := o.(*infrastructurev1beta2.OCIManagedControlPlane)
                if !ok </span><span class="cov0" title="0">{
                        log.Error(errors.Errorf("expected an OCIManagedControlPlane, got %T instead", o), "failed to map OCIManagedControlPlane")
                        return nil
                }</span>

                <span class="cov0" title="0">log = log.WithValues("OCIManagedControlPlane", ociManagedControlPlane.Name, "Namespace", ociManagedControlPlane.Namespace)

                // Don't handle deleted OCIManagedControlPlanes
                if !ociManagedControlPlane.ObjectMeta.DeletionTimestamp.IsZero() </span><span class="cov0" title="0">{
                        log.V(4).Info("OCIManagedControlPlane has a deletion timestamp, skipping mapping.")
                        return nil
                }</span>

                <span class="cov0" title="0">cluster, err := util.GetOwnerCluster(ctx, c, ociManagedControlPlane.ObjectMeta)
                if err != nil </span><span class="cov0" title="0">{
                        log.Error(err, "failed to get the owning cluster")
                        return nil
                }</span>

                <span class="cov0" title="0">if cluster == nil </span><span class="cov0" title="0">{
                        log.Error(err, "cluster has not set owner ref yet")
                        return nil
                }</span>

                <span class="cov0" title="0">ref := cluster.Spec.InfrastructureRef
                if ref.Name == "" </span><span class="cov0" title="0">{
                        return nil
                }</span>

                <span class="cov0" title="0">return []ctrl.Request{
                        {
                                NamespacedName: types.NamespacedName{
                                        Namespace: cluster.Namespace,
                                        Name:      ref.Name,
                                },
                        },
                }</span>
        }, nil
}
</pre>
		
		<pre class="file" id="file78" style="display: none">/*
Copyright (c) 2021, 2022 Oracle and/or its affiliates.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package controllers

import (
        "context"
        "fmt"
        "time"

        "github.com/go-logr/logr"
        infrastructurev1beta2 "github.com/oracle/cluster-api-provider-oci/api/v1beta2"
        "github.com/oracle/cluster-api-provider-oci/cloud/ociutil"
        "github.com/oracle/cluster-api-provider-oci/cloud/scope"
        cloudutil "github.com/oracle/cluster-api-provider-oci/cloud/util"
        "github.com/oracle/oci-go-sdk/v65/containerengine"
        "github.com/pkg/errors"
        corev1 "k8s.io/api/core/v1"
        apierrors "k8s.io/apimachinery/pkg/api/errors"
        "k8s.io/apimachinery/pkg/runtime"
        "k8s.io/apimachinery/pkg/types"
        "k8s.io/client-go/tools/record"
        clusterv1 "sigs.k8s.io/cluster-api/api/core/v1beta1"
        "sigs.k8s.io/cluster-api/util"
        "sigs.k8s.io/cluster-api/util/annotations"
        "sigs.k8s.io/cluster-api/util/deprecated/v1beta1/conditions"
        "sigs.k8s.io/cluster-api/util/patch"
        "sigs.k8s.io/cluster-api/util/predicates"
        ctrl "sigs.k8s.io/controller-runtime"
        "sigs.k8s.io/controller-runtime/pkg/builder"
        "sigs.k8s.io/controller-runtime/pkg/client"
        "sigs.k8s.io/controller-runtime/pkg/controller"
        "sigs.k8s.io/controller-runtime/pkg/controller/controllerutil"
        "sigs.k8s.io/controller-runtime/pkg/handler"
        "sigs.k8s.io/controller-runtime/pkg/log"
        "sigs.k8s.io/controller-runtime/pkg/reconcile"
)

// OCIManagedClusterControlPlaneReconciler reconciles a OCIManagedControlPlane object
type OCIManagedClusterControlPlaneReconciler struct {
        client.Client
        Scheme         *runtime.Scheme
        Recorder       record.EventRecorder
        Region         string
        ClientProvider *scope.ClientProvider
}

//+kubebuilder:rbac:groups=infrastructure.cluster.x-k8s.io,resources=ocimanagedcontrolplanes,verbs=get;list;watch;create;update;patch;delete
//+kubebuilder:rbac:groups=infrastructure.cluster.x-k8s.io,resources=ocimanagedcontrolplanes/status,verbs=get;update;patch
//+kubebuilder:rbac:groups=infrastructure.cluster.x-k8s.io,resources=ocimanagedcontrolplanes/finalizers,verbs=update

// Reconcile is part of the main kubernetes reconciliation loop which aims to
// move the current state of the machine closer to the desired state.
//
// For more details, check Reconcile and its Result here:
// - https://pkg.go.dev/sigs.k8s.io/controller-runtime@v0.8.3/pkg/reconcile
func (r *OCIManagedClusterControlPlaneReconciler) Reconcile(ctx context.Context, req ctrl.Request) (result ctrl.Result, reterr error) <span class="cov8" title="1">{
        logger := log.FromContext(ctx)
        logger = logger.WithValues(scope.OCIManagedClusterKind, req.NamespacedName)

        logger.Info("Inside managed control plane reconciler")

        // Fetch the OCI managed control plane
        controlPlane := &amp;infrastructurev1beta2.OCIManagedControlPlane{}
        err := r.Get(ctx, req.NamespacedName, controlPlane)
        if err != nil </span><span class="cov8" title="1">{
                if apierrors.IsNotFound(err) </span><span class="cov8" title="1">{
                        return ctrl.Result{}, nil
                }</span>
                <span class="cov0" title="0">return ctrl.Result{}, err</span>
        }
        // Fetch the Cluster.
        <span class="cov8" title="1">cluster, err := util.GetOwnerCluster(ctx, r.Client, controlPlane.ObjectMeta)
        if err != nil </span><span class="cov8" title="1">{
                return ctrl.Result{}, err
        }</span>
        <span class="cov8" title="1">if cluster == nil </span><span class="cov8" title="1">{
                r.Recorder.Eventf(controlPlane, corev1.EventTypeNormal, "OwnerRefNotSet", "Cluster Controller has not yet set OwnerRef")
                logger.Info("Cluster Controller has not yet set OwnerRef")
                return ctrl.Result{}, nil
        }</span>

        // Return early if the object or Cluster is paused.
        <span class="cov8" title="1">if annotations.IsPaused(cluster, controlPlane) </span><span class="cov8" title="1">{
                r.Recorder.Eventf(controlPlane, corev1.EventTypeNormal, "ClusterPaused", "Cluster is paused")
                logger.Info("OCIManagedCluster or linked Cluster is marked as paused. Won't reconcile")
                return ctrl.Result{}, nil
        }</span>
        // Convert v1beta2 Cluster to v1beta1 for scope compatibility
        <span class="cov8" title="1">clusterV1beta1, err := cloudutil.ConvertClusterV1Beta2ToV1Beta1(cluster)
        if err != nil </span><span class="cov0" title="0">{
                return ctrl.Result{}, errors.Wrap(err, "failed to convert cluster to v1beta1")
        }</span>

        <span class="cov8" title="1">ociManagedCluster := &amp;infrastructurev1beta2.OCIManagedCluster{}
        ociClusterName := client.ObjectKey{
                Namespace: clusterV1beta1.Namespace,
                Name:      clusterV1beta1.Spec.InfrastructureRef.Name,
        }

        if err := r.Client.Get(ctx, ociClusterName, ociManagedCluster); err != nil </span><span class="cov8" title="1">{
                logger.Info("Cluster is not available yet")
                r.Recorder.Eventf(controlPlane, corev1.EventTypeWarning, "ClusterNotAvailable", "Cluster is not available yet")
                return ctrl.Result{}, nil
        }</span>

        <span class="cov8" title="1">if !ociManagedCluster.Status.Ready </span><span class="cov8" title="1">{
                logger.Info("Cluster infrastructure is not ready")
                r.Recorder.Eventf(controlPlane, corev1.EventTypeWarning, "ClusterInfrastructureNotReady", "Cluster infrastructure is not ready")
                return ctrl.Result{}, nil
        }</span>

        // Return early if the object or Cluster is paused.
        <span class="cov0" title="0">if annotations.IsPaused(cluster, ociManagedCluster) </span><span class="cov0" title="0">{
                r.Recorder.Eventf(controlPlane, corev1.EventTypeNormal, "ClusterPaused", "Cluster is paused")
                logger.Info("OCIManagedCluster or linked Cluster is marked as paused. Won't reconcile")
                return ctrl.Result{}, nil
        }</span>

        <span class="cov0" title="0">clusterAccessor := scope.OCIManagedCluster{
                OCIManagedCluster: ociManagedCluster,
        }
        clientProvider, clusterRegion, clients, err := cloudutil.InitClientsAndRegion(ctx, r.Client, r.Region, clusterAccessor, r.ClientProvider)
        if err != nil </span><span class="cov0" title="0">{
                return ctrl.Result{}, err
        }</span>

        <span class="cov0" title="0">helper, err := patch.NewHelper(controlPlane, r.Client)
        if err != nil </span><span class="cov0" title="0">{
                return ctrl.Result{}, errors.Wrap(err, "failed to init patch helper")
        }</span>

        // Always close the scope when exiting this function so we can persist any OCIManagedCluster changes.
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                logger.Info("Closing control plane scope")
                conditions.SetSummary(controlPlane)

                if err := helper.Patch(ctx, controlPlane); err != nil &amp;&amp; reterr == nil </span><span class="cov0" title="0">{
                        reterr = err
                }</span>
        }()

        <span class="cov0" title="0">var controlPlaneScope *scope.ManagedControlPlaneScope

        controlPlaneScope, err = scope.NewManagedControlPlaneScope(scope.ManagedControlPlaneScopeParams{
                Client:                 r.Client,
                Logger:                 &amp;logger,
                Cluster:                clusterV1beta1,
                OCIClusterAccessor:     clusterAccessor,
                ClientProvider:         clientProvider,
                ContainerEngineClient:  clients.ContainerEngineClient,
                RegionIdentifier:       clusterRegion,
                OCIManagedControlPlane: controlPlane,
                BaseClient:             clients.BaseClient,
        })

        if err != nil </span><span class="cov0" title="0">{
                return ctrl.Result{}, err
        }</span>

        // Handle deleted clusters
        <span class="cov0" title="0">if !controlPlane.DeletionTimestamp.IsZero() </span><span class="cov0" title="0">{
                return r.reconcileDelete(ctx, controlPlaneScope, controlPlane)
        }</span>

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return reconcile.Result{}, errors.Errorf("failed to create scope: %+v", err)
        }</span> else<span class="cov0" title="0"> {
                return r.reconcile(ctx, controlPlaneScope, controlPlane)
        }</span>

}

func (r *OCIManagedClusterControlPlaneReconciler) reconcile(ctx context.Context, controlPlaneScope *scope.ManagedControlPlaneScope, controlPlane *infrastructurev1beta2.OCIManagedControlPlane) (ctrl.Result, error) <span class="cov8" title="1">{
        // If the OCIManagedControlPlane doesn't have our finalizer, add it.
        controllerutil.AddFinalizer(controlPlane, infrastructurev1beta2.ControlPlaneFinalizer)

        okeControlPlane, err := controlPlaneScope.GetOrCreateControlPlane(ctx)
        if err != nil </span><span class="cov0" title="0">{
                r.Recorder.Event(controlPlane, corev1.EventTypeWarning, "ReconcileError", errors.Wrapf(err, "Failed to reconcile OCIManagedcontrolPlane").Error())
                return ctrl.Result{}, errors.Wrapf(err, "failed to reconcile OCI Managed Control Plane %s/%s", controlPlane.Namespace, controlPlaneScope.GetClusterName())
        }</span>

        // Proceed to reconcile the DOMachine state.
        <span class="cov8" title="1">switch okeControlPlane.LifecycleState </span>{
        case containerengine.ClusterLifecycleStateCreating:<span class="cov8" title="1">
                controlPlaneScope.Info("Managed control plane is pending")
                conditions.MarkFalse(controlPlane, infrastructurev1beta2.ControlPlaneReadyCondition, infrastructurev1beta2.ControlPlaneNotReadyReason, clusterv1.ConditionSeverityInfo, "")
                return reconcile.Result{RequeueAfter: 30 * time.Second}, nil</span>
        case containerengine.ClusterLifecycleStateUpdating:<span class="cov8" title="1">
                controlPlaneScope.Info("Managed control plane is updating")
                r.Recorder.Eventf(controlPlane, corev1.EventTypeNormal, "ControlPlaneUpdating",
                        "Managed control plane is in updating state")
                conditions.MarkTrue(controlPlane, infrastructurev1beta2.ControlPlaneReadyCondition)
                return reconcile.Result{RequeueAfter: 30 * time.Second}, nil</span>
        case containerengine.ClusterLifecycleStateActive:<span class="cov8" title="1">
                controlPlaneScope.Info("Managed control plane is active", "endpoints", okeControlPlane.Endpoints)
                if controlPlaneScope.IsControlPlaneEndpointSubnetPublic() </span><span class="cov0" title="0">{
                        controlPlane.Spec.ControlPlaneEndpoint = clusterv1.APIEndpoint{
                                Host: *okeControlPlane.Endpoints.PublicEndpoint,
                                Port: 6443,
                        }
                }</span> else<span class="cov8" title="1"> {
                        controlPlane.Spec.ControlPlaneEndpoint = clusterv1.APIEndpoint{
                                Host: *okeControlPlane.Endpoints.PrivateEndpoint,
                                Port: 6443,
                        }
                }</span>
                <span class="cov8" title="1">controlPlane.Status.Version = okeControlPlane.KubernetesVersion
                // record the event only when machine goes from not ready to ready state
                r.Recorder.Eventf(controlPlane, corev1.EventTypeNormal, "ControlPlaneReady",
                        "Managed control plane is in ready state")
                conditions.MarkTrue(controlPlane, infrastructurev1beta2.ControlPlaneReadyCondition)

                controlPlaneScope.OCIManagedControlPlane.Status.Ready = true
                err := controlPlaneScope.ReconcileKubeconfig(ctx, okeControlPlane)
                if err != nil </span><span class="cov0" title="0">{
                        return ctrl.Result{}, err
                }</span>
                <span class="cov8" title="1">err = controlPlaneScope.ReconcileBootstrapSecret(ctx, okeControlPlane)
                if err != nil </span><span class="cov0" title="0">{
                        return ctrl.Result{}, err
                }</span>
                <span class="cov8" title="1">isUpdated, err := controlPlaneScope.UpdateControlPlane(ctx, okeControlPlane)
                if err != nil </span><span class="cov0" title="0">{
                        return ctrl.Result{}, err
                }</span>
                <span class="cov8" title="1">if isUpdated </span><span class="cov8" title="1">{
                        return reconcile.Result{RequeueAfter: 30 * time.Second}, nil
                }</span>
                <span class="cov8" title="1">err = controlPlaneScope.ReconcileAddons(ctx, okeControlPlane)
                if err != nil </span><span class="cov0" title="0">{
                        return ctrl.Result{}, err
                }</span>
                <span class="cov8" title="1">return reconcile.Result{RequeueAfter: 180 * time.Second}, nil</span>
        default:<span class="cov8" title="1">
                conditions.MarkFalse(controlPlane, infrastructurev1beta2.ControlPlaneReadyCondition, infrastructurev1beta2.ControlPlaneProvisionFailedReason, clusterv1.ConditionSeverityError, "")
                r.Recorder.Eventf(controlPlane, corev1.EventTypeWarning, "ReconcileError",
                        "Managed control plane has invalid lifecycle state %s", okeControlPlane.LifecycleState)
                return reconcile.Result{}, errors.New(fmt.Sprintf("Control plane has invalid lifecycle state %s", okeControlPlane.LifecycleState))</span>
        }
}

// SetupWithManager sets up the controller with the Manager.
func (r *OCIManagedClusterControlPlaneReconciler) SetupWithManager(ctx context.Context, mgr ctrl.Manager, options controller.Options) error <span class="cov0" title="0">{
        log := ctrl.LoggerFrom(ctx)
        ociManagedClusterMapper, err := OCIManagedClusterToOCIManagedControlPlaneMapper(r.Client, log)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">err = ctrl.NewControllerManagedBy(mgr).
                WithOptions(options).
                For(&amp;infrastructurev1beta2.OCIManagedControlPlane{}).
                Watches(
                        &amp;infrastructurev1beta2.OCIManagedCluster{},
                        handler.EnqueueRequestsFromMapFunc(ociManagedClusterMapper),
                ).
                Watches(
                        &amp;clusterv1.Cluster{},
                        handler.EnqueueRequestsFromMapFunc(ClusterToOCIManagedControlPlaneMapper()),
                        builder.WithPredicates(
                                predicates.ClusterUnpaused(mgr.GetScheme(), log),
                                predicates.ResourceNotPausedAndHasFilterLabel(mgr.GetScheme(), log, ""),
                        ),
                ).
                Complete(r)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrapf(err, "error creating controller")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// ClusterToInfrastructureMapFunc returns a handler.ToRequestsFunc that watches for
// Cluster events and returns reconciliation requests for an infrastructure provider object.
func (r *OCIManagedClusterControlPlaneReconciler) clusterToInfrastructureMapFunc(log logr.Logger) handler.MapFunc <span class="cov0" title="0">{
        return func(ctx context.Context, o client.Object) []reconcile.Request </span><span class="cov0" title="0">{
                c, ok := o.(*clusterv1.Cluster)
                if !ok </span><span class="cov0" title="0">{
                        return nil
                }</span>

                // Make sure the ref is set
                <span class="cov0" title="0">if c.Spec.InfrastructureRef == nil </span><span class="cov0" title="0">{
                        log.V(4).Info("Cluster does not have an InfrastructureRef, skipping mapping.")
                        return nil
                }</span>

                <span class="cov0" title="0">if c.Spec.InfrastructureRef.GroupVersionKind().Kind != "OCIManagedCluster" </span><span class="cov0" title="0">{
                        log.V(4).Info("Cluster has an InfrastructureRef for a different type, skipping mapping.")
                        return nil
                }</span>

                <span class="cov0" title="0">ociCluster := &amp;infrastructurev1beta2.OCIManagedCluster{}
                key := types.NamespacedName{Namespace: c.Spec.InfrastructureRef.Namespace, Name: c.Spec.InfrastructureRef.Name}

                if err := r.Get(ctx, key, ociCluster); err != nil </span><span class="cov0" title="0">{
                        log.V(4).Error(err, "Failed to get OCI cluster")
                        return nil
                }</span>

                <span class="cov0" title="0">if annotations.IsExternallyManaged(ociCluster) </span><span class="cov0" title="0">{
                        log.V(4).Info("OCIManagedCluster is externally managed, skipping mapping.")
                        return nil
                }</span>

                <span class="cov0" title="0">log.V(4).Info("Adding request.", "ociCluster", c.Spec.InfrastructureRef.Name)

                return []reconcile.Request{
                        {
                                NamespacedName: client.ObjectKey{
                                        Namespace: c.Namespace,
                                        Name:      c.Spec.InfrastructureRef.Name,
                                },
                        },
                }</span>
        }
}

func (r *OCIManagedClusterControlPlaneReconciler) reconcileDelete(ctx context.Context,
        controlPlaneScope *scope.ManagedControlPlaneScope, controlPlane *infrastructurev1beta2.OCIManagedControlPlane) (ctrl.Result, error) <span class="cov8" title="1">{
        controlPlaneScope.Info("Handling deleted OCiManagedControlPlane")

        cluster, err := controlPlaneScope.GetOKECluster(ctx)
        if err != nil </span><span class="cov8" title="1">{
                if ociutil.IsNotFound(err) </span><span class="cov8" title="1">{
                        controllerutil.RemoveFinalizer(controlPlaneScope.OCIManagedControlPlane, infrastructurev1beta2.ControlPlaneFinalizer)
                        controlPlaneScope.Info("Cluster is not found, may have been deleted")
                        conditions.MarkTrue(controlPlaneScope.OCIManagedControlPlane, infrastructurev1beta2.ControlPlaneNotFoundReason)
                        controlPlaneScope.OCIManagedControlPlane.Status.Ready = false
                        return reconcile.Result{}, nil
                }</span> else<span class="cov0" title="0"> {
                        return reconcile.Result{}, err
                }</span>
        }
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return reconcile.Result{}, err
        }</span>
        <span class="cov8" title="1">if cluster == nil </span><span class="cov0" title="0">{
                controlPlaneScope.Info("Cluster is not found, may have been deleted")
                controllerutil.RemoveFinalizer(controlPlane, infrastructurev1beta2.ControlPlaneFinalizer)
                return reconcile.Result{}, nil
        }</span>

        <span class="cov8" title="1">switch cluster.LifecycleState </span>{
        case containerengine.ClusterLifecycleStateDeleting:<span class="cov8" title="1">
                controlPlane.Status.Ready = false
                conditions.MarkFalse(controlPlane, infrastructurev1beta2.ControlPlaneReadyCondition, infrastructurev1beta2.ControlPlaneDeletionInProgress, clusterv1.ConditionSeverityWarning, "")
                r.Recorder.Eventf(controlPlane, corev1.EventTypeWarning, "DeletionInProgress", "Managed control plane deletion in progress")
                controlPlaneScope.Info("Managed control plane is deleting")
                return reconcile.Result{RequeueAfter: 30 * time.Second}, nil</span>
        case containerengine.ClusterLifecycleStateDeleted:<span class="cov8" title="1">
                conditions.MarkFalse(controlPlane, infrastructurev1beta2.ControlPlaneReadyCondition, infrastructurev1beta2.ControlPlaneDeletedReason, clusterv1.ConditionSeverityWarning, "")
                controllerutil.RemoveFinalizer(controlPlane, infrastructurev1beta2.ControlPlaneFinalizer)
                controlPlaneScope.Info("Managed control plane is deleted")
                return reconcile.Result{}, nil</span>
        default:<span class="cov8" title="1">
                if err := controlPlaneScope.DeleteOKECluster(ctx, cluster); err != nil </span><span class="cov0" title="0">{
                        controlPlaneScope.Error(err, "Error deleting managed control plane")
                        return ctrl.Result{}, errors.Wrapf(err, "error deleting cluster %s", controlPlaneScope.GetClusterName())
                }</span>
                <span class="cov8" title="1">conditions.MarkFalse(controlPlane, infrastructurev1beta2.ControlPlaneReadyCondition, infrastructurev1beta2.ControlPlaneDeletionInProgress, clusterv1.ConditionSeverityWarning, "")
                return reconcile.Result{RequeueAfter: 30 * time.Second}, nil</span>
        }
}

func OCIManagedClusterToOCIManagedControlPlaneMapper(c client.Client, log logr.Logger) (handler.MapFunc, error) <span class="cov0" title="0">{
        return func(ctx context.Context, o client.Object) []ctrl.Request </span><span class="cov0" title="0">{
                ociCluster, ok := o.(*infrastructurev1beta2.OCIManagedCluster)
                if !ok </span><span class="cov0" title="0">{
                        log.Error(errors.Errorf("expected an OCIManagedCluster, got %T instead", o), "failed to map OCIManagedCluster")
                        return nil
                }</span>

                <span class="cov0" title="0">log = log.WithValues("OCIManagedCluster", ociCluster.Name, "Namespace", ociCluster.Namespace)

                // Don't handle deleted OCIManagedClusters
                if !ociCluster.ObjectMeta.DeletionTimestamp.IsZero() </span><span class="cov0" title="0">{
                        log.V(4).Info("OCIManagedCluster has a deletion timestamp, skipping mapping.")
                        return nil
                }</span>

                <span class="cov0" title="0">cluster, err := util.GetOwnerCluster(ctx, c, ociCluster.ObjectMeta)
                if err != nil </span><span class="cov0" title="0">{
                        log.Error(err, "failed to get the owning cluster")
                        return nil
                }</span>

                <span class="cov0" title="0">if cluster == nil </span><span class="cov0" title="0">{
                        log.Error(err, "cluster has not set owner ref yet")
                        return nil
                }</span>

                <span class="cov0" title="0">ref := cluster.Spec.ControlPlaneRef
                if ref.Name == "" </span><span class="cov0" title="0">{
                        return nil
                }</span>

                <span class="cov0" title="0">return []ctrl.Request{
                        {
                                NamespacedName: types.NamespacedName{
                                        Namespace: cluster.Namespace,
                                        Name:      ref.Name,
                                },
                        },
                }</span>
        }, nil
}

func ClusterToOCIManagedControlPlaneMapper() handler.MapFunc <span class="cov0" title="0">{
        return func(ctx context.Context, o client.Object) []ctrl.Request </span><span class="cov0" title="0">{
                cluster, ok := o.(*clusterv1.Cluster)
                if !ok </span><span class="cov0" title="0">{
                        return nil
                }</span>

                <span class="cov0" title="0">ref := cluster.Spec.ControlPlaneRef
                if ref.Name == "" </span><span class="cov0" title="0">{
                        return nil
                }</span>

                <span class="cov0" title="0">return []ctrl.Request{
                        {
                                NamespacedName: types.NamespacedName{
                                        Namespace: cluster.Namespace,
                                        Name:      ref.Name,
                                },
                        },
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file79" style="display: none">/*
 Copyright (c) 2023 Oracle and/or its affiliates.

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

      https://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
*/

package v1beta1

import (
        infrastructurev1beta1 "github.com/oracle/cluster-api-provider-oci/api/v1beta1"
        infrastructurev1beta2 "github.com/oracle/cluster-api-provider-oci/api/v1beta2"
        "github.com/oracle/cluster-api-provider-oci/exp/api/v1beta2"
        "k8s.io/apimachinery/pkg/conversion"
)

// Convert_v1beta1_NetworkSpec_To_v1beta2_NetworkSpec converts v1beta1 NetworkSpec to v1beta2 NetworkSpec
func Convert_v1beta1_NetworkSpec_To_v1beta2_NetworkSpec(in *infrastructurev1beta1.NetworkSpec, out *infrastructurev1beta2.NetworkSpec, s conversion.Scope) error <span class="cov0" title="0">{
        return infrastructurev1beta1.Convert_v1beta1_NetworkSpec_To_v1beta2_NetworkSpec(in, out, s)
}</span>

// Convert_v1beta2_NetworkSpec_To_v1beta1_NetworkSpec converts v1beta2 NetworkSpec to v1beta1 NetworkSpec
func Convert_v1beta2_NetworkSpec_To_v1beta1_NetworkSpec(in *infrastructurev1beta2.NetworkSpec, out *infrastructurev1beta1.NetworkSpec, s conversion.Scope) error <span class="cov0" title="0">{
        return infrastructurev1beta1.Convert_v1beta2_NetworkSpec_To_v1beta1_NetworkSpec(in, out, s)
}</span>

// Convert_v1beta2_NetworkDetails_To_v1beta1_NetworkDetails converts v1beta2 NetworkDetails to v1beta1 NetworkDetails
func Convert_v1beta2_NetworkDetails_To_v1beta1_NetworkDetails(in *infrastructurev1beta2.NetworkDetails, out *infrastructurev1beta1.NetworkDetails, s conversion.Scope) error <span class="cov8" title="1">{
        return infrastructurev1beta1.Convert_v1beta2_NetworkDetails_To_v1beta1_NetworkDetails(in, out, s)
}</span>

func Convert_v1beta2_OCIManagedMachinePoolSpec_To_v1beta1_OCIManagedMachinePoolSpec(in *v1beta2.OCIManagedMachinePoolSpec, out *OCIManagedMachinePoolSpec, s conversion.Scope) error <span class="cov8" title="1">{
        return autoConvert_v1beta2_OCIManagedMachinePoolSpec_To_v1beta1_OCIManagedMachinePoolSpec(in, out, s)
}</span>
</pre>
		
		<pre class="file" id="file80" style="display: none">/*
Copyright (c) 2021, 2022 Oracle and/or its affiliates.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1beta1

import (
        "github.com/oracle/cluster-api-provider-oci/exp/api/v1beta2"
        utilconversion "sigs.k8s.io/cluster-api/util/conversion"
        "sigs.k8s.io/controller-runtime/pkg/conversion"
)

// ConvertTo converts the v1beta1 OCIMachinePool receiver to a v1beta2 OCIMachinePool.
func (src *OCIMachinePool) ConvertTo(dstRaw conversion.Hub) error <span class="cov8" title="1">{
        dst := dstRaw.(*v1beta2.OCIMachinePool)

        if err := Convert_v1beta1_OCIMachinePool_To_v1beta2_OCIMachinePool(src, dst, nil); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Manually restore data.
        <span class="cov8" title="1">restored := &amp;v1beta2.OCIMachinePool{}
        if ok, err := utilconversion.UnmarshalData(src, restored); err != nil || !ok </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// ConvertFrom converts receiver to a v1beta2 OCIManagedMachinePool.
func (r *OCIMachinePool) ConvertFrom(srcRaw conversion.Hub) error <span class="cov8" title="1">{
        src := srcRaw.(*v1beta2.OCIMachinePool)

        if err := Convert_v1beta2_OCIMachinePool_To_v1beta1_OCIMachinePool(src, r, nil); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Preserve Hub data on down-conversion.
        <span class="cov8" title="1">if err := utilconversion.MarshalData(src, r); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file81" style="display: none">/*
Copyright (c) 2022 Oracle and/or its affiliates.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1beta1

import (
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        clusterv1 "sigs.k8s.io/cluster-api/api/core/v1beta1"
)

// +kubebuilder:object:generate=true
// +groupName=infrastructure.cluster.x-k8s.io

const (
        Managed     MachineTypeEnum = "MANAGED_TYPE"
        Virtual     MachineTypeEnum = "VIRTUAL_TYPE"
        SelfManaged MachineTypeEnum = "SELF_MANAGED_TYPE"
)

type MachineTypeEnum string

// OCIMachinePoolMachineSpec defines the desired state of OCIMachinePoolMachine
type OCIMachinePoolMachineSpec struct {
        // ProviderID is the Oracle Cloud Identifier of the associated instance.
        // +optional
        ProviderID *string `json:"providerID,omitempty"`

        // OCID is the OCID of the associated instance.
        // +optional
        OCID *string `json:"ocid,omitempty"`

        // InstanceName is the name of the instance.
        // +optional
        InstanceName *string `json:"instanceName,omitempty"`

        // MachineType is the type of the machine.
        MachineType MachineTypeEnum `json:"machineType,omitempty"`
}

// OCIMachinePoolMachineStatus defines the observed state of OCIMachinePoolMachine
type OCIMachinePoolMachineStatus struct {
        // Flag set to true when machine is ready.
        // +optional
        Ready bool `json:"ready,omitempty"`

        // Conditions defines current service state of the OCIMachinePool.
        // +optional
        Conditions clusterv1.Conditions `json:"conditions,omitempty"`
}

//+kubebuilder:object:root=true
//+kubebuilder:subresource:status

type OCIMachinePoolMachine struct {
        metav1.TypeMeta   `json:",inline"`
        metav1.ObjectMeta `json:"metadata,omitempty"`

        Spec   OCIMachinePoolMachineSpec   `json:"spec,omitempty"`
        Status OCIMachinePoolMachineStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// OCIMachinePoolMachineList contains a list of OCIMachinePoolMachine.
type OCIMachinePoolMachineList struct {
        metav1.TypeMeta `json:",inline"`
        metav1.ListMeta `json:"metadata,omitempty"`
        Items           []OCIMachinePoolMachine `json:"items"`
}

func init() <span class="cov8" title="1">{
        SchemeBuilder.Register(&amp;OCIMachinePoolMachine{}, &amp;OCIMachinePoolMachineList{})
}</span>
</pre>
		
		<pre class="file" id="file82" style="display: none">/*
Copyright (c) 2022 Oracle and/or its affiliates.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1beta1

import (
        infrastructurev1beta1 "github.com/oracle/cluster-api-provider-oci/api/v1beta1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        clusterv1 "sigs.k8s.io/cluster-api/api/core/v1beta1"
)

// +kubebuilder:object:generate=true
// +groupName=infrastructure.cluster.x-k8s.io

const (
        // MachinePoolFinalizer is the finalizer for the machine pool.
        MachinePoolFinalizer = "ocimachinepool.infrastructure.cluster.x-k8s.io"
)

// OCIMachinePoolSpec defines the desired state of OCIMachinePool
type OCIMachinePoolSpec struct {
        // ProviderID is the OCID of the associated InstancePool in a provider format
        // +optional
        ProviderID *string `json:"providerID,omitempty"`

        // OCID is the OCID of the associated InstancePool
        // +optional
        OCID *string `json:"ocid,omitempty"`

        // PlacementDetails defines the placement details of the instance pool.
        PlacementDetails []PlacementDetails `json:"placementDetails,omitempty"`

        // InstanceConfiguration defines the configuration of the instance pool instances.
        InstanceConfiguration InstanceConfiguration `json:"instanceConfiguration,omitempty"`

        // ProviderIDList are the identification IDs of machine instances provided by the provider.
        // This field must match the provider IDs as seen on the node objects corresponding to a machine pool's machine instances.
        // +optional
        ProviderIDList []string `json:"providerIDList,omitempty"`
}

type InstanceConfiguration struct {
        InstanceConfigurationId *string `json:"instanceConfigurationId,omitempty"`
        Shape                   *string `json:"shape,omitempty"`
        // The shape configuration of the instance, applicable for flex instances.
        ShapeConfig *ShapeConfig `json:"shapeConfig,omitempty"`

        InstanceVnicConfiguration *infrastructurev1beta1.NetworkDetails `json:"instanceVnicConfiguration,omitempty"`

        // PlatformConfig defines the platform config parameters
        PlatformConfig *infrastructurev1beta1.PlatformConfig `json:"platformConfig,omitempty"`

        // AgentConfig defines the options for the Oracle Cloud Agent software running on the instance.
        AgentConfig *infrastructurev1beta1.LaunchInstanceAgentConfig `json:"agentConfig,omitempty"`

        // PreemptibleInstanceConfig Configuration options for preemptible instances.
        PreemptibleInstanceConfig *infrastructurev1beta1.PreemptibleInstanceConfig `json:"preemptibleInstanceConfig,omitempty"`

        // LaunchInstanceAvailabilityConfig defines the options for VM migration during infrastructure maintenance events and for defining
        // the availability of a VM instance after a maintenance event that impacts the underlying hardware.
        AvailabilityConfig *infrastructurev1beta1.LaunchInstanceAvailabilityConfig `json:"availabilityConfig,omitempty"`

        // DedicatedVmHostId defines the OCID of the dedicated VM host.
        DedicatedVmHostId *string `json:"dedicatedVmHostId,omitempty"`

        // LaunchOptions defines the options for tuning the compatibility and performance of VM shapes
        LaunchOptions *infrastructurev1beta1.LaunchOptions `json:"launchOptions,omitempty"`

        // InstanceOptions defines the instance options
        InstanceOptions *infrastructurev1beta1.InstanceOptions `json:"instanceOptions,omitempty"`

        // Is in transit encryption of volumes required.
        // +kubebuilder:default=true
        // +optional
        IsPvEncryptionInTransitEnabled *bool `json:"isPvEncryptionInTransitEnabled,omitempty"`

        // InstanceSourceViaImageConfig defines the options for booting up instances via images
        InstanceSourceViaImageDetails *InstanceSourceViaImageConfig `json:"instanceSourceViaImageConfig,omitempty"`

        // CapacityReservationId defines the OCID of the compute capacity reservation this instance is launched under.
        // You can opt out of all default reservations by specifying an empty string as input for this field.
        // For more information, see Capacity Reservations (https://docs.cloud.oracle.com/iaas/Content/Compute/Tasks/reserve-capacity.htm#default).
        CapacityReservationId *string `json:"capacityReservationId,omitempty"`

        // Custom metadata key/value pairs that you provide, such as the SSH public key
        // required to connect to the instance.
        Metadata map[string]string `json:"metadata,omitempty"`
}

type PlacementDetails struct {
        // The availability domain to place instances.
        AvailabilityDomain int `mandatory:"true" json:"availabilityDomain"`
}

// LaunchDetails Instance launch details for creating an instance from an instance configuration
// https://docs.oracle.com/en-us/iaas/api/#/en/iaas/20160918/datatypes/InstanceConfigurationLaunchInstanceDetails
type LaunchDetails struct {
        // Custom metadata key/value pairs that you provide, such as the SSH public key
        // required to connect to the instance.
        Metadata map[string]string `json:"metadata,omitempty"`

        Shape string `json:"shape,omitempty"`
}

// ShapeConfig defines the configuration options for the compute instance shape
// https://docs.oracle.com/en-us/iaas/api/#/en/iaas/20160918/datatypes/LaunchInstanceShapeConfigDetails
type ShapeConfig struct {
        // The total number of OCPUs available to the instance.
        Ocpus *string `json:"ocpus,omitempty"`

        // The total amount of memory available to the instance, in gigabytes.
        MemoryInGBs *string `json:"memoryInGBs,omitempty"`

        // The baseline OCPU utilization for a subcore burstable VM instance. Leave this attribute blank for a
        // non-burstable instance, or explicitly specify non-burstable with `BASELINE_1_1`.
        // The following values are supported:
        // - `BASELINE_1_8` - baseline usage is 1/8 of an OCPU.
        // - `BASELINE_1_2` - baseline usage is 1/2 of an OCPU.
        // - `BASELINE_1_1` - baseline usage is an entire OCPU. This represents a non-burstable instance.
        BaselineOcpuUtilization string `json:"baselineOcpuUtilization,omitempty"`

        // Nvmes defines the number of NVMe drives to be used for storage. A single drive has 6.8 TB available.
        Nvmes *int `json:"nvmes,omitempty"`
}

// InstanceVnicConfiguration defines the configuration options for the network
type InstanceVnicConfiguration struct {

        // AssignPublicIp defines whether the instance should have a public IP address
        AssignPublicIp bool `json:"assignPublicIp,omitempty"`

        // SubnetName defines the subnet name to use for the VNIC
        SubnetName string `json:"subnetName,omitempty"`

        // Deprecated, use         NsgNames parameter to define the NSGs
        NSGId *string `json:"nsgId,omitempty"`

        // SkipSourceDestCheck defines whether the source/destination check is disabled on the VNIC.
        SkipSourceDestCheck *bool `json:"skipSourceDestCheck,omitempty"`

        // NsgNames defines a list of the nsg names of the network security groups (NSGs) to add the VNIC to.
        NsgNames []string `json:"nsgNames,omitempty"`

        // HostnameLabel defines the hostname for the VNIC's primary private IP. Used for DNS.
        HostnameLabel *string `json:"hostnameLabel,omitempty"`

        // DisplayName defines a user-friendly name. Does not have to be unique, and it's changeable.
        // Avoid entering confidential information.
        DisplayName *string `json:"displayName,omitempty"`

        // AssignPrivateDnsRecord defines whether the VNIC should be assigned a DNS record.
        AssignPrivateDnsRecord *bool `json:"assignPrivateDnsRecord,omitempty"`
}

// InstanceSourceViaImageConfig The configuration options for booting up instances via images
type InstanceSourceViaImageConfig struct {
        // OCID of the image to be used to launch the instance.
        ImageId *string `json:"imageId,omitempty"`

        // KmsKeyId defines the OCID of the Key Management key to assign as the master encryption key for the boot volume.
        KmsKeyId *string `json:"kmsKeyId,omitempty"`

        // The size of boot volume. Please see https://docs.oracle.com/en-us/iaas/Content/Block/Tasks/extendingbootpartition.htm
        // to extend the boot volume size.
        BootVolumeSizeInGBs *int64 `json:"bootVolumeSizeInGBs,omitempty"`

        // BootVolumeVpusPerGB defines the number of volume performance units (VPUs) that will be applied to this volume per GB,
        // representing the Block Volume service's elastic performance options.
        // See Block Volume Performance Levels (https://docs.cloud.oracle.com/iaas/Content/Block/Concepts/blockvolumeperformance.htm#perf_levels) for more information.
        // Allowed values:
        //   * `10`: Represents Balanced option.
        //   * `20`: Represents Higher Performance option.
        //   * `30`-`120`: Represents the Ultra High Performance option.
        // For volumes with the auto-tuned performance feature enabled, this is set to the default (minimum) VPUs/GB.
        BootVolumeVpusPerGB *int64 `json:"bootVolumeVpusPerGB,omitempty"`
}

// OCIMachinePoolStatus defines the observed state of OCIMachinePool
type OCIMachinePoolStatus struct {
        // Ready is true when the provider resource is ready.
        // +optional
        Ready bool `json:"ready"`

        // Replicas is the most recently observed number of replicas
        // +optional
        Replicas int32 `json:"replicas"`

        // Conditions defines current service state of the OCIMachinePool.
        // +optional
        Conditions clusterv1.Conditions `json:"conditions,omitempty"`

        FailureReason *string `json:"failureReason,omitempty"`

        FailureMessage *string `json:"failureMessage,omitempty"`

        // InfrastructureMachineKind is the kind of the infrastructure resources behind MachinePool Machines.
        // +optional
        InfrastructureMachineKind string `json:"infrastructureMachineKind,omitempty"`
}

//+kubebuilder:object:root=true
//+kubebuilder:subresource:status

type OCIMachinePool struct {
        metav1.TypeMeta   `json:",inline"`
        metav1.ObjectMeta `json:"metadata,omitempty"`

        Spec   OCIMachinePoolSpec   `json:"spec,omitempty"`
        Status OCIMachinePoolStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// OCIMachinePoolList contains a list of OCIMachinePool.
type OCIMachinePoolList struct {
        metav1.TypeMeta `json:",inline"`
        metav1.ListMeta `json:"metadata,omitempty"`
        Items           []OCIMachinePool `json:"items"`
}

// GetConditions returns the list of conditions for an OCIMachine API object.
func (m *OCIMachinePool) GetConditions() clusterv1.Conditions <span class="cov0" title="0">{
        return m.Status.Conditions
}</span>

// SetConditions will set the given conditions on an OCIMachine object.
func (m *OCIMachinePool) SetConditions(conditions clusterv1.Conditions) <span class="cov0" title="0">{
        m.Status.Conditions = conditions
}</span>

func init() <span class="cov8" title="1">{
        SchemeBuilder.Register(&amp;OCIMachinePool{}, &amp;OCIMachinePoolList{})
}</span>
</pre>
		
		<pre class="file" id="file83" style="display: none">/*
Copyright (c) 2021, 2022 Oracle and/or its affiliates.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1beta1

import (
        "github.com/oracle/cluster-api-provider-oci/exp/api/v1beta2"
        utilconversion "sigs.k8s.io/cluster-api/util/conversion"
        "sigs.k8s.io/controller-runtime/pkg/conversion"
)

// ConvertTo converts the v1beta1 OCIMachinePoolMachine receiver to a v1beta2 OCIMachinePoolMachine.
func (src *OCIMachinePoolMachine) ConvertTo(dstRaw conversion.Hub) error <span class="cov0" title="0">{
        dst := dstRaw.(*v1beta2.OCIMachinePoolMachine)

        if err := Convert_v1beta1_OCIMachinePoolMachine_To_v1beta2_OCIMachinePoolMachine(src, dst, nil); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">restored := &amp;v1beta2.OCIMachinePoolMachine{}
        if ok, err := utilconversion.UnmarshalData(src, restored); err != nil || !ok </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// ConvertFrom converts receiver to a v1beta2 OCIMachinePoolMachine.
func (r *OCIMachinePoolMachine) ConvertFrom(srcRaw conversion.Hub) error <span class="cov0" title="0">{
        src := srcRaw.(*v1beta2.OCIMachinePoolMachine)

        if err := Convert_v1beta2_OCIMachinePoolMachine_To_v1beta1_OCIMachinePoolMachine(src, r, nil); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Preserve Hub data on down-conversion.
        <span class="cov0" title="0">if err := utilconversion.MarshalData(src, r); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file84" style="display: none">/*
Copyright (c) 2021, 2022 Oracle and/or its affiliates.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1beta1

import (
        "github.com/oracle/cluster-api-provider-oci/exp/api/v1beta2"
        utilconversion "sigs.k8s.io/cluster-api/util/conversion"
        "sigs.k8s.io/controller-runtime/pkg/conversion"
)

// ConvertTo converts the v1beta1 OCIManagedMachinePool receiver to a v1beta2 OCIManagedMachinePool.
func (src *OCIManagedMachinePool) ConvertTo(dstRaw conversion.Hub) error <span class="cov8" title="1">{
        dst := dstRaw.(*v1beta2.OCIManagedMachinePool)

        if err := Convert_v1beta1_OCIManagedMachinePool_To_v1beta2_OCIManagedMachinePool(src, dst, nil); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">restored := &amp;v1beta2.OCIManagedMachinePool{}
        if ok, err := utilconversion.UnmarshalData(src, restored); err != nil || !ok </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">dst.Spec.NodePoolCyclingDetails = restored.Spec.NodePoolCyclingDetails

        return nil</span>
}

// ConvertFrom converts receiver to a v1beta2 OCIManagedMachinePool.
func (r *OCIManagedMachinePool) ConvertFrom(srcRaw conversion.Hub) error <span class="cov8" title="1">{
        src := srcRaw.(*v1beta2.OCIManagedMachinePool)

        if err := Convert_v1beta2_OCIManagedMachinePool_To_v1beta1_OCIManagedMachinePool(src, r, nil); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Preserve Hub data on down-conversion.
        <span class="cov8" title="1">if err := utilconversion.MarshalData(src, r); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file85" style="display: none">package v1beta1

import (
        infrastructurev1beta1 "github.com/oracle/cluster-api-provider-oci/api/v1beta1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        clusterv1 "sigs.k8s.io/cluster-api/api/core/v1beta1"
        "sigs.k8s.io/cluster-api/errors"
)

const (
        // ManagedMachinePoolFinalizer is the finalizer for managed machine pool.
        ManagedMachinePoolFinalizer = "ocimanagedmachinepool.infrastructure.cluster.x-k8s.io"
)

// OCIManagedMachinePoolSpec defines the desired state of an OCI managed machine pool.
// An OCIManagedMachinePool translates to an OKE NodePool.
// The properties are generated from https://docs.oracle.com/en-us/iaas/api/#/en/containerengine/20180222/datatypes/CreateNodePoolDetails
type OCIManagedMachinePoolSpec struct {

        // ProviderID is the OCID of the associated NodePool in a provider format
        // +optional
        ProviderID *string `json:"providerID,omitempty"`

        // Version represents the version of the OKE node pool.
        Version *string `json:"version,omitempty"`

        // ID is the OCID of the associated NodePool
        // +optional
        ID *string `json:"id,omitempty"`

        // NodePoolNodeConfig defines the configuration of nodes in the node pool.
        // +optional
        NodePoolNodeConfig *NodePoolNodeConfig `json:"nodePoolNodeConfig,omitempty"`

        // NodeEvictionNodePoolSettings defines the eviction settings.
        // +optional
        NodeEvictionNodePoolSettings *NodeEvictionNodePoolSettings `json:"nodeEvictionNodePoolSettings,omitempty"`

        // NodeShape defines the name of the node shape of the nodes in the node pool.
        // +optional
        NodeShape string `json:"nodeShape,omitempty"`

        // NodeShapeConfig defines the configuration of the shape to launch nodes in the node pool.
        // +optional
        NodeShapeConfig *NodeShapeConfig `json:"nodeShapeConfig,omitempty"`

        // NodeSourceViaImage defines the image configuration of the nodes in the nodepool.
        // +optional
        NodeSourceViaImage *NodeSourceViaImage `json:"nodeSourceViaImage,omitempty"`

        // SshPublicKey defines the SSH public key on each node in the node pool on launch.
        // +optional
        SshPublicKey string `json:"sshPublicKey,omitempty"`

        // NodeMetadata defines a list of key/value pairs to add to each underlying OCI instance in the node pool on launch.
        // +optional
        NodeMetadata map[string]string `json:"nodeMetadata,omitempty"`

        // InitialNodeLabels defines a list of key/value pairs to add to nodes after they join the Kubernetes cluster.
        // +optional
        InitialNodeLabels []KeyValue `json:"initialNodeLabels,omitempty"`

        // ProviderIDList are the identification IDs of machine instances provided by the provider.
        // This field must match the provider IDs as seen on the node objects corresponding to a machine pool's machine instances.
        // +optional
        ProviderIDList []string `json:"providerIDList,omitempty"`
}

// NodePoolNodeConfig describes the configuration of nodes in the node pool.
type NodePoolNodeConfig struct {
        // IsPvEncryptionInTransitEnabled defines whether in transit encryption should be enabled on the nodes.
        // +optional
        IsPvEncryptionInTransitEnabled *bool `json:"isPvEncryptionInTransitEnabled,omitempty"`

        // KmsKeyId  defines whether in transit encryption should be enabled on the nodes.
        // +optional
        KmsKeyId *string `json:"kmsKeyId,omitempty"`

        // PlacementConfigs defines the placement configurations for the node pool.
        // +optional
        PlacementConfigs []PlacementConfig `json:"placementConfigs,omitempty"`

        // NsgNames defines the names of NSGs which will be associated with the nodes. the NSGs are defined
        // in OCIManagedCluster object.
        // +optional
        NsgNames []string `json:"nsgNames,omitempty"`

        // NodePoolPodNetworkOptionDetails defines the pod networking details of the node pool
        // +optional
        NodePoolPodNetworkOptionDetails *NodePoolPodNetworkOptionDetails `json:"nodePoolPodNetworkOptionDetails,omitempty"`
}

// NodePoolPodNetworkOptionDetails describes the CNI related configuration of pods in the node pool.
type NodePoolPodNetworkOptionDetails struct {

        // CniType describes the CNI plugin used by this node pool. Allowed values are OCI_VCN_IP_NATIVE and FLANNEL_OVERLAY.
        // +optional
        CniType infrastructurev1beta1.CNIOptionEnum `json:"cniType,omitempty"`

        // VcnIpNativePodNetworkOptions describes the network options specific to using the OCI VCN Native CNI
        // +optional
        VcnIpNativePodNetworkOptions VcnIpNativePodNetworkOptions `json:"vcnIpNativePodNetworkOptions,omitempty"`
}

// VcnIpNativePodNetworkOptions defines the Network options specific to using the OCI VCN Native CNI
type VcnIpNativePodNetworkOptions struct {

        // MemoryInGBs defines the max number of pods per node in the node pool. This value will be limited by the
        // number of VNICs attachable to the node pool shape
        // +optional
        MaxPodsPerNode *int `json:"maxPodsPerNode,omitempty"`

        // NSGNames defines the NSGs associated with the native pod network.
        // +optional
        NSGNames []string `json:"nsgNames,omitempty"`

        // SubnetNames defines the Subnets associated with the native pod network.
        // +optional
        SubnetNames []string `json:"subnetNames,omitempty"`
}

// PlacementConfig defines the placement configurations for the node pool.
type PlacementConfig struct {
        // AvailabilityDomain defines the availability domain in which to place nodes.
        // +optional
        AvailabilityDomain *string `json:"availabilityDomain,omitempty"`

        // CapacityReservationId defines the OCID of the compute capacity reservation in which to place the compute instance.
        // +optional
        CapacityReservationId *string `json:"capacityReservationId,omitempty"`

        // FaultDomains defines the list of fault domains in which to place nodes.
        // +optional
        FaultDomains []string `json:"faultDomains,omitempty"`

        // SubnetName defines the name of the subnet which need ot be associated with the Nodepool.
        // The subnets are defined in the OCiManagedCluster object.
        // +optional
        SubnetName *string `json:"subnetName,omitempty"`
}

// NodeEvictionNodePoolSettings defines the Node Eviction Details configuration.
type NodeEvictionNodePoolSettings struct {

        // EvictionGraceDuration defines the duration after which OKE will give up eviction of the pods on the node. PT0M will indicate you want to delete the node without cordon and drain. Default PT60M, Min PT0M, Max: PT60M. Format ISO 8601 e.g PT30M
        // +optional
        EvictionGraceDuration *string `json:"evictionGraceDuration,omitempty"`

        // IsForceDeleteAfterGraceDuration defines if the underlying compute instance should be deleted if you cannot evict all the pods in grace period
        // +optional
        IsForceDeleteAfterGraceDuration *bool `json:"isForceDeleteAfterGraceDuration,omitempty"`
}

// NodeShapeConfig defines the shape configuration of the nodes.
type NodeShapeConfig struct {

        // MemoryInGBs defines the total amount of memory available to each node, in gigabytes.
        // +optional
        MemoryInGBs *string `json:"memoryInGBs,omitempty"`

        // Ocpus defines the total number of OCPUs available to each node in the node pool.
        // +optional
        Ocpus *string `json:"ocpus,omitempty"`
}

// NodeSourceViaImage defines the Details of the image running on the node.
type NodeSourceViaImage struct {

        // BootVolumeSizeInGBs defines the size of the boot volume in GBs.
        // +optional
        BootVolumeSizeInGBs *int64 `json:"bootVolumeSizeInGBs,omitempty"`

        // ImageId defines the OCID of the image used to boot the node.
        // +optional
        ImageId *string `json:"imageId,omitempty"`
}

// KeyValue The properties that define a key value pair.
type KeyValue struct {

        // The key of the pair.
        Key *string `json:"key,omitempty"`

        // The value of the pair.
        Value *string `json:"value,omitempty"`
}

// OCIManagedMachinePoolStatus defines the observed state of OCIManagedMachinePool
type OCIManagedMachinePoolStatus struct {
        // +optional
        Ready bool `json:"ready"`
        // NetworkSpec encapsulates all things related to OCI network.
        // +optional
        Conditions clusterv1.Conditions `json:"conditions,omitempty"`

        // +optional
        NodepoolLifecycleState string `json:"nodepoolLifecycleState,omitempty"`

        // Replicas is the most recently observed number of replicas
        // +optional
        Replicas int32 `json:"replicas"`

        FailureReason *errors.MachineStatusError `json:"failureReason,omitempty"`

        FailureMessages []string `json:"failureMessages,omitempty"`

        // InfrastructureMachineKind is the kind of the infrastructure resources behind MachinePool Machines.
        // +optional
        InfrastructureMachineKind string `json:"infrastructureMachineKind,omitempty"`
}

//+kubebuilder:object:root=true
//+kubebuilder:subresource:status

// OCIManagedMachinePool is the Schema for the ocimanagedmachinepool API.
type OCIManagedMachinePool struct {
        metav1.TypeMeta   `json:",inline"`
        metav1.ObjectMeta `json:"metadata,omitempty"`

        Spec   OCIManagedMachinePoolSpec   `json:"spec,omitempty"`
        Status OCIManagedMachinePoolStatus `json:"status,omitempty"`
}

//+kubebuilder:object:root=true

// OCIManagedMachinePoolList contains a list of OCIManagedMachinePool.
type OCIManagedMachinePoolList struct {
        metav1.TypeMeta `json:",inline"`
        metav1.ListMeta `json:"metadata,omitempty"`
        Items           []OCIManagedMachinePool `json:"items"`
}

// GetConditions returns the list of conditions for an OCIMachine API object.
func (m *OCIManagedMachinePool) GetConditions() clusterv1.Conditions <span class="cov0" title="0">{
        return m.Status.Conditions
}</span>

// SetConditions will set the given conditions on an OCIMachine object.
func (m *OCIManagedMachinePool) SetConditions(conditions clusterv1.Conditions) <span class="cov0" title="0">{
        m.Status.Conditions = conditions
}</span>

func init() <span class="cov8" title="1">{
        SchemeBuilder.Register(&amp;OCIManagedMachinePool{}, &amp;OCIManagedMachinePoolList{})
}</span>
</pre>
		
		<pre class="file" id="file86" style="display: none">/*
Copyright (c) 2022, Oracle and/or its affiliates.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1beta1

import (
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

// OCIManagedMachinePoolTemplateSpec defines the desired state of OCIManagedMachinePoolTemplate.
type OCIManagedMachinePoolTemplateSpec struct {
        Template OCIManagedMachinePoolTemplateResource `json:"template"`
}

// +kubebuilder:object:root=true
// +kubebuilder:resource:path=ocimanagedmachinepooltemplates,scope=Namespaced,categories=cluster-api

// OCIManagedMachinePoolTemplate is the Schema for the OCIManagedMachinePoolTemplates API.
type OCIManagedMachinePoolTemplate struct {
        metav1.TypeMeta   `json:",inline"`
        metav1.ObjectMeta `json:"metadata,omitempty"`

        Spec OCIManagedMachinePoolTemplateSpec `json:"spec,omitempty"`
}

// +kubebuilder:object:root=true

// OCIManagedMachinePoolTemplateList contains a list of OCIManagedMachinePoolTemplate.
type OCIManagedMachinePoolTemplateList struct {
        metav1.TypeMeta `json:",inline"`
        metav1.ListMeta `json:"metadata,omitempty"`

        Items []OCIManagedMachinePoolTemplate `json:"items"`
}

func init() <span class="cov8" title="1">{
        SchemeBuilder.Register(&amp;OCIManagedMachinePoolTemplate{}, &amp;OCIManagedMachinePoolTemplateList{})
}</span>

// OCIManagedMachinePoolSpec describes the data needed to create an OCIManagedMachinePool from a template.
type OCIManagedMachinePoolTemplateResource struct {
        Spec OCIManagedMachinePoolSpec `json:"spec"`
}
</pre>
		
		<pre class="file" id="file87" style="display: none">/*
Copyright (c) 2021, 2022 Oracle and/or its affiliates.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1beta1

import (
        "github.com/oracle/cluster-api-provider-oci/exp/api/v1beta2"
        utilconversion "sigs.k8s.io/cluster-api/util/conversion"
        "sigs.k8s.io/controller-runtime/pkg/conversion"
)

// ConvertTo converts the v1beta1 OCIVirtualMachinePool receiver to a v1beta2 OCIVirtualMachinePool.
func (src *OCIVirtualMachinePool) ConvertTo(dstRaw conversion.Hub) error <span class="cov0" title="0">{
        dst := dstRaw.(*v1beta2.OCIVirtualMachinePool)

        if err := Convert_v1beta1_OCIVirtualMachinePool_To_v1beta2_OCIVirtualMachinePool(src, dst, nil); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">restored := &amp;v1beta2.OCIVirtualMachinePool{}
        if ok, err := utilconversion.UnmarshalData(src, restored); err != nil || !ok </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// ConvertFrom converts receiver to a v1beta2 OCIVirtualMachinePool.
func (r *OCIVirtualMachinePool) ConvertFrom(srcRaw conversion.Hub) error <span class="cov0" title="0">{
        src := srcRaw.(*v1beta2.OCIVirtualMachinePool)

        if err := Convert_v1beta2_OCIVirtualMachinePool_To_v1beta1_OCIVirtualMachinePool(src, r, nil); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Preserve Hub data on down-conversion.
        <span class="cov0" title="0">if err := utilconversion.MarshalData(src, r); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file88" style="display: none">package v1beta1

import (
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        clusterv1 "sigs.k8s.io/cluster-api/api/core/v1beta1"
        "sigs.k8s.io/cluster-api/errors"
)

const (
        // VirtualMachinePoolFinalizer is the finalizer for virtual machine pool.
        VirtualMachinePoolFinalizer = "ocivirtualmachinepool.infrastructure.cluster.x-k8s.io"
)

// OCIVirtualMachinePoolSpec defines the desired state of an OCI virtual machine pool.
// An OCIVirtualMachinePool translates to an OKE Virtual node poo;.
// The properties are generated from https://docs.oracle.com/en-us/iaas/api/#/en/containerengine/20180222/datatypes/CreateVirtualNodePoolDetails
type OCIVirtualMachinePoolSpec struct {

        // ProviderID is the OCID of the associated NodePool in a provider format
        // +optional
        ProviderID *string `json:"providerID,omitempty"`

        // ID is the OCID of the associated NodePool
        // +optional
        ID *string `json:"id,omitempty"`

        // PlacementConfigs defines the placement configurations for the node pool.
        // +optional
        PlacementConfigs []VirtualNodepoolPlacementConfig `json:"placementConfigs,omitempty"`

        // NsgNames defines the names of NSGs which will be associated with the nodes. the NSGs are defined
        // in OCIManagedCluster object.
        // +optional
        NsgNames []string `json:"nsgNames,omitempty"`

        // PodConfiguration defines pod configuration
        // +optional
        PodConfiguration PodConfig `json:"podConfiguration,omitempty"`

        // Taints describes the taints will be applied to the Virtual Nodes of this Virtual Node Pool for Kubernetes scheduling.
        // +optional
        Taints []Taint `json:"taints,omitempty"`

        // InitialNodeLabels defines a list of key/value pairs to add to nodes after they join the Kubernetes cluster.
        // +optional
        InitialVirtualNodeLabels []KeyValue `json:"initialVirtualNodeLabels,omitempty"`

        // ProviderIDList are the identification IDs of machine instances provided by the provider.
        // This field must match the provider IDs as seen on the node objects corresponding to a machine pool's machine instances.
        // +optional
        ProviderIDList []string `json:"providerIDList,omitempty"`
}

// VirtualNodepoolPlacementConfig defines the placement configurations for the virtual node pool.
type VirtualNodepoolPlacementConfig struct {
        // AvailabilityDomain defines the availability domain in which to place nodes.
        // +optional

        AvailabilityDomain *string `json:"availabilityDomain,omitempty"`
        // FaultDomains defines the list of fault domains in which to place nodes.
        // +optional
        FaultDomains []string `json:"faultDomains,omitempty"`

        // SubnetName defines the name of the subnet which need to be associated with the Virtual Node Pool.
        // The subnets are defined in the OCiManagedCluster object.
        // +optional
        SubnetName *string `json:"subnetName,omitempty"`
}

// PodConfig  describes the pod configuration of the virtual node pool.
type PodConfig struct {
        // NsgNames defines the names of NSGs which will be associated with the pods.
        // +optional
        NsgNames []string `json:"nsgNames,omitempty"`

        // Shape described the shape of the pods.
        // +optional
        Shape *string `json:"shape,omitempty"`

        // SubnetName described the regional subnet where pods' VNIC will be placed.
        // +optional
        SubnetName *string `json:"subnetName,omitempty"`
}

// Taint describes a taint.
type Taint struct {
        // The key of the pair.
        Key *string `json:"key,omitempty"`

        // The value of the pair.
        Value *string `json:"value,omitempty"`

        // The effect of the pair.
        Effect *string `json:"effect,omitempty"`
}

// OCIVirtualMachinePoolStatus defines the observed state of OCIVirtualMachinePool
type OCIVirtualMachinePoolStatus struct {
        // +optional
        Ready bool `json:"ready"`
        // NetworkSpec encapsulates all things related to OCI network.
        // +optional
        Conditions clusterv1.Conditions `json:"conditions,omitempty"`

        // Replicas is the most recently observed number of replicas
        // +optional
        Replicas int32 `json:"replicas"`

        // +optional
        NodepoolLifecycleState string `json:"nodepoolLifecycleState,omitempty"`

        // FailureReason will contains the CAPI MachinePoolStatusFailure if the virtual machine pool has hit an error condition.
        // +optional
        FailureReason *errors.MachinePoolStatusFailure `json:"failureReason,omitempty"`

        // FailureMessages contains the verbose erorr messages related to the virtual machine pool failures.
        // +optional
        FailureMessages []string `json:"failureMessages,omitempty"`

        // InfrastructureMachineKind is the kind of the infrastructure resources behind MachinePool Machines.
        // +optional
        InfrastructureMachineKind string `json:"infrastructureMachineKind,omitempty"`
}

//+kubebuilder:object:root=true
//+kubebuilder:subresource:status

// OCIVirtualMachinePool is the Schema for the ocivirtualmachinepool API.
type OCIVirtualMachinePool struct {
        metav1.TypeMeta   `json:",inline"`
        metav1.ObjectMeta `json:"metadata,omitempty"`

        Spec   OCIVirtualMachinePoolSpec   `json:"spec,omitempty"`
        Status OCIVirtualMachinePoolStatus `json:"status,omitempty"`
}

//+kubebuilder:object:root=true

// OCIVirtualMachinePoolList contains a list of OCIVirtualMachinePool.
type OCIVirtualMachinePoolList struct {
        metav1.TypeMeta `json:",inline"`
        metav1.ListMeta `json:"metadata,omitempty"`
        Items           []OCIVirtualMachinePool `json:"items"`
}

// GetConditions returns the list of conditions for an OCIMachine API object.
func (m *OCIVirtualMachinePool) GetConditions() clusterv1.Conditions <span class="cov0" title="0">{
        return m.Status.Conditions
}</span>

// SetConditions will set the given conditions on an OCIMachine object.
func (m *OCIVirtualMachinePool) SetConditions(conditions clusterv1.Conditions) <span class="cov0" title="0">{
        m.Status.Conditions = conditions
}</span>

func init() <span class="cov8" title="1">{
        SchemeBuilder.Register(&amp;OCIVirtualMachinePool{}, &amp;OCIVirtualMachinePoolList{})
}</span>
</pre>
		
		<pre class="file" id="file89" style="display: none">/*
Copyright (c) 2023 Oracle and/or its affiliates.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1beta2

// Hub marks OCIManagedMachinePool as a conversion hub.
func (*OCIManagedMachinePool) Hub() {<span class="cov0" title="0">}</span>

// Hub marks OCIManagedMachinePoolList as a conversion hub.
func (*OCIManagedMachinePoolList) Hub() {<span class="cov0" title="0">}</span>

// Hub marks OCIMachinePool as a conversion hub.
func (*OCIMachinePool) Hub() {<span class="cov0" title="0">}</span>

// Hub marks OCIMachinePoolList as a conversion hub.
func (*OCIMachinePoolList) Hub() {<span class="cov0" title="0">}</span>

// Hub marks OCIVirtualMachinePool as a conversion hub.
func (*OCIVirtualMachinePool) Hub() {<span class="cov0" title="0">}</span>

// Hub marks OCIVirtualMachinePool as a conversion hub.
func (*OCIVirtualMachinePoolList) Hub() {<span class="cov0" title="0">}</span>

// Hub marks OCIManagedMachinePoolMachine as a conversion hub.
func (*OCIMachinePoolMachine) Hub() {<span class="cov0" title="0">}</span>

// Hub marks OCIManagedMachinePoolMachineList as a conversion hub.
func (*OCIMachinePoolMachineList) Hub() {<span class="cov0" title="0">}</span>
</pre>
		
		<pre class="file" id="file90" style="display: none">/*
Copyright (c) 2022 Oracle and/or its affiliates.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1beta2

import (
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        clusterv1 "sigs.k8s.io/cluster-api/api/core/v1beta1"
)

// +kubebuilder:object:generate=true
// +groupName=infrastructure.cluster.x-k8s.io

const (
        Managed     MachineTypeEnum = "MANAGED_TYPE"
        Virtual     MachineTypeEnum = "VIRTUAL_TYPE"
        SelfManaged MachineTypeEnum = "SELF_MANAGED_TYPE"
        // MachinePoolMachineFinalizer is the finalizer for managed machine pool.
        MachinePoolMachineFinalizer = "ocimachinepoolmachine.infrastructure.cluster.x-k8s.io"
)

type MachineTypeEnum string

// OCIMachinePoolMachineSpec defines the desired state of OCIMachinePoolMachine
type OCIMachinePoolMachineSpec struct {
        // ProviderID is Oracle Cloud Identifier of the associated instance.
        // +optional
        ProviderID *string `json:"providerID,omitempty"`

        // OCID is the OCID of the associated instance.
        // +optional
        OCID *string `json:"ocid,omitempty"`

        // InstanceName is the name of the instance.
        // +optional
        InstanceName *string `json:"instanceName,omitempty"`

        // MachineType is the type of the machine.
        MachineType MachineTypeEnum `json:"machineType,omitempty"`
}

// OCIMachinePoolMachineStatus defines the observed state of OCIMachinePoolMachine
type OCIMachinePoolMachineStatus struct {
        // Flag set to true when machine is ready.
        // +optional
        Ready bool `json:"ready,omitempty"`

        // Conditions defines current service state of the OCIMachinePool.
        // +optional
        Conditions clusterv1.Conditions `json:"conditions,omitempty"`
}

//+kubebuilder:object:root=true
//+kubebuilder:subresource:status
// +kubebuilder:storageversion

type OCIMachinePoolMachine struct {
        metav1.TypeMeta   `json:",inline"`
        metav1.ObjectMeta `json:"metadata,omitempty"`

        Spec   OCIMachinePoolMachineSpec   `json:"spec,omitempty"`
        Status OCIMachinePoolMachineStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true
// +kubebuilder:storageversion

// OCIMachinePoolMachineList contains a list of OCIMachinePoolMachine.
type OCIMachinePoolMachineList struct {
        metav1.TypeMeta `json:",inline"`
        metav1.ListMeta `json:"metadata,omitempty"`
        Items           []OCIMachinePoolMachine `json:"items"`
}

func init() <span class="cov8" title="1">{
        SchemeBuilder.Register(&amp;OCIMachinePoolMachine{}, &amp;OCIMachinePoolMachineList{})
}</span>
</pre>
		
		<pre class="file" id="file91" style="display: none">/*
Copyright (c) 2022 Oracle and/or its affiliates.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1beta2

import (
        infrastructurev1beta2 "github.com/oracle/cluster-api-provider-oci/api/v1beta2"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        clusterv1 "sigs.k8s.io/cluster-api/api/core/v1beta1"
)

// +kubebuilder:object:generate=true
// +groupName=infrastructure.cluster.x-k8s.io

const (
        // MachinePoolFinalizer is the finalizer for the machine pool.
        MachinePoolFinalizer = "ocimachinepool.infrastructure.cluster.x-k8s.io"
)

// OCIMachinePoolSpec defines the desired state of OCIMachinePool
type OCIMachinePoolSpec struct {
        // ProviderID is the OCID of the associated InstancePool in a provider format
        // +optional
        ProviderID *string `json:"providerID,omitempty"`

        // OCID is the OCID of the associated InstancePool
        // +optional
        OCID *string `json:"ocid,omitempty"`

        // PlacementDetails defines the placement details of the instance pool.
        PlacementDetails []PlacementDetails `json:"placementDetails,omitempty"`

        // InstanceConfiguration defines the configuration of the instance pool instances.
        InstanceConfiguration InstanceConfiguration `json:"instanceConfiguration,omitempty"`

        // ProviderIDList are the identification IDs of machine instances provided by the provider.
        // This field must match the provider IDs as seen on the node objects corresponding to a machine pool's machine instances.
        // +optional
        ProviderIDList []string `json:"providerIDList,omitempty"`
}

type InstanceConfiguration struct {
        InstanceConfigurationId *string `json:"instanceConfigurationId,omitempty"`
        Shape                   *string `json:"shape,omitempty"`
        // The shape configuration of the instance, applicable for flex instances.
        ShapeConfig *ShapeConfig `json:"shapeConfig,omitempty"`

        InstanceVnicConfiguration *infrastructurev1beta2.NetworkDetails `json:"instanceVnicConfiguration,omitempty"`

        // PlatformConfig defines the platform config parameters
        PlatformConfig *infrastructurev1beta2.PlatformConfig `json:"platformConfig,omitempty"`

        // AgentConfig defines the options for the Oracle Cloud Agent software running on the instance.
        AgentConfig *infrastructurev1beta2.LaunchInstanceAgentConfig `json:"agentConfig,omitempty"`

        // PreemptibleInstanceConfig Configuration options for preemptible instances.
        PreemptibleInstanceConfig *infrastructurev1beta2.PreemptibleInstanceConfig `json:"preemptibleInstanceConfig,omitempty"`

        // LaunchInstanceAvailabilityConfig defines the options for VM migration during infrastructure maintenance events and for defining
        // the availability of a VM instance after a maintenance event that impacts the underlying hardware.
        AvailabilityConfig *infrastructurev1beta2.LaunchInstanceAvailabilityConfig `json:"availabilityConfig,omitempty"`

        // DedicatedVmHostId defines the OCID of the dedicated VM host.
        DedicatedVmHostId *string `json:"dedicatedVmHostId,omitempty"`

        // LaunchOptions defines the options for tuning the compatibility and performance of VM shapes
        LaunchOptions *infrastructurev1beta2.LaunchOptions `json:"launchOptions,omitempty"`

        // InstanceOptions defines the instance options
        InstanceOptions *infrastructurev1beta2.InstanceOptions `json:"instanceOptions,omitempty"`

        // Is in transit encryption of volumes required.
        // +optional
        IsPvEncryptionInTransitEnabled *bool `json:"isPvEncryptionInTransitEnabled,omitempty"`

        // InstanceSourceViaImageConfig defines the options for booting up instances via images
        InstanceSourceViaImageDetails *InstanceSourceViaImageConfig `json:"instanceSourceViaImageConfig,omitempty"`

        // CapacityReservationId defines the OCID of the compute capacity reservation this instance is launched under.
        // You can opt out of all default reservations by specifying an empty string as input for this field.
        // For more information, see Capacity Reservations (https://docs.cloud.oracle.com/iaas/Content/Compute/Tasks/reserve-capacity.htm#default).
        CapacityReservationId *string `json:"capacityReservationId,omitempty"`

        // Custom metadata key/value pairs that you provide, such as the SSH public key
        // required to connect to the instance.
        Metadata map[string]string `json:"metadata,omitempty"`
}

type PlacementDetails struct {
        // The availability domain to place instances.
        AvailabilityDomain int `mandatory:"true" json:"availabilityDomain"`
}

// LaunchDetails Instance launch details for creating an instance from an instance configuration
// https://docs.oracle.com/en-us/iaas/api/#/en/iaas/20160918/datatypes/InstanceConfigurationLaunchInstanceDetails
type LaunchDetails struct {
        // Custom metadata key/value pairs that you provide, such as the SSH public key
        // required to connect to the instance.
        Metadata map[string]string `json:"metadata,omitempty"`

        Shape string `json:"shape,omitempty"`
}

// ShapeConfig defines the configuration options for the compute instance shape
// https://docs.oracle.com/en-us/iaas/api/#/en/iaas/20160918/datatypes/LaunchInstanceShapeConfigDetails
type ShapeConfig struct {
        // The total number of OCPUs available to the instance.
        Ocpus *string `json:"ocpus,omitempty"`

        // The total amount of memory available to the instance, in gigabytes.
        MemoryInGBs *string `json:"memoryInGBs,omitempty"`

        // The baseline OCPU utilization for a subcore burstable VM instance. Leave this attribute blank for a
        // non-burstable instance, or explicitly specify non-burstable with `BASELINE_1_1`.
        // The following values are supported:
        // - `BASELINE_1_8` - baseline usage is 1/8 of an OCPU.
        // - `BASELINE_1_2` - baseline usage is 1/2 of an OCPU.
        // - `BASELINE_1_1` - baseline usage is an entire OCPU. This represents a non-burstable instance.
        BaselineOcpuUtilization string `json:"baselineOcpuUtilization,omitempty"`

        // Nvmes defines the number of NVMe drives to be used for storage. A single drive has 6.8 TB available.
        Nvmes *int `json:"nvmes,omitempty"`
}

// InstanceVnicConfiguration defines the configuration options for the network
type InstanceVnicConfiguration struct {

        // AssignPublicIp defines whether the instance should have a public IP address
        AssignPublicIp bool `json:"assignPublicIp,omitempty"`

        // SubnetName defines the subnet name to use for the VNIC
        SubnetName string `json:"subnetName,omitempty"`

        // Deprecated, use         NsgNames parameter to define the NSGs
        NSGId *string `json:"nsgId,omitempty"`

        // SkipSourceDestCheck defines whether the source/destination check is disabled on the VNIC.
        SkipSourceDestCheck *bool `json:"skipSourceDestCheck,omitempty"`

        // NsgNames defines a list of the nsg names of the network security groups (NSGs) to add the VNIC to.
        NsgNames []string `json:"nsgNames,omitempty"`

        // HostnameLabel defines the hostname for the VNIC's primary private IP. Used for DNS.
        HostnameLabel *string `json:"hostnameLabel,omitempty"`

        // DisplayName defines a user-friendly name. Does not have to be unique, and it's changeable.
        // Avoid entering confidential information.
        DisplayName *string `json:"displayName,omitempty"`

        // AssignPrivateDnsRecord defines whether the VNIC should be assigned a DNS record.
        AssignPrivateDnsRecord *bool `json:"assignPrivateDnsRecord,omitempty"`
}

// InstanceSourceViaImageConfig The configuration options for booting up instances via images
type InstanceSourceViaImageConfig struct {
        // OCID of the image to be used to launch the instance.
        ImageId *string `json:"imageId,omitempty"`

        // KmsKeyId defines the OCID of the Key Management key to assign as the master encryption key for the boot volume.
        KmsKeyId *string `json:"kmsKeyId,omitempty"`

        // The size of boot volume. Please see https://docs.oracle.com/en-us/iaas/Content/Block/Tasks/extendingbootpartition.htm
        // to extend the boot volume size.
        BootVolumeSizeInGBs *int64 `json:"bootVolumeSizeInGBs,omitempty"`

        // BootVolumeVpusPerGB defines the number of volume performance units (VPUs) that will be applied to this volume per GB,
        // representing the Block Volume service's elastic performance options.
        // See Block Volume Performance Levels (https://docs.cloud.oracle.com/iaas/Content/Block/Concepts/blockvolumeperformance.htm#perf_levels) for more information.
        // Allowed values:
        //   * `10`: Represents Balanced option.
        //   * `20`: Represents Higher Performance option.
        //   * `30`-`120`: Represents the Ultra High Performance option.
        // For volumes with the auto-tuned performance feature enabled, this is set to the default (minimum) VPUs/GB.
        BootVolumeVpusPerGB *int64 `json:"bootVolumeVpusPerGB,omitempty"`
}

// OCIMachinePoolStatus defines the observed state of OCIMachinePool
type OCIMachinePoolStatus struct {
        // Ready is true when the provider resource is ready.
        // +optional
        Ready bool `json:"ready"`

        // Replicas is the most recently observed number of replicas
        // +optional
        Replicas int32 `json:"replicas"`

        // Conditions defines current service state of the OCIMachinePool.
        // +optional
        Conditions clusterv1.Conditions `json:"conditions,omitempty"`

        FailureReason *string `json:"failureReason,omitempty"`

        FailureMessage *string `json:"failureMessage,omitempty"`

        // InfrastructureMachineKind is the kind of the infrastructure resources behind MachinePool Machines.
        // +optional
        InfrastructureMachineKind string `json:"infrastructureMachineKind,omitempty"`
}

//+kubebuilder:object:root=true
//+kubebuilder:subresource:status
// +kubebuilder:storageversion

type OCIMachinePool struct {
        metav1.TypeMeta   `json:",inline"`
        metav1.ObjectMeta `json:"metadata,omitempty"`

        Spec   OCIMachinePoolSpec   `json:"spec,omitempty"`
        Status OCIMachinePoolStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true
// +kubebuilder:storageversion

// OCIMachinePoolList contains a list of OCIMachinePool.
type OCIMachinePoolList struct {
        metav1.TypeMeta `json:",inline"`
        metav1.ListMeta `json:"metadata,omitempty"`
        Items           []OCIMachinePool `json:"items"`
}

// GetConditions returns the list of conditions for an OCIMachine API object.
func (m *OCIMachinePool) GetConditions() clusterv1.Conditions <span class="cov0" title="0">{
        return m.Status.Conditions
}</span>

// SetConditions will set the given conditions on an OCIMachine object.
func (m *OCIMachinePool) SetConditions(conditions clusterv1.Conditions) <span class="cov0" title="0">{
        m.Status.Conditions = conditions
}</span>

func init() <span class="cov8" title="1">{
        SchemeBuilder.Register(&amp;OCIMachinePool{}, &amp;OCIMachinePoolList{})
}</span>
</pre>
		
		<pre class="file" id="file92" style="display: none">package v1beta2

import (
        infrastructurev1beta2 "github.com/oracle/cluster-api-provider-oci/api/v1beta2"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        clusterv1 "sigs.k8s.io/cluster-api/api/core/v1beta1"
)

const (
        // ManagedMachinePoolFinalizer is the finalizer for managed machine pool.
        ManagedMachinePoolFinalizer = "ocimanagedmachinepool.infrastructure.cluster.x-k8s.io"
)

// OCIManagedMachinePoolSpec defines the desired state of an OCI managed machine pool.
// An OCIManagedMachinePool translates to an OKE NodePool.
// The properties are generated from https://docs.oracle.com/en-us/iaas/api/#/en/containerengine/20180222/datatypes/CreateNodePoolDetails
type OCIManagedMachinePoolSpec struct {

        // ProviderID is the OCID of the associated NodePool in a provider format
        // +optional
        ProviderID *string `json:"providerID,omitempty"`

        // Version represents the version of the OKE node pool.
        Version *string `json:"version,omitempty"`

        // ID is the OCID of the associated NodePool
        // +optional
        ID *string `json:"id,omitempty"`

        // NodePoolNodeConfig defines the configuration of nodes in the node pool.
        // +optional
        NodePoolNodeConfig *NodePoolNodeConfig `json:"nodePoolNodeConfig,omitempty"`

        // NodeEvictionNodePoolSettings defines the eviction settings.
        // +optional
        NodeEvictionNodePoolSettings *NodeEvictionNodePoolSettings `json:"nodeEvictionNodePoolSettings,omitempty"`

        // NodeShape defines the name of the node shape of the nodes in the node pool.
        // +optional
        NodeShape string `json:"nodeShape,omitempty"`

        // NodeShapeConfig defines the configuration of the shape to launch nodes in the node pool.
        // +optional
        NodeShapeConfig *NodeShapeConfig `json:"nodeShapeConfig,omitempty"`

        // NodeSourceViaImage defines the image configuration of the nodes in the nodepool.
        // +optional
        NodeSourceViaImage *NodeSourceViaImage `json:"nodeSourceViaImage,omitempty"`

        // SshPublicKey defines the SSH public key on each node in the node pool on launch.
        // +optional
        SshPublicKey string `json:"sshPublicKey,omitempty"`

        // NodeMetadata defines a list of key/value pairs to add to each underlying OCI instance in the node pool on launch.
        // +optional
        NodeMetadata map[string]string `json:"nodeMetadata,omitempty"`

        // InitialNodeLabels defines a list of key/value pairs to add to nodes after they join the Kubernetes cluster.
        // +optional
        InitialNodeLabels []KeyValue `json:"initialNodeLabels,omitempty"`

        // NodePoolCyclingDetails defines the node pool recycling options.
        // +optional
        NodePoolCyclingDetails *NodePoolCyclingDetails `json:"nodePoolCyclingDetails,omitempty"`

        // ProviderIDList are the identification IDs of machine instances provided by the provider.
        // This field must match the provider IDs as seen on the node objects corresponding to a machine pool's machine instances.
        // +optional
        ProviderIDList []string `json:"providerIDList,omitempty"`
}

// NodePoolNodeConfig describes the configuration of nodes in the node pool.
type NodePoolNodeConfig struct {
        // IsPvEncryptionInTransitEnabled defines whether in transit encryption should be enabled on the nodes.
        // +optional
        IsPvEncryptionInTransitEnabled *bool `json:"isPvEncryptionInTransitEnabled,omitempty"`

        // KmsKeyId  defines whether in transit encryption should be enabled on the nodes.
        // +optional
        KmsKeyId *string `json:"kmsKeyId,omitempty"`

        // PlacementConfigs defines the placement configurations for the node pool.
        // +optional
        PlacementConfigs []PlacementConfig `json:"placementConfigs,omitempty"`

        // NsgNames defines the names of NSGs which will be associated with the nodes. the NSGs are defined
        // in OCIManagedCluster object.
        // +optional
        NsgNames []string `json:"nsgNames,omitempty"`

        // NodePoolPodNetworkOptionDetails defines the pod networking details of the node pool
        // +optional
        NodePoolPodNetworkOptionDetails *NodePoolPodNetworkOptionDetails `json:"nodePoolPodNetworkOptionDetails,omitempty"`
}

// NodePoolPodNetworkOptionDetails describes the CNI related configuration of pods in the node pool.
type NodePoolPodNetworkOptionDetails struct {

        // CniType describes the CNI plugin used by this node pool. Allowed values are OCI_VCN_IP_NATIVE and FLANNEL_OVERLAY.
        // +optional
        CniType infrastructurev1beta2.CNIOptionEnum `json:"cniType,omitempty"`

        // VcnIpNativePodNetworkOptions describes the network options specific to using the OCI VCN Native CNI
        // +optional
        VcnIpNativePodNetworkOptions VcnIpNativePodNetworkOptions `json:"vcnIpNativePodNetworkOptions,omitempty"`
}

// VcnIpNativePodNetworkOptions defines the Network options specific to using the OCI VCN Native CNI
type VcnIpNativePodNetworkOptions struct {

        // MemoryInGBs defines the max number of pods per node in the node pool. This value will be limited by the
        // number of VNICs attachable to the node pool shape
        // +optional
        MaxPodsPerNode *int `json:"maxPodsPerNode,omitempty"`

        // NSGNames defines the NSGs associated with the native pod network.
        // +optional
        NSGNames []string `json:"nsgNames,omitempty"`

        // SubnetNames defines the Subnets associated with the native pod network.
        // +optional
        SubnetNames []string `json:"subnetNames,omitempty"`
}

// PlacementConfig defines the placement configurations for the node pool.
type PlacementConfig struct {
        // AvailabilityDomain defines the availability domain in which to place nodes.
        // +optional
        AvailabilityDomain *string `json:"availabilityDomain,omitempty"`

        // CapacityReservationId defines the OCID of the compute capacity reservation in which to place the compute instance.
        // +optional
        CapacityReservationId *string `json:"capacityReservationId,omitempty"`

        // FaultDomains defines the list of fault domains in which to place nodes.
        // +optional
        FaultDomains []string `json:"faultDomains,omitempty"`

        // SubnetName defines the name of the subnet which need ot be associated with the Nodepool.
        // The subnets are defined in the OCiManagedCluster object.
        // +optional
        SubnetName *string `json:"subnetName,omitempty"`
}

// NodeEvictionNodePoolSettings defines the Node Eviction Details configuration.
type NodeEvictionNodePoolSettings struct {

        // EvictionGraceDuration defines the duration after which OKE will give up eviction of the pods on the node. PT0M will indicate you want to delete the node without cordon and drain. Default PT60M, Min PT0M, Max: PT60M. Format ISO 8601 e.g PT30M
        // +optional
        EvictionGraceDuration *string `json:"evictionGraceDuration,omitempty"`

        // IsForceDeleteAfterGraceDuration defines if the underlying compute instance should be deleted if you cannot evict all the pods in grace period
        // +optional
        IsForceDeleteAfterGraceDuration *bool `json:"isForceDeleteAfterGraceDuration,omitempty"`
}

// NodeShapeConfig defines the shape configuration of the nodes.
type NodeShapeConfig struct {

        // MemoryInGBs defines the total amount of memory available to each node, in gigabytes.
        // +optional
        MemoryInGBs *string `json:"memoryInGBs,omitempty"`

        // Ocpus defines the total number of OCPUs available to each node in the node pool.
        // +optional
        Ocpus *string `json:"ocpus,omitempty"`
}

// NodeSourceViaImage defines the Details of the image running on the node.
type NodeSourceViaImage struct {

        // BootVolumeSizeInGBs defines the size of the boot volume in GBs.
        // +optional
        BootVolumeSizeInGBs *int64 `json:"bootVolumeSizeInGBs,omitempty"`

        // ImageId defines the OCID of the image used to boot the node.
        // +optional
        ImageId *string `json:"imageId,omitempty"`
}

// KeyValue The properties that define a key value pair.
type KeyValue struct {

        // The key of the pair.
        Key *string `json:"key,omitempty"`

        // The value of the pair.
        Value *string `json:"value,omitempty"`
}

// NodePoolCyclingDetails defines the node pool recycling options
type NodePoolCyclingDetails struct {

        // IsNodeCyclingEnabled refers if nodes in the nodepool will be cycled to have new changes.
        // +optional
        IsNodeCyclingEnabled *bool `json:"isNodeCyclingEnabled,omitempty"`

        // MaximumSurge refers to the maximum additional new compute instances that would be temporarily created and
        // added to nodepool during the cycling nodepool process. OKE supports both integer and percentage input.
        // Defaults to 1, Ranges from 0 to Nodepool size or 0% to 100%
        // +optional
        MaximumSurge *string `json:"maximumSurge,omitempty"`

        // Maximum active nodes that would be terminated from nodepool during the cycling nodepool process.
        // OKE supports both integer and percentage input. Defaults to 0, Ranges from 0 to Nodepool size or 0% to 100%
        // +optional
        MaximumUnavailable *string `json:"maximumUnavailable,omitempty"`
}

// OCIManagedMachinePoolStatus defines the observed state of OCIManagedMachinePool
type OCIManagedMachinePoolStatus struct {
        // +optional
        Ready bool `json:"ready"`
        // NetworkSpec encapsulates all things related to OCI network.
        // +optional
        Conditions clusterv1.Conditions `json:"conditions,omitempty"`

        // +optional
        NodepoolLifecycleState string `json:"nodepoolLifecycleState,omitempty"`

        // Replicas is the most recently observed number of replicas
        // +optional
        Replicas int32 `json:"replicas"`

        FailureReason *string `json:"failureReason,omitempty"`

        FailureMessages []string `json:"failureMessages,omitempty"`

        // InfrastructureMachineKind is the kind of the infrastructure resources behind MachinePool Machines.
        // +optional
        InfrastructureMachineKind string `json:"infrastructureMachineKind,omitempty"`
}

//+kubebuilder:object:root=true
//+kubebuilder:subresource:status
// +kubebuilder:storageversion

// OCIManagedMachinePool is the Schema for the ocimanagedmachinepool API.
type OCIManagedMachinePool struct {
        metav1.TypeMeta   `json:",inline"`
        metav1.ObjectMeta `json:"metadata,omitempty"`

        Spec   OCIManagedMachinePoolSpec   `json:"spec,omitempty"`
        Status OCIManagedMachinePoolStatus `json:"status,omitempty"`
}

//+kubebuilder:object:root=true
// +kubebuilder:storageversion

// OCIManagedMachinePoolList contains a list of OCIManagedMachinePool.
type OCIManagedMachinePoolList struct {
        metav1.TypeMeta `json:",inline"`
        metav1.ListMeta `json:"metadata,omitempty"`
        Items           []OCIManagedMachinePool `json:"items"`
}

// GetConditions returns the list of conditions for an OCIMachine API object.
func (m *OCIManagedMachinePool) GetConditions() clusterv1.Conditions <span class="cov0" title="0">{
        return m.Status.Conditions
}</span>

// SetConditions will set the given conditions on an OCIMachine object.
func (m *OCIManagedMachinePool) SetConditions(conditions clusterv1.Conditions) <span class="cov0" title="0">{
        m.Status.Conditions = conditions
}</span>

func init() <span class="cov8" title="1">{
        SchemeBuilder.Register(&amp;OCIManagedMachinePool{}, &amp;OCIManagedMachinePoolList{})
}</span>
</pre>
		
		<pre class="file" id="file93" style="display: none">/*
Copyright (c) 2021, 2022 Oracle and/or its affiliates.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1beta2

import (
        "context"
        "fmt"
        "reflect"

        infrastructurev1beta2 "github.com/oracle/cluster-api-provider-oci/api/v1beta2"
        apierrors "k8s.io/apimachinery/pkg/api/errors"
        "k8s.io/apimachinery/pkg/runtime"
        "k8s.io/apimachinery/pkg/util/validation/field"
        "sigs.k8s.io/cluster-api/util/version"
        ctrl "sigs.k8s.io/controller-runtime"
        "sigs.k8s.io/controller-runtime/pkg/webhook"
        "sigs.k8s.io/controller-runtime/pkg/webhook/admission"
)

var logger = ctrl.Log.WithName("ocimachinepool-resource")

type OCIManagedMachinePoolWebhook struct{}

var (
        _ webhook.CustomDefaulter = &amp;OCIManagedMachinePoolWebhook{}
        _ webhook.CustomValidator = &amp;OCIManagedMachinePoolWebhook{}
)

// +kubebuilder:webhook:verbs=create;update,path=/validate-infrastructure-cluster-x-k8s-io-v1beta2-ocimanagedmachinepool,mutating=false,failurePolicy=fail,matchPolicy=Equivalent,groups=infrastructure.cluster.x-k8s.io,resources=ocimanagedmachinepools,versions=v1beta2,name=validation.ocimanagedmachinepool.infrastructure.cluster.x-k8s.io,sideEffects=None,admissionReviewVersions=v1beta1
// +kubebuilder:webhook:verbs=create;update,path=/mutate-infrastructure-cluster-x-k8s-io-v1beta2-ocimanagedmachinepool,mutating=true,failurePolicy=fail,matchPolicy=Equivalent,groups=infrastructure.cluster.x-k8s.io,resources=ocimanagedmachinepools,versions=v1beta2,name=default.ocimanagedmachinepool.infrastructure.cluster.x-k8s.io,sideEffects=None,admissionReviewVersions=v1beta1

func (m *OCIManagedMachinePool) SetupWebhookWithManager(mgr ctrl.Manager) error <span class="cov0" title="0">{
        w := new(OCIManagedMachinePoolWebhook)
        return ctrl.NewWebhookManagedBy(mgr).
                For(m).
                WithDefaulter(w).
                WithValidator(w).
                Complete()
}</span>

func (*OCIManagedMachinePoolWebhook) Default(_ context.Context, obj runtime.Object) error <span class="cov8" title="1">{
        m, ok := obj.(*OCIManagedMachinePool)
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("expected an OCIManagedMachinePool object but got %T", m)
        }</span>

        <span class="cov8" title="1">if m.Spec.NodePoolNodeConfig == nil </span><span class="cov8" title="1">{
                m.Spec.NodePoolNodeConfig = &amp;NodePoolNodeConfig{}
        }</span>
        <span class="cov8" title="1">if m.Spec.NodePoolNodeConfig.NodePoolPodNetworkOptionDetails == nil </span><span class="cov8" title="1">{
                m.Spec.NodePoolNodeConfig.NodePoolPodNetworkOptionDetails = &amp;NodePoolPodNetworkOptionDetails{
                        CniType: infrastructurev1beta2.VCNNativeCNI,
                        VcnIpNativePodNetworkOptions: VcnIpNativePodNetworkOptions{
                                SubnetNames: []string{PodDefaultName},
                                NSGNames:    []string{PodDefaultName},
                        },
                }
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (*OCIManagedMachinePoolWebhook) ValidateCreate(_ context.Context, obj runtime.Object) (admission.Warnings, error) <span class="cov8" title="1">{
        m, ok := obj.(*OCIManagedMachinePool)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("expected an OCIManagedMachinePool object but got %T", m)
        }</span>

        <span class="cov8" title="1">var allErrs field.ErrorList
        if len(m.Name) &gt; 31 </span><span class="cov8" title="1">{
                allErrs = append(allErrs, field.Invalid(field.NewPath("Name"), m.Name, "Name cannot be more than 31 characters"))
        }</span>
        <span class="cov8" title="1">allErrs = m.validateVersion(allErrs)
        if len(allErrs) == 0 </span><span class="cov8" title="1">{
                return nil, nil
        }</span>
        <span class="cov8" title="1">return nil, apierrors.NewInvalid(m.GroupVersionKind().GroupKind(), m.Name, allErrs)</span>
}

func (m *OCIManagedMachinePool) validateVersion(allErrs field.ErrorList) field.ErrorList <span class="cov8" title="1">{
        if m.Spec.Version == nil </span><span class="cov8" title="1">{
                allErrs = append(
                        allErrs,
                        field.Invalid(field.NewPath("spec", "version"), m.Spec.Version, "field is required"))
        }</span>
        <span class="cov8" title="1">if m.Spec.Version != nil </span><span class="cov8" title="1">{
                if !version.KubeSemver.MatchString(*m.Spec.Version) </span><span class="cov8" title="1">{
                        allErrs = append(
                                allErrs,
                                field.Invalid(field.NewPath("spec", "version"), m.Spec.Version, "must be a valid semantic version"))
                }</span>
        }
        <span class="cov8" title="1">return allErrs</span>
}

func (*OCIManagedMachinePoolWebhook) ValidateUpdate(_ context.Context, oldRaw, newObj runtime.Object) (admission.Warnings, error) <span class="cov8" title="1">{
        m, ok := newObj.(*OCIManagedMachinePool)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("expected an OCIManagedMachinePool object but got %T", m)
        }</span>

        <span class="cov8" title="1">var allErrs field.ErrorList
        var warnings admission.Warnings

        oldManagedMachinePool, ok := oldRaw.(*OCIManagedMachinePool)
        if !ok </span><span class="cov0" title="0">{
                return nil, apierrors.NewBadRequest(fmt.Sprintf("expected an OCIManagedMachinePool but got a %T", oldRaw))
        }</span>

        <span class="cov8" title="1">allErrs = m.validateVersion(allErrs)

        if !reflect.DeepEqual(m.Spec.Version, oldManagedMachinePool.Spec.Version) </span><span class="cov8" title="1">{
                newImage := m.getImageId()
                oldImage := oldManagedMachinePool.getImageId()

                if newImage != nil &amp;&amp; reflect.DeepEqual(newImage, oldImage) </span><span class="cov8" title="1">{
                        // if an image has been provided in updated machine pool and it matches old image id,
                        // and if Kubernetes version has been updated, that means that it might be a custom image.
                        // This allows the use of custom images that support multiple Kubernetes versions. If the image is not a custom image
                        // then the image should have been updated by the user, or set as nil in which case
                        // CAPOCI will lookup a correct image.
                        warnMsg := fmt.Sprintf("Kubernetes version was updated from %q to %q without changing the imageId. "+
                                "If you are not using a custom multi-version image, this may cause nodepool creation to fail.",
                                *oldManagedMachinePool.Spec.Version, *m.Spec.Version)
                        warnings = append(warnings, warnMsg)
                }</span>
        }

        // If there are any hard errors (like an invalid version format), return them.
        // Also return the list of accumulated warnings.
        <span class="cov8" title="1">if len(allErrs) &gt; 0 </span><span class="cov8" title="1">{
                return warnings, apierrors.NewInvalid(m.GroupVersionKind().GroupKind(), m.Name, allErrs)
        }</span>

        // If there are no errors, return the warnings.
        <span class="cov8" title="1">return warnings, nil</span>
}

func (*OCIManagedMachinePoolWebhook) ValidateDelete(_ context.Context, obj runtime.Object) (admission.Warnings, error) <span class="cov0" title="0">{
        return nil, nil
}</span>

func (m *OCIManagedMachinePool) getImageId() *string <span class="cov8" title="1">{
        if m.Spec.NodeSourceViaImage != nil </span><span class="cov8" title="1">{
                return m.Spec.NodeSourceViaImage.ImageId
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file94" style="display: none">/*
Copyright (c) 2022, Oracle and/or its affiliates.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1beta2

import (
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

// OCIManagedMachinePoolTemplateSpec defines the desired state of OCIManagedMachinePoolTemplate.
type OCIManagedMachinePoolTemplateSpec struct {
        Template OCIManagedMachinePoolTemplateResource `json:"template"`
}

// +kubebuilder:object:root=true
// +kubebuilder:resource:path=ocimanagedmachinepooltemplates,scope=Namespaced,categories=cluster-api
// +kubebuilder:storageversion

// OCIManagedMachinePoolTemplate is the Schema for the OCIManagedMachinePoolTemplates API.
type OCIManagedMachinePoolTemplate struct {
        metav1.TypeMeta   `json:",inline"`
        metav1.ObjectMeta `json:"metadata,omitempty"`

        Spec OCIManagedMachinePoolTemplateSpec `json:"spec,omitempty"`
}

// +kubebuilder:object:root=true
// +kubebuilder:storageversion

// OCIManagedMachinePoolTemplateList contains a list of OCIManagedMachinePoolTemplate.
type OCIManagedMachinePoolTemplateList struct {
        metav1.TypeMeta `json:",inline"`
        metav1.ListMeta `json:"metadata,omitempty"`

        Items []OCIManagedMachinePoolTemplate `json:"items"`
}

func init() <span class="cov8" title="1">{
        SchemeBuilder.Register(&amp;OCIManagedMachinePoolTemplate{}, &amp;OCIManagedMachinePoolTemplateList{})
}</span>

// OCIManagedMachinePoolSpec describes the data needed to create an OCIManagedMachinePool from a template.
type OCIManagedMachinePoolTemplateResource struct {
        Spec OCIManagedMachinePoolSpec `json:"spec"`
}
</pre>
		
		<pre class="file" id="file95" style="display: none">package v1beta2

import (
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        clusterv1 "sigs.k8s.io/cluster-api/api/core/v1beta1"
        "sigs.k8s.io/cluster-api/errors"
)

const (
        // VirtualMachinePoolFinalizer is the finalizer for virtual machine pool.
        VirtualMachinePoolFinalizer = "ocivirtualmachinepool.infrastructure.cluster.x-k8s.io"
)

// OCIVirtualMachinePoolSpec defines the desired state of an OCI virtual machine pool.
// An OCIVirtualMachinePool translates to an OKE Virtual node poo;.
// The properties are generated from https://docs.oracle.com/en-us/iaas/api/#/en/containerengine/20180222/datatypes/CreateVirtualNodePoolDetails
type OCIVirtualMachinePoolSpec struct {

        // ProviderID is the OCID of the associated NodePool in a provider format
        // +optional
        ProviderID *string `json:"providerID,omitempty"`

        // ID is the OCID of the associated NodePool
        // +optional
        ID *string `json:"id,omitempty"`

        // PlacementConfigs defines the placement configurations for the node pool.
        // +optional
        PlacementConfigs []VirtualNodepoolPlacementConfig `json:"placementConfigs,omitempty"`

        // NsgNames defines the names of NSGs which will be associated with the nodes. the NSGs are defined
        // in OCIManagedCluster object.
        // +optional
        NsgNames []string `json:"nsgNames,omitempty"`

        // PodConfiguration defines pod configuration
        // +optional
        PodConfiguration PodConfig `json:"podConfiguration,omitempty"`

        // Taints describes the taints will be applied to the Virtual Nodes of this Virtual Node Pool for Kubernetes scheduling.
        // +optional
        Taints []Taint `json:"taints,omitempty"`

        // InitialVirtualNodeLabels defines a list of key/value pairs to add to nodes after they join the Kubernetes cluster.
        // +optional
        InitialVirtualNodeLabels []KeyValue `json:"initialVirtualNodeLabels,omitempty"`

        // ProviderIDList are the identification IDs of machine instances provided by the provider.
        // This field must match the provider IDs as seen on the node objects corresponding to a machine pool's machine instances.
        // +optional
        ProviderIDList []string `json:"providerIDList,omitempty"`
}

// VirtualNodepoolPlacementConfig defines the placement configurations for the virtual node pool.
type VirtualNodepoolPlacementConfig struct {
        // AvailabilityDomain defines the availability domain in which to place nodes.
        // +optional

        AvailabilityDomain *string `json:"availabilityDomain,omitempty"`
        // FaultDomains defines the list of fault domains in which to place nodes.
        // +optional
        FaultDomains []string `json:"faultDomains,omitempty"`

        // SubnetName defines the name of the subnet which need to be associated with the Virtual Node Pool.
        // The subnets are defined in the OCiManagedCluster object.
        // +optional
        SubnetName *string `json:"subnetName,omitempty"`
}

// PodConfig  describes the pod configuration of the virtual node pool.
type PodConfig struct {
        // NsgNames defines the names of NSGs which will be associated with the pods.
        // +optional
        NsgNames []string `json:"nsgNames,omitempty"`

        // Shape described the shape of the pods.
        // +optional
        Shape *string `json:"shape,omitempty"`

        // SubnetName described the regional subnet where pods' VNIC will be placed.
        // +optional
        SubnetName *string `json:"subnetName,omitempty"`
}

// Taint describes a taint.
type Taint struct {
        // The key of the pair.
        Key *string `json:"key,omitempty"`

        // The value of the pair.
        Value *string `json:"value,omitempty"`

        // The effect of the pair.
        Effect *string `json:"effect,omitempty"`
}

// OCIVirtualMachinePoolStatus defines the observed state of OCIVirtualMachinePool
type OCIVirtualMachinePoolStatus struct {
        // +optional
        Ready bool `json:"ready"`
        // NetworkSpec encapsulates all things related to OCI network.
        // +optional
        Conditions clusterv1.Conditions `json:"conditions,omitempty"`

        // Replicas is the most recently observed number of replicas
        // +optional
        Replicas int32 `json:"replicas"`

        // +optional
        NodepoolLifecycleState string `json:"nodepoolLifecycleState,omitempty"`

        // FailureReason will contains the CAPI MachinePoolStatusFailure if the virtual machine pool has hit an error condition.
        // +optional
        FailureReason *errors.MachinePoolStatusFailure `json:"failureReason,omitempty"`

        // FailureMessages contains the verbose erorr messages related to the virtual machine pool failures.
        // +optional
        FailureMessages []string `json:"failureMessages,omitempty"`

        // InfrastructureMachineKind is the kind of the infrastructure resources behind MachinePool Machines.
        // +optional
        InfrastructureMachineKind string `json:"infrastructureMachineKind,omitempty"`
}

//+kubebuilder:object:root=true
//+kubebuilder:subresource:status
//+kubebuilder:storageversion

// OCIVirtualMachinePool is the Schema for the ocivirtualmachinepool API.
type OCIVirtualMachinePool struct {
        metav1.TypeMeta   `json:",inline"`
        metav1.ObjectMeta `json:"metadata,omitempty"`

        Spec   OCIVirtualMachinePoolSpec   `json:"spec,omitempty"`
        Status OCIVirtualMachinePoolStatus `json:"status,omitempty"`
}

//+kubebuilder:object:root=true

// OCIVirtualMachinePoolList contains a list of OCIVirtualMachinePool.
type OCIVirtualMachinePoolList struct {
        metav1.TypeMeta `json:",inline"`
        metav1.ListMeta `json:"metadata,omitempty"`
        Items           []OCIVirtualMachinePool `json:"items"`
}

// GetConditions returns the list of conditions for an OCIMachine API object.
func (m *OCIVirtualMachinePool) GetConditions() clusterv1.Conditions <span class="cov0" title="0">{
        return m.Status.Conditions
}</span>

// SetConditions will set the given conditions on an OCIMachine object.
func (m *OCIVirtualMachinePool) SetConditions(conditions clusterv1.Conditions) <span class="cov0" title="0">{
        m.Status.Conditions = conditions
}</span>

func init() <span class="cov8" title="1">{
        SchemeBuilder.Register(&amp;OCIVirtualMachinePool{}, &amp;OCIVirtualMachinePoolList{})
}</span>
</pre>
		
		<pre class="file" id="file96" style="display: none">/*
Copyright (c) 2021, 2022 Oracle and/or its affiliates.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1beta2

import (
        "context"
        "fmt"

        "github.com/oracle/oci-go-sdk/v65/common"
        "k8s.io/apimachinery/pkg/runtime"
        ctrl "sigs.k8s.io/controller-runtime"
        "sigs.k8s.io/controller-runtime/pkg/webhook"
        "sigs.k8s.io/controller-runtime/pkg/webhook/admission"
)

var virtualMpLogger = ctrl.Log.WithName("ocivirtualmachinepool-resource")

type OCIVirtualMachinePoolWebhook struct{}

var (
        _ webhook.CustomDefaulter = &amp;OCIVirtualMachinePoolWebhook{}
        _ webhook.CustomValidator = &amp;OCIVirtualMachinePoolWebhook{}
)

// +kubebuilder:webhook:verbs=create;update,path=/validate-infrastructure-cluster-x-k8s-io-v1beta2-ocivirtualmachinepool,mutating=false,failurePolicy=fail,matchPolicy=Equivalent,groups=infrastructure.cluster.x-k8s.io,resources=ocivirtualmachinepools,versions=v1beta2,name=validation.ocivirtualmachinepool.infrastructure.cluster.x-k8s.io,sideEffects=None,admissionReviewVersions=v1beta1
// +kubebuilder:webhook:verbs=create;update,path=/mutate-infrastructure-cluster-x-k8s-io-v1beta2-ocivirtualmachinepool,mutating=true,failurePolicy=fail,matchPolicy=Equivalent,groups=infrastructure.cluster.x-k8s.io,resources=ocivirtualmachinepools,versions=v1beta2,name=default.ocivirtualmachinepool.infrastructure.cluster.x-k8s.io,sideEffects=None,admissionReviewVersions=v1beta1

func (m *OCIVirtualMachinePool) SetupWebhookWithManager(mgr ctrl.Manager) error <span class="cov0" title="0">{
        w := new(OCIVirtualMachinePoolWebhook)
        return ctrl.NewWebhookManagedBy(mgr).
                For(m).
                WithDefaulter(w).
                WithValidator(w).
                Complete()
}</span>

func (*OCIVirtualMachinePoolWebhook) Default(_ context.Context, obj runtime.Object) error <span class="cov0" title="0">{
        m, ok := obj.(*OCIVirtualMachinePool)
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("expected an OCIVirtualMachinePool object but got %T", m)
        }</span>

        <span class="cov0" title="0">if m.Spec.PodConfiguration.NsgNames == nil </span><span class="cov0" title="0">{
                m.Spec.PodConfiguration.NsgNames = []string{PodDefaultName}
        }</span>
        <span class="cov0" title="0">if m.Spec.PodConfiguration.SubnetName == nil </span><span class="cov0" title="0">{
                m.Spec.PodConfiguration.SubnetName = common.String(PodDefaultName)
        }</span>
        <span class="cov0" title="0">if m.Spec.PodConfiguration.Shape == nil </span><span class="cov0" title="0">{
                m.Spec.PodConfiguration.Shape = common.String("Pod.Standard.E4.Flex")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (*OCIVirtualMachinePoolWebhook) ValidateCreate(_ context.Context, obj runtime.Object) (admission.Warnings, error) <span class="cov0" title="0">{
        return nil, nil
}</span>

func (*OCIVirtualMachinePoolWebhook) ValidateUpdate(_ context.Context, oldRaw, newObj runtime.Object) (admission.Warnings, error) <span class="cov0" title="0">{
        return nil, nil
}</span>

func (*OCIVirtualMachinePoolWebhook) ValidateDelete(_ context.Context, obj runtime.Object) (admission.Warnings, error) <span class="cov0" title="0">{
        return nil, nil
}</span>
</pre>
		
		<pre class="file" id="file97" style="display: none">/*
Copyright (c) 2021, 2022 Oracle and/or its affiliates.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package controllers

import (
        "context"
        "fmt"
        "time"

        "github.com/go-logr/logr"
        infrastructurev1beta2 "github.com/oracle/cluster-api-provider-oci/api/v1beta2"
        "github.com/oracle/cluster-api-provider-oci/cloud/ociutil"
        "github.com/oracle/cluster-api-provider-oci/cloud/scope"
        cloudutil "github.com/oracle/cluster-api-provider-oci/cloud/util"
        expV1Beta1 "github.com/oracle/cluster-api-provider-oci/exp/api/v1beta1"
        infrav2exp "github.com/oracle/cluster-api-provider-oci/exp/api/v1beta2"
        "github.com/oracle/oci-go-sdk/v65/common"
        "github.com/oracle/oci-go-sdk/v65/core"
        "github.com/pkg/errors"
        corev1 "k8s.io/api/core/v1"
        apierrors "k8s.io/apimachinery/pkg/api/errors"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/runtime"
        "k8s.io/apimachinery/pkg/runtime/schema"
        "k8s.io/client-go/tools/record"
        clusterv1 "sigs.k8s.io/cluster-api/api/core/v1beta1"
        expclusterv1 "sigs.k8s.io/cluster-api/api/core/v1beta1"
        "sigs.k8s.io/cluster-api/util"
        "sigs.k8s.io/cluster-api/util/annotations"
        "sigs.k8s.io/cluster-api/util/deprecated/v1beta1/conditions"
        "sigs.k8s.io/cluster-api/util/predicates"
        ctrl "sigs.k8s.io/controller-runtime"
        "sigs.k8s.io/controller-runtime/pkg/builder"
        "sigs.k8s.io/controller-runtime/pkg/client"
        "sigs.k8s.io/controller-runtime/pkg/client/apiutil"
        "sigs.k8s.io/controller-runtime/pkg/controller"
        "sigs.k8s.io/controller-runtime/pkg/controller/controllerutil"
        "sigs.k8s.io/controller-runtime/pkg/handler"
        "sigs.k8s.io/controller-runtime/pkg/log"
        "sigs.k8s.io/controller-runtime/pkg/reconcile"
)

// OCIMachinePoolReconciler reconciles a OCIMachinePool object
type OCIMachinePoolReconciler struct {
        client.Client
        Scheme         *runtime.Scheme
        Recorder       record.EventRecorder
        ClientProvider *scope.ClientProvider
        Region         string
}

//+kubebuilder:rbac:groups=infrastructure.cluster.x-k8s.io,resources=ocimachinepools,verbs=get;list;watch;create;update;patch;delete
//+kubebuilder:rbac:groups=infrastructure.cluster.x-k8s.io,resources=ocimachinepools/status,verbs=get;update;patch
//+kubebuilder:rbac:groups=cluster.x-k8s.io,resources=machinepools;machinepools/status,verbs=get;list;watch
//+kubebuilder:rbac:groups=infrastructure.cluster.x-k8s.io,resources=ocimachinepools/finalizers,verbs=update

// Reconcile is part of the main kubernetes reconciliation loop which aims to
// move the current state of the machinepool closer to the desired state.
//
// For more details, check Reconcile and its Result here:
// - https://pkg.go.dev/sigs.k8s.io/controller-runtime@v0.8.3/pkg/reconcile
func (r *OCIMachinePoolReconciler) Reconcile(ctx context.Context, req ctrl.Request) (result ctrl.Result, reterr error) <span class="cov8" title="1">{
        logger := log.FromContext(ctx)
        logger.Info("Got reconciliation event for machine pool")

        // Fetch the OCIMachinePool.
        ociMachinePool := &amp;infrav2exp.OCIMachinePool{}
        err := r.Get(ctx, req.NamespacedName, ociMachinePool)
        if err != nil </span><span class="cov8" title="1">{
                if apierrors.IsNotFound(err) </span><span class="cov8" title="1">{
                        return ctrl.Result{}, nil
                }</span>
                <span class="cov0" title="0">return ctrl.Result{}, err</span>
        }

        // Fetch the CAPI MachinePool
        <span class="cov8" title="1">machinePool, err := getOwnerMachinePool(ctx, r.Client, ociMachinePool.ObjectMeta)
        if err != nil </span><span class="cov0" title="0">{
                return reconcile.Result{}, err
        }</span>
        <span class="cov8" title="1">if machinePool == nil </span><span class="cov8" title="1">{
                r.Recorder.Eventf(ociMachinePool, corev1.EventTypeNormal, "OwnerRefNotSet", "Cluster Controller has not yet set OwnerRef")
                logger.Info("MachinePool Controller has not yet set OwnerRef")
                return reconcile.Result{}, nil
        }</span>
        <span class="cov8" title="1">logger = logger.WithValues("machinePool", machinePool.Name)

        // Fetch the Cluster.
        cluster, err := util.GetClusterFromMetadata(ctx, r.Client, ociMachinePool.ObjectMeta)
        if err != nil </span><span class="cov8" title="1">{
                r.Recorder.Eventf(ociMachinePool, corev1.EventTypeWarning, "ClusterDoesNotExist", "MachinePool is missing cluster label or cluster does not exist")
                logger.Info("MachinePool is missing cluster label or cluster does not exist")
                return reconcile.Result{}, nil
        }</span>
        <span class="cov0" title="0">logger = logger.WithValues("cluster", cluster.Name)

        // Return early if the object or Cluster is paused.
        if annotations.IsPaused(cluster, ociMachinePool) </span><span class="cov0" title="0">{
                logger.Info("OCIMachinePool or linked Cluster is marked as paused. Won't reconcile")
                return ctrl.Result{}, nil
        }</span>
        // Convert v1beta2 Cluster to v1beta1 for scope compatibility
        <span class="cov0" title="0">clusterV1beta1, err := cloudutil.ConvertClusterV1Beta2ToV1Beta1(cluster)
        if err != nil </span><span class="cov0" title="0">{
                return ctrl.Result{}, errors.Wrap(err, "failed to convert cluster to v1beta1")
        }</span>

        <span class="cov0" title="0">var clusterAccessor scope.OCIClusterAccessor
        if clusterV1beta1.Spec.InfrastructureRef.Kind == "OCICluster" </span><span class="cov0" title="0">{
                ociCluster := &amp;infrastructurev1beta2.OCICluster{}
                ociClusterName := client.ObjectKey{
                        Namespace: clusterV1beta1.Namespace,
                        Name:      clusterV1beta1.Spec.InfrastructureRef.Name,
                }
                if err := r.Client.Get(ctx, ociClusterName, ociCluster); err != nil </span><span class="cov0" title="0">{
                        logger.Info("Cluster is not available yet")
                        r.Recorder.Eventf(ociMachinePool, corev1.EventTypeWarning, "ClusterNotAvailable", "Cluster is not available yet")
                        logger.V(2).Info("OCICluster is not available yet")
                        return ctrl.Result{}, nil
                }</span>
                <span class="cov0" title="0">clusterAccessor = scope.OCISelfManagedCluster{
                        OCICluster: ociCluster,
                }</span>
        } else<span class="cov0" title="0"> if clusterV1beta1.Spec.InfrastructureRef.Kind == "OCIManagedCluster" </span><span class="cov0" title="0">{
                ociManagedCluster := &amp;infrastructurev1beta2.OCIManagedCluster{}
                ociManagedClusterName := client.ObjectKey{
                        Namespace: clusterV1beta1.Namespace,
                        Name:      clusterV1beta1.Spec.InfrastructureRef.Name,
                }
                if err := r.Client.Get(ctx, ociManagedClusterName, ociManagedCluster); err != nil </span><span class="cov0" title="0">{
                        logger.Info("Cluster is not available yet")
                        r.Recorder.Eventf(ociMachinePool, corev1.EventTypeWarning, "ClusterNotAvailable", "Cluster is not available yet")
                        logger.V(2).Info("OCIManagedCluster is not available yet")
                        return ctrl.Result{}, nil
                }</span>
                <span class="cov0" title="0">clusterAccessor = scope.OCIManagedCluster{
                        OCIManagedCluster: ociManagedCluster,
                }</span>
        } else<span class="cov0" title="0"> {
                r.Recorder.Eventf(ociMachinePool, corev1.EventTypeWarning, "InfrastructureClusterTypeNotSupported", fmt.Sprintf("Infrastructure Cluster Type %s is not supported", cluster.Spec.InfrastructureRef.Kind))
                return ctrl.Result{}, errors.New(fmt.Sprintf("Infrastructure Cluster Type %s is not supported", cluster.Spec.InfrastructureRef.Kind))
        }</span>

        <span class="cov0" title="0">_, _, clients, err := cloudutil.InitClientsAndRegion(ctx, r.Client, r.Region, clusterAccessor, r.ClientProvider)
        if err != nil </span><span class="cov0" title="0">{
                return ctrl.Result{}, err
        }</span>

        // Create the machine pool scope
        <span class="cov0" title="0">machinePoolScope, err := scope.NewMachinePoolScope(scope.MachinePoolScopeParams{
                Client:                  r.Client,
                ComputeManagementClient: clients.ComputeManagementClient,
                Logger:                  &amp;logger,
                Cluster:                 clusterV1beta1,
                OCIClusterAccessor:      clusterAccessor,
                MachinePool:             machinePool,
                OCIMachinePool:          ociMachinePool,
        })
        if err != nil </span><span class="cov0" title="0">{
                return ctrl.Result{}, errors.Errorf("failed to create scope: %+v", err)
        }</span>

        // Always close the scope when exiting this function so we can persist any OCIMachinePool changes.
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err := machinePoolScope.Close(ctx); err != nil &amp;&amp; reterr == nil </span><span class="cov0" title="0">{
                        reterr = err
                }</span>
        }()

        // Handle deleted machines
        <span class="cov0" title="0">if !ociMachinePool.DeletionTimestamp.IsZero() </span><span class="cov0" title="0">{
                return r.reconcileDelete(ctx, machinePoolScope)
        }</span>

        // Handle non-deleted machines
        <span class="cov0" title="0">return r.reconcileNormal(ctx, logger, machinePoolScope)</span>
}

// SetupWithManager sets up the controller with the Manager.
func (r *OCIMachinePoolReconciler) SetupWithManager(ctx context.Context, mgr ctrl.Manager, options controller.Options) error <span class="cov0" title="0">{
        logger := log.FromContext(ctx)
        clusterToObjectFunc, err := util.ClusterToTypedObjectsMapper(r.Client, &amp;expV1Beta1.OCIMachinePoolList{}, mgr.GetScheme())
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrapf(err, "failed to create mapper for Cluster to OCIMachinePool")
        }</span>
        <span class="cov0" title="0">gvk, err := apiutil.GVKForObject(new(infrav2exp.OCIMachinePool), mgr.GetScheme())
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrapf(err, "failed to find GVK for OCIMachinePool")
        }</span>
        <span class="cov0" title="0">managedClusterToMachinePoolMap := managedClusterToManagedMachinePoolMapFunc(r.Client, gvk, logger)

        err = ctrl.NewControllerManagedBy(mgr).
                WithOptions(options).
                For(&amp;infrav2exp.OCIMachinePool{}).
                Watches(
                        &amp;expclusterv1.MachinePool{},
                        handler.EnqueueRequestsFromMapFunc(machinePoolToInfrastructureMapFunc(infrav2exp.
                                GroupVersion.WithKind(scope.OCIMachinePoolKind), logger)),
                ).
                Watches(
                        &amp;infrastructurev1beta2.OCIManagedCluster{},
                        handler.EnqueueRequestsFromMapFunc(managedClusterToMachinePoolMap),
                ).
                Watches(
                        &amp;clusterv1.Cluster{},
                        handler.EnqueueRequestsFromMapFunc(clusterToObjectFunc),
                        builder.WithPredicates(
                                predicates.ClusterPausedTransitionsOrInfrastructureProvisioned(mgr.GetScheme(), ctrl.LoggerFrom(ctx)),
                        ),
                ).
                WithEventFilter(predicates.ResourceNotPaused(mgr.GetScheme(), ctrl.LoggerFrom(ctx))).
                Complete(r)

        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrapf(err, "error creating controller")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func machinePoolToInfrastructureMapFunc(gvk schema.GroupVersionKind, logger logr.Logger) handler.MapFunc <span class="cov0" title="0">{
        return func(ctx context.Context, o client.Object) []reconcile.Request </span><span class="cov0" title="0">{
                m, ok := o.(*expclusterv1.MachinePool)
                if !ok </span><span class="cov0" title="0">{
                        panic(fmt.Sprintf("Expected a MachinePool but got a %T", o))</span>
                }

                <span class="cov0" title="0">gk := gvk.GroupKind()
                // Return early if the GroupKind doesn't match what we expect
                infraGK := m.Spec.Template.Spec.InfrastructureRef.GroupVersionKind().GroupKind()
                if gk != infraGK </span><span class="cov0" title="0">{
                        logger.V(4).Info("gk does not match", "gk", gk, "infraGK", infraGK)
                        return nil
                }</span>

                <span class="cov0" title="0">return []reconcile.Request{
                        {
                                NamespacedName: client.ObjectKey{
                                        Namespace: m.Namespace,
                                        Name:      m.Spec.Template.Spec.InfrastructureRef.Name,
                                },
                        },
                }</span>
        }
}

// getOwnerMachinePool returns the MachinePool object owning the current resource.
// nolint:nilnil
func getOwnerMachinePool(ctx context.Context, c client.Client, obj metav1.ObjectMeta) (*expclusterv1.MachinePool, error) <span class="cov8" title="1">{
        for _, ref := range obj.OwnerReferences </span><span class="cov8" title="1">{
                if ref.Kind != "MachinePool" </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">gv, err := schema.ParseGroupVersion(ref.APIVersion)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errors.WithStack(err)
                }</span>
                <span class="cov8" title="1">if gv.Group == expclusterv1.GroupVersion.Group </span><span class="cov8" title="1">{
                        return getMachinePoolByName(ctx, c, obj.Namespace, ref.Name)
                }</span>
        }
        <span class="cov8" title="1">return nil, nil</span>
}

// getMachinePoolByName finds and return a Machine object using the specified params.
func getMachinePoolByName(ctx context.Context, c client.Client, namespace, name string) (*expclusterv1.MachinePool, error) <span class="cov8" title="1">{
        m := &amp;expclusterv1.MachinePool{}
        key := client.ObjectKey{Name: name, Namespace: namespace}
        if err := c.Get(ctx, key, m); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return m, nil</span>
}

func (r *OCIMachinePoolReconciler) reconcileNormal(ctx context.Context, logger logr.Logger, machinePoolScope *scope.MachinePoolScope) (ctrl.Result, error) <span class="cov8" title="1">{
        machinePoolScope.Info("Handling reconcile OCIMachinePool")

        // If the OCIMachinePool is in an error state, return early.
        if machinePoolScope.HasFailed() </span><span class="cov0" title="0">{
                machinePoolScope.Info("Error state detected, skipping reconciliation")

                return ctrl.Result{}, nil
        }</span>

        // If the OCIMachinePool doesn't have our finalizer, add it.
        <span class="cov8" title="1">controllerutil.AddFinalizer(machinePoolScope.OCIMachinePool, infrav2exp.MachinePoolFinalizer)
        // Register the finalizer immediately to avoid orphaning OCI resources on delete
        if err := machinePoolScope.PatchObject(ctx); err != nil </span><span class="cov0" title="0">{
                return reconcile.Result{}, err
        }</span>

        <span class="cov8" title="1">if !machinePoolScope.Cluster.Status.InfrastructureReady </span><span class="cov0" title="0">{
                logger.Info("Cluster infrastructure is not ready yet")
                return reconcile.Result{}, nil
        }</span>

        // Make sure bootstrap data is available and populated.
        <span class="cov8" title="1">if machinePoolScope.MachinePool.Spec.Template.Spec.Bootstrap.DataSecretName == nil </span><span class="cov8" title="1">{
                r.Recorder.Event(machinePoolScope.OCIMachinePool, corev1.EventTypeNormal, infrastructurev1beta2.WaitingForBootstrapDataReason, "Bootstrap data secret reference is not yet available")
                conditions.MarkFalse(machinePoolScope.OCIMachinePool, infrav2exp.InstancePoolReadyCondition, infrastructurev1beta2.WaitingForBootstrapDataReason, clusterv1.ConditionSeverityInfo, "")
                logger.Info("Bootstrap data secret reference is not yet available")
                return reconcile.Result{}, nil
        }</span>

        // get or create the InstanceConfiguration
        // https://docs.oracle.com/en-us/iaas/api/#/en/iaas/20160918/InstanceConfiguration/
        <span class="cov8" title="1">if err := machinePoolScope.ReconcileInstanceConfiguration(ctx); err != nil </span><span class="cov0" title="0">{
                r.Recorder.Eventf(machinePoolScope.OCIMachinePool, corev1.EventTypeWarning, "FailedLaunchTemplateReconcile", "Failed to reconcile launch template: %v", err)
                return ctrl.Result{}, err
        }</span>

        // set the LaunchTemplateReady condition
        <span class="cov8" title="1">conditions.MarkTrue(machinePoolScope.OCIMachinePool, infrav2exp.LaunchTemplateReadyCondition)

        // Find existing Instance Pool
        instancePool, err := machinePoolScope.FindInstancePool(ctx)
        if err != nil </span><span class="cov0" title="0">{
                r.Recorder.Event(machinePoolScope.OCIMachinePool, corev1.EventTypeWarning, "ReconcileError", err.Error())
                conditions.MarkUnknown(machinePoolScope.OCIMachinePool, infrav2exp.InstancePoolReadyCondition, infrav2exp.InstancePoolNotFoundReason, "")
                return ctrl.Result{}, err
        }</span>

        <span class="cov8" title="1">if instancePool == nil </span><span class="cov8" title="1">{
                if _, err := machinePoolScope.CreateInstancePool(ctx); err != nil </span><span class="cov0" title="0">{
                        r.Recorder.Event(machinePoolScope.OCIMachinePool, corev1.EventTypeWarning, "ReconcileError", err.Error())
                        conditions.MarkFalse(machinePoolScope.OCIMachinePool, infrav2exp.InstancePoolReadyCondition, infrav2exp.InstancePoolProvisionFailedReason, clusterv1.ConditionSeverityError, "")
                        return ctrl.Result{}, err
                }</span>
                <span class="cov8" title="1">r.Recorder.Eventf(machinePoolScope.OCIMachinePool, corev1.EventTypeNormal, "InstancePoolCreated", "Created new Instance Pool: %s", machinePoolScope.OCIMachinePool.GetName())
                return ctrl.Result{}, nil</span>
        }

        <span class="cov8" title="1">machinePoolScope.Info("OCI Compute Instance Pool found", "InstancePoolId", *instancePool.Id)
        machinePoolScope.OCIMachinePool.Spec.ProviderID = common.String(fmt.Sprintf("oci://%s", *instancePool.Id))
        machinePoolScope.OCIMachinePool.Spec.OCID = instancePool.Id

        switch instancePool.LifecycleState </span>{
        case core.InstancePoolLifecycleStateProvisioning, core.InstancePoolLifecycleStateStarting:<span class="cov0" title="0">
                machinePoolScope.Info("Instance Pool is pending")
                conditions.MarkFalse(machinePoolScope.OCIMachinePool, infrav2exp.InstancePoolReadyCondition, infrav2exp.InstancePoolNotReadyReason, clusterv1.ConditionSeverityInfo, "")
                return reconcile.Result{RequeueAfter: 10 * time.Second}, nil</span>
        case core.InstancePoolLifecycleStateScaling:<span class="cov0" title="0">
                machinePoolScope.Info("Instance Pool is scaling")
                conditions.MarkFalse(machinePoolScope.OCIMachinePool, infrav2exp.InstancePoolReadyCondition, infrav2exp.InstancePoolNotReadyReason, clusterv1.ConditionSeverityInfo, "")
                return reconcile.Result{RequeueAfter: 10 * time.Second}, nil</span>
        case core.InstancePoolLifecycleStateRunning:<span class="cov8" title="1">
                machinePoolScope.Info("Instance pool is active")

                // record the event only when pool goes from not ready to ready state
                r.Recorder.Eventf(machinePoolScope.OCIMachinePool, corev1.EventTypeNormal, "InstancePoolReady",
                        "Instance pool is in ready state")
                conditions.MarkTrue(machinePoolScope.OCIMachinePool, infrav2exp.InstancePoolReadyCondition)

                machines, err := machinePoolScope.SetListandSetMachinePoolInstances(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        return reconcile.Result{}, err
                }</span>
                <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                        return reconcile.Result{}, err
                }</span>
                <span class="cov8" title="1">providerIDList := make([]string, 0)
                for _, machine := range machines </span><span class="cov8" title="1">{
                        if machine.Status.Ready </span><span class="cov8" title="1">{
                                providerIDList = append(providerIDList, *machine.Spec.ProviderID)
                        }</span>
                }
                <span class="cov8" title="1">machinePoolScope.OCIMachinePool.Spec.ProviderIDList = providerIDList

                err = r.reconcileMachines(ctx, err, machinePoolScope, machines)
                if err != nil </span><span class="cov0" title="0">{
                        return reconcile.Result{}, err
                }</span>

                <span class="cov8" title="1">instancePool, err = machinePoolScope.UpdatePool(ctx, instancePool)
                if err != nil </span><span class="cov0" title="0">{
                        r.Recorder.Eventf(machinePoolScope.OCIMachinePool, corev1.EventTypeWarning, "FailedUpdate", "Failed to update instance pool: %v", err)
                        machinePoolScope.Error(err, "error updating OCIMachinePool")
                        return ctrl.Result{}, err
                }</span>
                <span class="cov8" title="1">err = machinePoolScope.CleanupInstanceConfiguration(ctx, instancePool)
                if err != nil </span><span class="cov0" title="0">{
                        return ctrl.Result{}, err
                }</span>
                <span class="cov8" title="1">machinePoolScope.SetReplicaCount(int32(len(providerIDList)))
                machinePoolScope.SetReady()</span>
        default:<span class="cov8" title="1">
                conditions.MarkFalse(machinePoolScope.OCIMachinePool, infrav2exp.InstancePoolReadyCondition, infrav2exp.InstancePoolProvisionFailedReason, clusterv1.ConditionSeverityError, "")
                machinePoolScope.SetFailureReason(cloudutil.CreateError)
                machinePoolScope.SetFailureMessage(errors.Errorf("Instance Pool status %q is unexpected", instancePool.LifecycleState))
                r.Recorder.Eventf(machinePoolScope.OCIMachinePool, corev1.EventTypeWarning, "ReconcileError",
                        "Instance pool has invalid lifecycle state %s", instancePool.LifecycleState)
                return reconcile.Result{}, errors.New(fmt.Sprintf("instance pool has invalid lifecycle state %s", instancePool.LifecycleState))</span>
        }
        // we reconcile every 5 minutes in case any reconciliation have happened behind the scenes by Instancepool service on
        // the instance pool(removing unhealthy nodes etc) which has to be percolated to machinepool machines
        <span class="cov8" title="1">return reconcile.Result{RequeueAfter: 300 * time.Second}, nil</span>
}

func (r *OCIMachinePoolReconciler) reconcileDelete(ctx context.Context, machinePoolScope *scope.MachinePoolScope) (_ ctrl.Result, reterr error) <span class="cov8" title="1">{
        machinePoolScope.Info("Handling deleted OCIMachinePool")

        // Find existing Instance Pool
        instancePool, err := machinePoolScope.FindInstancePool(ctx)
        if err != nil </span><span class="cov0" title="0">{
                if !ociutil.IsNotFound(err) </span><span class="cov0" title="0">{
                        return ctrl.Result{}, err
                }</span>
        }

        <span class="cov8" title="1">if instancePool == nil </span><span class="cov0" title="0">{
                machinePoolScope.OCIMachinePool.Status.Ready = false
                conditions.MarkFalse(machinePoolScope.OCIMachinePool, infrav2exp.InstancePoolReadyCondition, infrav2exp.InstancePoolNotFoundReason, clusterv1.ConditionSeverityWarning, "")
                machinePoolScope.Info("Instance Pool may already be deleted")
                r.Recorder.Eventf(machinePoolScope.OCIMachinePool, corev1.EventTypeNormal, infrav2exp.InstancePoolNotFoundReason, "Unable to find matching instance pool")
        }</span> else<span class="cov8" title="1"> {
                switch instancePool.LifecycleState </span>{
                case core.InstancePoolLifecycleStateTerminating:<span class="cov0" title="0">
                        machinePoolScope.Info("Instance Pool is already deleting", "displayName", instancePool.DisplayName, "id", instancePool.Id)
                        // check back after 30 seconds
                        return reconcile.Result{RequeueAfter: 30 * time.Second}, nil</span>
                case core.InstancePoolLifecycleStateTerminated:<span class="cov8" title="1">
                        // Instance Pool is already deleted
                        machinePoolScope.OCIMachinePool.Status.Ready = false
                        conditions.MarkFalse(machinePoolScope.OCIMachinePool, infrav2exp.InstancePoolReadyCondition, infrav2exp.InstancePoolDeletionInProgress, clusterv1.ConditionSeverityWarning, "")
                        r.Recorder.Eventf(machinePoolScope.OCIMachinePool, corev1.EventTypeWarning, "DeletionInProgress", "Instance Pool deletion in progress: %s - %s", instancePool.DisplayName, instancePool.Id)
                        machinePoolScope.Info("Instance Pool is already deleted", "displayName", instancePool.DisplayName, "id", instancePool.Id)</span>
                default:<span class="cov8" title="1">
                        if err := machinePoolScope.TerminateInstancePool(ctx, instancePool); err != nil </span><span class="cov0" title="0">{
                                r.Recorder.Eventf(machinePoolScope.OCIMachinePool, corev1.EventTypeWarning, "FailedDelete", "Failed to delete instance pool %q: %v", instancePool.Id, err)
                                return ctrl.Result{}, errors.Wrap(err, "failed to delete instance pool")
                        }</span> else<span class="cov8" title="1"> {
                                // check back after 30 seconds
                                return reconcile.Result{RequeueAfter: 30 * time.Second}, nil
                        }</span>
                }
        }

        <span class="cov8" title="1">err = machinePoolScope.CleanupInstanceConfiguration(ctx, nil)
        if err != nil </span><span class="cov0" title="0">{
                return ctrl.Result{}, err
        }</span>
        <span class="cov8" title="1">instanceConfiguration, err := machinePoolScope.GetInstanceConfiguration(ctx)
        if err != nil </span><span class="cov0" title="0">{
                if !ociutil.IsNotFound(err) </span><span class="cov0" title="0">{
                        return reconcile.Result{}, err
                }</span>
        }
        <span class="cov8" title="1">if instanceConfiguration != nil </span><span class="cov8" title="1">{
                instanceConfigurationId := instanceConfiguration.Id
                machinePoolScope.Info("deleting instance configuration", "id", *instanceConfigurationId)
                req := core.DeleteInstanceConfigurationRequest{InstanceConfigurationId: instanceConfigurationId}
                if _, err := machinePoolScope.ComputeManagementClient.DeleteInstanceConfiguration(ctx, req); err != nil </span><span class="cov0" title="0">{
                        r.Recorder.Eventf(machinePoolScope.OCIMachinePool, corev1.EventTypeWarning, "FailedDelete", "Failed to delete instance configuration %q: %v", instanceConfigurationId, err)
                        return ctrl.Result{}, errors.Wrap(err, "failed to delete instance configuration")
                }</span>
        }
        <span class="cov8" title="1">machinePoolScope.Info("successfully deleted instance pool and Launch Template")
        // remove finalizer
        controllerutil.RemoveFinalizer(machinePoolScope.OCIMachinePool, infrav2exp.MachinePoolFinalizer)
        return ctrl.Result{}, nil</span>
}

func (r *OCIMachinePoolReconciler) reconcileMachines(ctx context.Context, err error, machinePoolScope *scope.MachinePoolScope, specInfraMachines []infrav2exp.OCIMachinePoolMachine) error <span class="cov8" title="1">{
        params := cloudutil.MachineParams{
                Cluster:              machinePoolScope.Cluster,
                MachinePool:          machinePoolScope.MachinePool,
                InfraMachinePoolName: machinePoolScope.OCIMachinePool.Name,
                Namespace:            machinePoolScope.OCIMachinePool.Namespace,
                SpecInfraMachines:    specInfraMachines,
                Client:               r.Client,
                Logger:               machinePoolScope.Logger,
                InfraMachinePoolKind: machinePoolScope.OCIMachinePool.Kind,
                InfraMachinePoolUID:  machinePoolScope.OCIMachinePool.UID,
        }
        err = cloudutil.CreateMachinePoolMachinesIfNotExists(ctx, params)
        if err != nil </span><span class="cov0" title="0">{
                r.Recorder.Event(machinePoolScope.OCIMachinePool, corev1.EventTypeWarning, "FailedToCreateNewMachines", err.Error())
                conditions.MarkFalse(machinePoolScope.OCIMachinePool, clusterv1.ReadyCondition, "FailedToCreateNewMachines", clusterv1.ConditionSeverityWarning, "")
                return errors.Wrap(err, "failed to create missing machines")
        }</span>

        <span class="cov8" title="1">err = cloudutil.DeleteOrphanedMachinePoolMachines(ctx, params)
        if err != nil </span><span class="cov0" title="0">{
                conditions.MarkFalse(machinePoolScope.OCIMachinePool, clusterv1.ReadyCondition, "FailedToDeleteOrphanedMachines", clusterv1.ConditionSeverityWarning, "")
                return errors.Wrap(err, "failed to delete orphaned machines")
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file98" style="display: none">/*
Copyright (c) 2023 Oracle and/or its affiliates.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package controllers

import (
        "context"

        "github.com/oracle/cluster-api-provider-oci/cloud/scope"
        infrav2exp "github.com/oracle/cluster-api-provider-oci/exp/api/v1beta2"
        "github.com/pkg/errors"
        apierrors "k8s.io/apimachinery/pkg/api/errors"
        "k8s.io/apimachinery/pkg/runtime"
        "k8s.io/client-go/tools/record"
        "sigs.k8s.io/cluster-api/util/patch"
        "sigs.k8s.io/cluster-api/util/predicates"
        ctrl "sigs.k8s.io/controller-runtime"
        "sigs.k8s.io/controller-runtime/pkg/client"
        "sigs.k8s.io/controller-runtime/pkg/controller"
        "sigs.k8s.io/controller-runtime/pkg/controller/controllerutil"
)

type OCIMachinePoolMachineReconciler struct {
        client.Client
        Scheme         *runtime.Scheme
        Recorder       record.EventRecorder
        ClientProvider *scope.ClientProvider
        Region         string
}

//+kubebuilder:rbac:groups=infrastructure.cluster.x-k8s.io,resources=ocimachinepoolmachines,verbs=get;list;watch;create;update;patch;delete

// Reconcile is part of the main kubernetes reconciliation loop which aims to
// move the current state of the machinepoolmachines closer to the desired state.
func (r *OCIMachinePoolMachineReconciler) Reconcile(ctx context.Context, req ctrl.Request) (result ctrl.Result, reterr error) <span class="cov0" title="0">{
        // currently, we only remove the finalizer on delete
        // at a later point, when machine pool machine feature improves with integration with autoscaler and deployment
        // orchestration etc, we should improve the below logic to actually delete the machine pool machine from the underlying
        // infra object such as OKE nodepool or instance pool etc
        ociMachinePoolMachine := &amp;infrav2exp.OCIMachinePoolMachine{}
        err := r.Get(ctx, req.NamespacedName, ociMachinePoolMachine)
        if err != nil </span><span class="cov0" title="0">{
                if apierrors.IsNotFound(err) </span><span class="cov0" title="0">{
                        return ctrl.Result{}, nil
                }</span>
                <span class="cov0" title="0">return ctrl.Result{}, err</span>
        }
        <span class="cov0" title="0">helper, err := patch.NewHelper(ociMachinePoolMachine, r.Client)
        defer func() </span><span class="cov0" title="0">{
                if err := helper.Patch(ctx, ociMachinePoolMachine); err != nil &amp;&amp; reterr == nil </span><span class="cov0" title="0">{
                        reterr = err
                }</span>
        }()
        <span class="cov0" title="0">if !ociMachinePoolMachine.DeletionTimestamp.IsZero() </span><span class="cov0" title="0">{
                controllerutil.RemoveFinalizer(ociMachinePoolMachine, infrav2exp.MachinePoolMachineFinalizer)
        }</span>
        <span class="cov0" title="0">return ctrl.Result{}, nil</span>
}

func (r *OCIMachinePoolMachineReconciler) SetupWithManager(ctx context.Context, mgr ctrl.Manager, options controller.Options) error <span class="cov0" title="0">{
        err := ctrl.NewControllerManagedBy(mgr).
                WithOptions(options).
                For(&amp;infrav2exp.OCIMachinePoolMachine{}).
                WithEventFilter(predicates.ResourceNotPaused(mgr.GetScheme(), ctrl.LoggerFrom(ctx))).
                Complete(r)

        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrapf(err, "error creating controller")
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file99" style="display: none">/*
Copyright (c) 2021, 2022 Oracle and/or its affiliates.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
//updating
package controllers

import (
        "context"
        "fmt"
        "time"

        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"

        "github.com/go-logr/logr"
        infrastructurev1beta2 "github.com/oracle/cluster-api-provider-oci/api/v1beta2"
        "github.com/oracle/cluster-api-provider-oci/cloud/ociutil"
        "github.com/oracle/cluster-api-provider-oci/cloud/scope"
        cloudutil "github.com/oracle/cluster-api-provider-oci/cloud/util"
        expV1Beta1 "github.com/oracle/cluster-api-provider-oci/exp/api/v1beta1"
        infrav2exp "github.com/oracle/cluster-api-provider-oci/exp/api/v1beta2"
        "github.com/oracle/oci-go-sdk/v65/common"
        oke "github.com/oracle/oci-go-sdk/v65/containerengine"
        "github.com/pkg/errors"
        corev1 "k8s.io/api/core/v1"
        apierrors "k8s.io/apimachinery/pkg/api/errors"
        "k8s.io/apimachinery/pkg/runtime"
        "k8s.io/apimachinery/pkg/runtime/schema"
        "k8s.io/apimachinery/pkg/types"
        "k8s.io/client-go/tools/record"
        clusterv1 "sigs.k8s.io/cluster-api/api/core/v1beta1"
        expclusterv1 "sigs.k8s.io/cluster-api/api/core/v1beta1"
        "sigs.k8s.io/cluster-api/util"
        "sigs.k8s.io/cluster-api/util/annotations"
        "sigs.k8s.io/cluster-api/util/deprecated/v1beta1/conditions"
        "sigs.k8s.io/cluster-api/util/predicates"
        ctrl "sigs.k8s.io/controller-runtime"
        "sigs.k8s.io/controller-runtime/pkg/builder"
        "sigs.k8s.io/controller-runtime/pkg/client"
        "sigs.k8s.io/controller-runtime/pkg/client/apiutil"
        "sigs.k8s.io/controller-runtime/pkg/controller"
        "sigs.k8s.io/controller-runtime/pkg/controller/controllerutil"
        "sigs.k8s.io/controller-runtime/pkg/handler"
        "sigs.k8s.io/controller-runtime/pkg/log"
        "sigs.k8s.io/controller-runtime/pkg/reconcile"
)

// OCIManagedMachinePoolReconciler reconciles a OCIManagedMachinePool object
type OCIManagedMachinePoolReconciler struct {
        client.Client
        Scheme         *runtime.Scheme
        Recorder       record.EventRecorder
        ClientProvider *scope.ClientProvider
        Region         string
}

//+kubebuilder:rbac:groups=infrastructure.cluster.x-k8s.io,resources=ocimanagedmachinepools,verbs=get;list;watch;create;update;patch;delete
//+kubebuilder:rbac:groups=infrastructure.cluster.x-k8s.io,resources=ocimanagedmachinepools/status,verbs=get;update;patch
//+kubebuilder:rbac:groups=cluster.x-k8s.io,resources=machinepools;machinepools/status,verbs=get;list;watch
//+kubebuilder:rbac:groups=infrastructure.cluster.x-k8s.io,resources=ocimanagedmachinepools/finalizers,verbs=update

// Reconcile is part of the main kubernetes reconciliation loop which aims to
// move the current state of the machinepool closer to the desired state.
//
// For more details, check Reconcile and its Result here:
// - https://pkg.go.dev/sigs.k8s.io/controller-runtime@v0.8.3/pkg/reconcile
func (r *OCIManagedMachinePoolReconciler) Reconcile(ctx context.Context, req ctrl.Request) (result ctrl.Result, reterr error) <span class="cov8" title="1">{
        logger := log.FromContext(ctx)
        logger.Info("Got reconciliation event for managedmachine pool")

        // Fetch the OCIManagedMachinePool.
        ociManagedMachinePool := &amp;infrav2exp.OCIManagedMachinePool{}
        err := r.Get(ctx, req.NamespacedName, ociManagedMachinePool)
        if err != nil </span><span class="cov8" title="1">{
                if apierrors.IsNotFound(err) </span><span class="cov8" title="1">{
                        return ctrl.Result{}, nil
                }</span>
                <span class="cov0" title="0">return ctrl.Result{}, err</span>
        }
        // Fetch the CAPI MachinePool
        <span class="cov8" title="1">machinePool, err := getOwnerMachinePool(ctx, r.Client, ociManagedMachinePool.ObjectMeta)
        if err != nil </span><span class="cov0" title="0">{
                return reconcile.Result{}, err
        }</span>
        <span class="cov8" title="1">if machinePool == nil </span><span class="cov8" title="1">{
                r.Recorder.Eventf(ociManagedMachinePool, corev1.EventTypeNormal, "OwnerRefNotSet", "Cluster Controller has not yet set OwnerRef")
                logger.Info("MachinePool Controller has not yet set OwnerRef")
                return reconcile.Result{}, nil
        }</span>
        <span class="cov8" title="1">logger = logger.WithValues("machinePool", machinePool.Name)

        // Fetch the Cluster.
        cluster, err := util.GetClusterFromMetadata(ctx, r.Client, ociManagedMachinePool.ObjectMeta)
        if err != nil </span><span class="cov8" title="1">{
                r.Recorder.Eventf(ociManagedMachinePool, corev1.EventTypeWarning, "ClusterDoesNotExist", "MachinePool is missing cluster label or cluster does not exist")
                logger.Info("MachinePool is missing cluster label or cluster does not exist")
                return reconcile.Result{}, nil
        }</span>
        <span class="cov0" title="0">logger = logger.WithValues("cluster", cluster.Name)

        // Return early if the object or Cluster is paused.
        if annotations.IsPaused(cluster, ociManagedMachinePool) </span><span class="cov0" title="0">{
                logger.Info("OCIMachinePool or linked Cluster is marked as paused. Won't reconcile")
                return ctrl.Result{}, nil
        }</span>
        // Convert v1beta2 Cluster to v1beta1 for scope compatibility
        <span class="cov0" title="0">clusterV1beta1, err := cloudutil.ConvertClusterV1Beta2ToV1Beta1(cluster)
        if err != nil </span><span class="cov0" title="0">{
                return ctrl.Result{}, errors.Wrap(err, "failed to convert cluster to v1beta1")
        }</span>

        <span class="cov0" title="0">ociManagedCluster := &amp;infrastructurev1beta2.OCIManagedCluster{}
        ociClusterName := client.ObjectKey{
                Namespace: clusterV1beta1.Namespace,
                Name:      clusterV1beta1.Spec.InfrastructureRef.Name,
        }

        if err := r.Client.Get(ctx, ociClusterName, ociManagedCluster); err != nil </span><span class="cov0" title="0">{
                logger.Info("Cluster is not available yet")
                r.Recorder.Eventf(ociManagedMachinePool, corev1.EventTypeWarning, "ClusterNotAvailable", "Cluster is not available yet")
                logger.V(2).Info("OCICluster is not available yet")
                return ctrl.Result{}, nil
        }</span>

        <span class="cov0" title="0">clusterAccessor := scope.OCIManagedCluster{
                OCIManagedCluster: ociManagedCluster,
        }
        _, _, clients, err := cloudutil.InitClientsAndRegion(ctx, r.Client, r.Region, clusterAccessor, r.ClientProvider)
        if err != nil </span><span class="cov0" title="0">{
                return ctrl.Result{}, err
        }</span>

        <span class="cov0" title="0">controlPlane := &amp;infrastructurev1beta2.OCIManagedControlPlane{}
        controlPlaneRef := types.NamespacedName{
                Name:      clusterV1beta1.Spec.ControlPlaneRef.Name,
                Namespace: clusterV1beta1.Namespace,
        }

        if err := r.Get(ctx, controlPlaneRef, controlPlane); err != nil </span><span class="cov0" title="0">{
                return reconcile.Result{}, errors.Wrap(err, "failed to get control plane ref")
        }</span>

        // Create the machine pool scope
        <span class="cov0" title="0">machinePoolScope, err := scope.NewManagedMachinePoolScope(scope.ManagedMachinePoolScopeParams{
                Client:                  r.Client,
                ComputeManagementClient: clients.ComputeManagementClient,
                Logger:                  &amp;logger,
                Cluster:                 clusterV1beta1,
                OCIManagedCluster:       ociManagedCluster,
                MachinePool:             machinePool,
                OCIManagedMachinePool:   ociManagedMachinePool,
                ContainerEngineClient:   clients.ContainerEngineClient,
                OCIManagedControlPlane:  controlPlane,
        })
        if err != nil </span><span class="cov0" title="0">{
                return ctrl.Result{}, errors.Errorf("failed to create scope: %+v", err)
        }</span>

        // Always close the scope when exiting this function so we can persist any OCIManagedMachinePool changes.
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err := machinePoolScope.Close(ctx); err != nil &amp;&amp; reterr == nil </span><span class="cov0" title="0">{
                        reterr = err
                }</span>
        }()

        // Handle deleted machines
        <span class="cov0" title="0">if !ociManagedMachinePool.DeletionTimestamp.IsZero() </span><span class="cov0" title="0">{
                return r.reconcileDelete(ctx, machinePoolScope)
        }</span>

        // Handle non-deleted machines
        <span class="cov0" title="0">return r.reconcileNormal(ctx, logger, machinePoolScope)</span>
}

// SetupWithManager sets up the controller with the Manager.
func (r *OCIManagedMachinePoolReconciler) SetupWithManager(ctx context.Context, mgr ctrl.Manager, options controller.Options) error <span class="cov0" title="0">{
        logger := log.FromContext(ctx)
        gvk, err := apiutil.GVKForObject(new(infrav2exp.OCIManagedMachinePool), mgr.GetScheme())
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrapf(err, "failed to find GVK for OCIManagedMachinePool")
        }</span>
        <span class="cov0" title="0">managedControlPlaneToManagedMachinePoolMap := managedClusterToManagedMachinePoolMapFunc(r.Client, gvk, logger)
        clusterToObjectFunc, err := util.ClusterToTypedObjectsMapper(r.Client, &amp;expV1Beta1.OCIManagedMachinePoolList{}, mgr.GetScheme())
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrapf(err, "failed to create mapper for Cluster to OCIManagedMachinePool")
        }</span>
        <span class="cov0" title="0">return ctrl.NewControllerManagedBy(mgr).
                WithOptions(options).
                For(&amp;infrav2exp.OCIManagedMachinePool{}).
                Watches(
                        &amp;expclusterv1.MachinePool{},
                        handler.EnqueueRequestsFromMapFunc(machinePoolToInfrastructureMapFunc(infrastructurev1beta2.
                                GroupVersion.WithKind(scope.OCIManagedMachinePoolKind), logger)),
                ).
                Watches(
                        &amp;infrastructurev1beta2.OCIManagedCluster{},
                        handler.EnqueueRequestsFromMapFunc(managedControlPlaneToManagedMachinePoolMap),
                ).
                Watches(
                        &amp;clusterv1.Cluster{},
                        handler.EnqueueRequestsFromMapFunc(clusterToObjectFunc),
                        builder.WithPredicates(
                                predicates.ClusterPausedTransitionsOrInfrastructureProvisioned(mgr.GetScheme(), ctrl.LoggerFrom(ctx)),
                        ),
                ).
                WithEventFilter(predicates.ResourceNotPaused(mgr.GetScheme(), ctrl.LoggerFrom(ctx))).
                Complete(r)</span>
}

func managedClusterToManagedMachinePoolMapFunc(c client.Client, gvk schema.GroupVersionKind, log logr.Logger) handler.MapFunc <span class="cov0" title="0">{
        return func(ctx context.Context, o client.Object) []reconcile.Request </span><span class="cov0" title="0">{
                ociCluster, ok := o.(*infrastructurev1beta2.OCIManagedCluster)
                if !ok </span><span class="cov0" title="0">{
                        panic(fmt.Sprintf("Expected a OCIManagedCluster but got a %T", o))</span>
                }

                <span class="cov0" title="0">if !ociCluster.ObjectMeta.DeletionTimestamp.IsZero() </span><span class="cov0" title="0">{
                        return nil
                }</span>

                <span class="cov0" title="0">cluster, err := util.GetOwnerCluster(ctx, c, ociCluster.ObjectMeta)
                if err != nil </span><span class="cov0" title="0">{
                        log.Error(err, "couldn't get OCIManagedCluster owner ObjectKey")
                        return nil
                }</span>
                <span class="cov0" title="0">if cluster == nil </span><span class="cov0" title="0">{
                        return nil
                }</span>

                <span class="cov0" title="0">managedPoolForClusterList := expclusterv1.MachinePoolList{}
                if err := c.List(
                        ctx, &amp;managedPoolForClusterList, client.InNamespace(cluster.Namespace), client.MatchingLabels{clusterv1.ClusterNameLabel: cluster.Name},
                ); err != nil </span><span class="cov0" title="0">{
                        log.Error(err, "couldn't list pools for cluster")
                        return nil
                }</span>

                <span class="cov0" title="0">mapFunc := machinePoolToInfrastructureMapFunc(gvk, log)

                var results []ctrl.Request
                for i := range managedPoolForClusterList.Items </span><span class="cov0" title="0">{
                        managedPool := mapFunc(ctx, &amp;managedPoolForClusterList.Items[i])
                        results = append(results, managedPool...)
                }</span>

                <span class="cov0" title="0">return results</span>
        }
}

func (r *OCIManagedMachinePoolReconciler) reconcileNormal(ctx context.Context, logger logr.Logger, machinePoolScope *scope.ManagedMachinePoolScope) (ctrl.Result, error) <span class="cov8" title="1">{
        machinePoolScope.Info("Handling reconcile OCIMachinePool")
        // If the OCIMachinePool doesn't have our finalizer, add it.
        controllerutil.AddFinalizer(machinePoolScope.OCIManagedMachinePool, infrav2exp.ManagedMachinePoolFinalizer)

        if !machinePoolScope.Cluster.Status.InfrastructureReady </span><span class="cov0" title="0">{
                logger.Info("Cluster infrastructure is not ready yet")
                return reconcile.Result{}, nil
        }</span>

        <span class="cov8" title="1">if !machinePoolScope.OCIManagedControlPlane.Status.Ready </span><span class="cov0" title="0">{
                logger.Info("Cluster control plane is not ready yet")
                return reconcile.Result{}, nil
        }</span>

        // Find existing Node Pool
        <span class="cov8" title="1">nodePool, err := machinePoolScope.FindNodePool(ctx)
        if err != nil </span><span class="cov0" title="0">{
                r.Recorder.Event(machinePoolScope.OCIManagedMachinePool, corev1.EventTypeWarning, "ReconcileError", err.Error())
                conditions.MarkUnknown(machinePoolScope.OCIManagedMachinePool, infrav2exp.NodePoolReadyCondition, infrav2exp.NodePoolNotFoundReason, "")
                return ctrl.Result{}, err
        }</span>

        <span class="cov8" title="1">if nodePool == nil </span><span class="cov8" title="1">{
                if nodePool, err = machinePoolScope.CreateNodePool(ctx); err != nil </span><span class="cov0" title="0">{
                        r.Recorder.Event(machinePoolScope.OCIManagedMachinePool, corev1.EventTypeWarning, "ReconcileError", err.Error())
                        conditions.MarkFalse(machinePoolScope.OCIManagedMachinePool, infrav2exp.NodePoolReadyCondition, infrav2exp.NodePoolProvisionFailedReason, clusterv1.ConditionSeverityError, "")
                        return ctrl.Result{}, err
                }</span>
                // record the event only when node pool is created
                <span class="cov8" title="1">r.Recorder.Eventf(machinePoolScope.OCIManagedMachinePool, corev1.EventTypeNormal, "NodePool",
                        "Created new Node Pool: %s", machinePoolScope.OCIManagedMachinePool.GetName())</span>
        }

        <span class="cov8" title="1">machinePoolScope.Info("Node Pool found", "NodePoolId", *nodePool.Id)
        machinePoolScope.OCIManagedMachinePool.Spec.ProviderID = common.String(fmt.Sprintf("oci://%s", *nodePool.Id))
        machinePoolScope.OCIManagedMachinePool.Spec.ID = nodePool.Id

        failureMessages := make([]string, 0)
        for _, node := range nodePool.Nodes </span><span class="cov8" title="1">{
                if node.NodeError != nil </span><span class="cov8" title="1">{
                        failureMessages = append(failureMessages, *node.NodeError.Message)
                }</span>
        }
        <span class="cov8" title="1">if len(failureMessages) &gt; 0 </span><span class="cov8" title="1">{
                machinePoolScope.OCIManagedMachinePool.Status.FailureMessages = failureMessages
        }</span>

        <span class="cov8" title="1">machinePoolScope.OCIManagedMachinePool.Status.NodepoolLifecycleState = fmt.Sprintf("%s", nodePool.LifecycleState)
        switch nodePool.LifecycleState </span>{
        case oke.NodePoolLifecycleStateCreating:<span class="cov8" title="1">
                machinePoolScope.Info("Node Pool is creating")
                err = r.reconcileManagedMachines(ctx, err, machinePoolScope, nodePool)
                if err != nil </span><span class="cov0" title="0">{
                        return reconcile.Result{}, err
                }</span>
                <span class="cov8" title="1">conditions.MarkFalse(machinePoolScope.OCIManagedMachinePool, infrav2exp.NodePoolReadyCondition, infrav2exp.NodePoolNotReadyReason, clusterv1.ConditionSeverityInfo, "")
                return reconcile.Result{RequeueAfter: 30 * time.Second}, nil</span>
        case oke.NodePoolLifecycleStateUpdating:<span class="cov8" title="1">
                machinePoolScope.Info("Node Pool is updating")
                err = r.reconcileManagedMachines(ctx, err, machinePoolScope, nodePool)
                if err != nil </span><span class="cov0" title="0">{
                        return reconcile.Result{}, err
                }</span>
                <span class="cov8" title="1">return reconcile.Result{RequeueAfter: 30 * time.Second}, nil</span>
        case oke.NodePoolLifecycleStateActive:<span class="cov8" title="1">
                machinePoolScope.Info("Node pool is active")
                instanceCount, err := machinePoolScope.SetListandSetMachinePoolInstances(ctx, nodePool)
                if err != nil </span><span class="cov0" title="0">{
                        return reconcile.Result{}, err
                }</span>
                <span class="cov8" title="1">machinePoolScope.SetReplicaCount(instanceCount)
                machinePoolScope.OCIManagedMachinePool.Status.Ready = true
                // record the event only when pool goes from not ready to ready state
                r.Recorder.Eventf(machinePoolScope.OCIManagedMachinePool, corev1.EventTypeNormal, "NodePoolReady",
                        "Node pool is in ready state")
                conditions.MarkTrue(machinePoolScope.OCIManagedMachinePool, infrav2exp.NodePoolReadyCondition)
                isUpdated, err := machinePoolScope.UpdateNodePool(ctx, nodePool)
                if err != nil </span><span class="cov0" title="0">{
                        return reconcile.Result{}, err
                }</span>
                <span class="cov8" title="1">if isUpdated </span><span class="cov8" title="1">{
                        return reconcile.Result{RequeueAfter: 30 * time.Second}, nil
                }</span>
                <span class="cov8" title="1">err = r.reconcileManagedMachines(ctx, err, machinePoolScope, nodePool)
                if err != nil </span><span class="cov0" title="0">{
                        return reconcile.Result{}, err
                }</span>

                // we reconcile every 5 minutes in case any reconciliation have happened behind the scenes by OKE service on
                // the node pool(removing unhealthy nodes etc) which has to be percolated to machinepool machines
                <span class="cov8" title="1">return reconcile.Result{RequeueAfter: 300 * time.Second}, nil</span>
        default:<span class="cov8" title="1">
                err := errors.Errorf("Node Pool status %s is unexpected", nodePool.LifecycleState)
                machinePoolScope.OCIManagedMachinePool.Status.FailureMessages = append(machinePoolScope.OCIManagedMachinePool.Status.FailureMessages, err.Error())
                conditions.MarkFalse(machinePoolScope.OCIManagedMachinePool, infrav2exp.NodePoolReadyCondition, infrav2exp.NodePoolProvisionFailedReason, clusterv1.ConditionSeverityError, "")
                r.Recorder.Eventf(machinePoolScope.OCIManagedMachinePool, corev1.EventTypeWarning, "ReconcileError",
                        "Node pool has invalid lifecycle state %s, lifecycle details is %s", nodePool.LifecycleState, nodePool.LifecycleDetails)
                return reconcile.Result{}, err</span>
        }
}

func (r *OCIManagedMachinePoolReconciler) reconcileManagedMachines(ctx context.Context, err error, machinePoolScope *scope.ManagedMachinePoolScope, nodePool *oke.NodePool) error <span class="cov8" title="1">{
        specInfraMachines := make([]infrav2exp.OCIMachinePoolMachine, 0)
        for _, node := range nodePool.Nodes </span><span class="cov8" title="1">{
                // deleted/failing nodes should not be added to spec
                if node.LifecycleState == oke.NodeLifecycleStateDeleted || node.LifecycleState == oke.NodeLifecycleStateFailing </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">ready := false
                if node.LifecycleState == oke.NodeLifecycleStateActive </span><span class="cov0" title="0">{
                        ready = true
                }</span>
                <span class="cov8" title="1">specInfraMachines = append(specInfraMachines, infrav2exp.OCIMachinePoolMachine{
                        ObjectMeta: metav1.ObjectMeta{
                                Name: *node.Name,
                        },
                        Spec: infrav2exp.OCIMachinePoolMachineSpec{
                                OCID:         node.Id,
                                ProviderID:   node.Id,
                                InstanceName: node.Name,
                                MachineType:  infrav2exp.Managed,
                        },
                        Status: infrav2exp.OCIMachinePoolMachineStatus{
                                Ready: ready,
                        },
                })</span>
        }
        <span class="cov8" title="1">params := cloudutil.MachineParams{
                Cluster:              machinePoolScope.Cluster,
                MachinePool:          machinePoolScope.MachinePool,
                InfraMachinePoolName: machinePoolScope.OCIManagedMachinePool.Name,
                Namespace:            machinePoolScope.OCIManagedMachinePool.Namespace,
                SpecInfraMachines:    specInfraMachines,
                Client:               r.Client,
                Logger:               machinePoolScope.Logger,
                InfraMachinePoolKind: machinePoolScope.OCIManagedMachinePool.Kind,
                InfraMachinePoolUID:  machinePoolScope.OCIManagedMachinePool.UID,
        }
        err = cloudutil.CreateMachinePoolMachinesIfNotExists(ctx, params)
        if err != nil </span><span class="cov0" title="0">{
                r.Recorder.Event(machinePoolScope.OCIManagedMachinePool, corev1.EventTypeWarning, "FailedToCreateNewMachines", err.Error())
                conditions.MarkFalse(machinePoolScope.OCIManagedMachinePool, clusterv1.ReadyCondition, "FailedToCreateNewMachines", clusterv1.ConditionSeverityWarning, "")
                return errors.Wrap(err, "failed to create missing machines")
        }</span>

        <span class="cov8" title="1">err = cloudutil.DeleteOrphanedMachinePoolMachines(ctx, params)
        if err != nil </span><span class="cov0" title="0">{
                conditions.MarkFalse(machinePoolScope.OCIManagedMachinePool, clusterv1.ReadyCondition, "FailedToDeleteOrphanedMachines", clusterv1.ConditionSeverityWarning, "")
                return errors.Wrap(err, "failed to delete orphaned machines")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (r *OCIManagedMachinePoolReconciler) reconcileDelete(ctx context.Context, machinePoolScope *scope.ManagedMachinePoolScope) (_ ctrl.Result, reterr error) <span class="cov8" title="1">{
        machinePoolScope.Info("Handling deleted OCIMachinePool")
        machinePool := machinePoolScope.OCIManagedMachinePool
        // Find existing Node Pool
        nodePool, err := machinePoolScope.FindNodePool(ctx)
        if err != nil </span><span class="cov8" title="1">{
                if ociutil.IsNotFound(err) </span><span class="cov8" title="1">{
                        controllerutil.RemoveFinalizer(machinePoolScope.OCIManagedMachinePool, infrav2exp.ManagedMachinePoolFinalizer)
                        machinePoolScope.Info("Node pool not found, may have been deleted")
                        conditions.MarkTrue(machinePoolScope.OCIManagedMachinePool, infrav2exp.NodePoolNotFoundReason)
                        machinePoolScope.OCIManagedMachinePool.Status.Ready = false
                        return reconcile.Result{}, nil
                }</span> else<span class="cov0" title="0"> {
                        return reconcile.Result{}, err
                }</span>
        }

        <span class="cov8" title="1">if nodePool == nil </span><span class="cov0" title="0">{
                machinePoolScope.Info("Node Pool is not found, may have been deleted")
                controllerutil.RemoveFinalizer(machinePoolScope.OCIManagedMachinePool, infrav2exp.ManagedMachinePoolFinalizer)
                conditions.MarkFalse(machinePool, infrav2exp.NodePoolReadyCondition, infrav2exp.NodePoolDeletedReason, clusterv1.ConditionSeverityWarning, "")
                return reconcile.Result{}, nil
        }</span>

        <span class="cov8" title="1">machinePoolScope.Info(fmt.Sprintf("Node Pool lifecycle state is %v", nodePool.LifecycleState))
        machinePoolScope.OCIManagedMachinePool.Status.NodepoolLifecycleState = fmt.Sprintf("%s", nodePool.LifecycleState)
        switch nodePool.LifecycleState </span>{
        case oke.NodePoolLifecycleStateDeleting:<span class="cov8" title="1">
                // Node Pool is already deleting
                machinePool.Status.Ready = false
                conditions.MarkFalse(machinePool, infrav2exp.NodePoolReadyCondition, infrav2exp.NodePoolDeletionInProgress, clusterv1.ConditionSeverityWarning, "")
                r.Recorder.Eventf(machinePool, corev1.EventTypeWarning, "DeletionInProgress", "Node Pool deletion in progress")
                machinePoolScope.Info("Node Pool is deleting")
                return reconcile.Result{RequeueAfter: 30 * time.Second}, nil</span>
        case oke.NodePoolLifecycleStateDeleted:<span class="cov8" title="1">
                controllerutil.RemoveFinalizer(machinePoolScope.OCIManagedMachinePool, infrav2exp.ManagedMachinePoolFinalizer)
                conditions.MarkFalse(machinePool, infrav2exp.NodePoolReadyCondition, infrav2exp.NodePoolDeletedReason, clusterv1.ConditionSeverityWarning, "")
                machinePoolScope.Info("Node Pool is already deleted")
                return reconcile.Result{}, nil</span>
        default:<span class="cov8" title="1">
                err = machinePoolScope.DeleteNodePool(ctx, nodePool)
                if err != nil </span><span class="cov0" title="0">{
                        machinePoolScope.Error(err, "Terminate node pool request failed")
                        return ctrl.Result{}, err
                }</span> else<span class="cov8" title="1"> {
                        machinePoolScope.OCIManagedMachinePool.Status.Ready = false
                        conditions.MarkFalse(machinePoolScope.OCIManagedMachinePool, infrav2exp.NodePoolReadyCondition, infrav2exp.NodePoolDeletionInProgress, clusterv1.ConditionSeverityWarning, "")
                        return reconcile.Result{RequeueAfter: 30 * time.Second}, nil
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file100" style="display: none">/*
Copyright (c) 2021, 2022 Oracle and/or its affiliates.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package controllers

import (
        "context"
        "fmt"
        "time"

        "github.com/go-logr/logr"
        infrastructurev1beta2 "github.com/oracle/cluster-api-provider-oci/api/v1beta2"
        "github.com/oracle/cluster-api-provider-oci/cloud/ociutil"
        "github.com/oracle/cluster-api-provider-oci/cloud/scope"
        cloudutil "github.com/oracle/cluster-api-provider-oci/cloud/util"
        infrav2exp "github.com/oracle/cluster-api-provider-oci/exp/api/v1beta2"
        "github.com/oracle/oci-go-sdk/v65/common"
        oke "github.com/oracle/oci-go-sdk/v65/containerengine"
        "github.com/pkg/errors"
        corev1 "k8s.io/api/core/v1"
        apierrors "k8s.io/apimachinery/pkg/api/errors"
        "k8s.io/apimachinery/pkg/runtime"
        "k8s.io/apimachinery/pkg/runtime/schema"
        "k8s.io/apimachinery/pkg/types"
        "k8s.io/client-go/tools/record"
        clusterv1 "sigs.k8s.io/cluster-api/api/core/v1beta1"
        expclusterv1 "sigs.k8s.io/cluster-api/api/core/v1beta1"
        "sigs.k8s.io/cluster-api/util"
        "sigs.k8s.io/cluster-api/util/annotations"
        "sigs.k8s.io/cluster-api/util/deprecated/v1beta1/conditions"
        "sigs.k8s.io/cluster-api/util/predicates"
        ctrl "sigs.k8s.io/controller-runtime"
        "sigs.k8s.io/controller-runtime/pkg/builder"
        "sigs.k8s.io/controller-runtime/pkg/client"
        "sigs.k8s.io/controller-runtime/pkg/client/apiutil"
        "sigs.k8s.io/controller-runtime/pkg/controller"
        "sigs.k8s.io/controller-runtime/pkg/controller/controllerutil"
        "sigs.k8s.io/controller-runtime/pkg/handler"
        "sigs.k8s.io/controller-runtime/pkg/log"
        "sigs.k8s.io/controller-runtime/pkg/reconcile"
)

// OCIVirtualMachinePoolReconciler reconciles a OCIVirtualMachinePool object
type OCIVirtualMachinePoolReconciler struct {
        client.Client
        Scheme         *runtime.Scheme
        Recorder       record.EventRecorder
        ClientProvider *scope.ClientProvider
        Region         string
}

//+kubebuilder:rbac:groups=infrastructure.cluster.x-k8s.io,resources=ocivirtualmachinepools,verbs=get;list;watch;create;update;patch;delete
//+kubebuilder:rbac:groups=infrastructure.cluster.x-k8s.io,resources=ocivirtualmachinepools/status,verbs=get;update;patch
//+kubebuilder:rbac:groups=cluster.x-k8s.io,resources=machinepools;machinepools/status,verbs=get;list;watch
//+kubebuilder:rbac:groups=infrastructure.cluster.x-k8s.io,resources=ocivirtualmachinepools/finalizers,verbs=update

// Reconcile is part of the main kubernetes reconciliation loop which aims to
// move the current state of the machinepool closer to the desired state.
//
// For more details, check Reconcile and its Result here:
// - https://pkg.go.dev/sigs.k8s.io/controller-runtime/pkg/reconcile
func (r *OCIVirtualMachinePoolReconciler) Reconcile(ctx context.Context, req ctrl.Request) (result ctrl.Result, reterr error) <span class="cov8" title="1">{
        logger := log.FromContext(ctx)
        logger.Info("Got reconciliation event for virtual machine pool")

        // Fetch the OCIVirtualMachinePool.
        ociVirtualMachinePool := &amp;infrav2exp.OCIVirtualMachinePool{}
        err := r.Get(ctx, req.NamespacedName, ociVirtualMachinePool)
        if err != nil </span><span class="cov8" title="1">{
                if apierrors.IsNotFound(err) </span><span class="cov8" title="1">{
                        return ctrl.Result{}, nil
                }</span>
                <span class="cov0" title="0">return ctrl.Result{}, err</span>
        }

        // Fetch the CAPI MachinePool
        <span class="cov8" title="1">machinePool, err := getOwnerMachinePool(ctx, r.Client, ociVirtualMachinePool.ObjectMeta)
        if err != nil </span><span class="cov0" title="0">{
                return reconcile.Result{}, err
        }</span>
        <span class="cov8" title="1">if machinePool == nil </span><span class="cov8" title="1">{
                r.Recorder.Eventf(ociVirtualMachinePool, corev1.EventTypeNormal, "OwnerRefNotSet", "Cluster Controller has not yet set OwnerRef")
                logger.Info("MachinePool Controller has not yet set OwnerRef")
                return reconcile.Result{}, nil
        }</span>
        <span class="cov8" title="1">logger = logger.WithValues("machinePool", machinePool.Name)

        // Fetch the Cluster.
        cluster, err := util.GetClusterFromMetadata(ctx, r.Client, ociVirtualMachinePool.ObjectMeta)
        if err != nil </span><span class="cov8" title="1">{
                r.Recorder.Eventf(ociVirtualMachinePool, corev1.EventTypeWarning, "ClusterDoesNotExist", "MachinePool is missing cluster label or cluster does not exist")
                logger.Info("MachinePool is missing cluster label or cluster does not exist")
                return reconcile.Result{}, nil
        }</span>
        <span class="cov0" title="0">logger = logger.WithValues("cluster", cluster.Name)

        // Return early if the object or Cluster is paused.
        if annotations.IsPaused(cluster, ociVirtualMachinePool) </span><span class="cov0" title="0">{
                logger.Info("OCIMachinePool or linked Cluster is marked as paused. Won't reconcile")
                return ctrl.Result{}, nil
        }</span>
        // Convert v1beta2 Cluster to v1beta1 for scope compatibility
        <span class="cov0" title="0">clusterV1beta1, err := cloudutil.ConvertClusterV1Beta2ToV1Beta1(cluster)
        if err != nil </span><span class="cov0" title="0">{
                return ctrl.Result{}, errors.Wrap(err, "failed to convert cluster to v1beta1")
        }</span>

        <span class="cov0" title="0">ociManagedCluster := &amp;infrastructurev1beta2.OCIManagedCluster{}
        ociClusterName := client.ObjectKey{
                Namespace: clusterV1beta1.Namespace,
                Name:      clusterV1beta1.Spec.InfrastructureRef.Name,
        }

        if err := r.Client.Get(ctx, ociClusterName, ociManagedCluster); err != nil </span><span class="cov0" title="0">{
                logger.Info("Cluster is not available yet")
                r.Recorder.Eventf(ociVirtualMachinePool, corev1.EventTypeWarning, "ClusterNotAvailable", "Cluster is not available yet")
                logger.V(2).Info("OCICluster is not available yet")
                return ctrl.Result{}, nil
        }</span>

        <span class="cov0" title="0">clusterAccessor := scope.OCIManagedCluster{
                OCIManagedCluster: ociManagedCluster,
        }
        _, _, clients, err := cloudutil.InitClientsAndRegion(ctx, r.Client, r.Region, clusterAccessor, r.ClientProvider)
        if err != nil </span><span class="cov0" title="0">{
                return ctrl.Result{}, err
        }</span>

        <span class="cov0" title="0">controlPlane := &amp;infrastructurev1beta2.OCIManagedControlPlane{}
        controlPlaneRef := types.NamespacedName{
                Name:      clusterV1beta1.Spec.ControlPlaneRef.Name,
                Namespace: clusterV1beta1.Namespace,
        }

        if err := r.Get(ctx, controlPlaneRef, controlPlane); err != nil </span><span class="cov0" title="0">{
                return reconcile.Result{}, errors.Wrap(err, "failed to get control plane ref")
        }</span>

        // Create the machine pool scope
        <span class="cov0" title="0">machinePoolScope, err := scope.NewVirtualMachinePoolScope(scope.VirtualMachinePoolScopeParams{
                Client:                  r.Client,
                ComputeManagementClient: clients.ComputeManagementClient,
                Logger:                  &amp;logger,
                Cluster:                 clusterV1beta1,
                OCIManagedCluster:       ociManagedCluster,
                MachinePool:             machinePool,
                OCIVirtualMachinePool:   ociVirtualMachinePool,
                ContainerEngineClient:   clients.ContainerEngineClient,
                OCIManagedControlPlane:  controlPlane,
        })
        if err != nil </span><span class="cov0" title="0">{
                return ctrl.Result{}, errors.Errorf("failed to create scope: %+v", err)
        }</span>

        // Always close the scope when exiting this function so we can persist any virtual machine pool changes.
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err := machinePoolScope.Close(ctx); err != nil &amp;&amp; reterr == nil </span><span class="cov0" title="0">{
                        reterr = err
                }</span>
        }()

        // Handle deleted machines
        <span class="cov0" title="0">if !ociVirtualMachinePool.DeletionTimestamp.IsZero() </span><span class="cov0" title="0">{
                return r.reconcileDelete(ctx, machinePoolScope)
        }</span>

        // Handle non-deleted machines
        <span class="cov0" title="0">return r.reconcileNormal(ctx, logger, machinePoolScope)</span>
}

// SetupWithManager sets up the controller with the Manager.
func (r *OCIVirtualMachinePoolReconciler) SetupWithManager(ctx context.Context, mgr ctrl.Manager, options controller.Options) error <span class="cov0" title="0">{
        logger := log.FromContext(ctx)
        gvk, err := apiutil.GVKForObject(new(infrav2exp.OCIVirtualMachinePool), mgr.GetScheme())
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrapf(err, "failed to find GVK for OCIVirtualMachinePool")
        }</span>
        <span class="cov0" title="0">clusterToObjectFunc, err := util.ClusterToTypedObjectsMapper(r.Client, &amp;infrav2exp.OCIVirtualMachinePoolList{}, mgr.GetScheme())
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrapf(err, "failed to create mapper for Cluster to OCIVirtualMachinePool")
        }</span>
        <span class="cov0" title="0">managedClusterToVirtualMachinePoolMapFunc := managedClusterToVirtualMachinePoolMapFunc(r.Client, gvk, logger)
        return ctrl.NewControllerManagedBy(mgr).
                WithOptions(options).
                For(&amp;infrav2exp.OCIVirtualMachinePool{}).
                Watches(
                        &amp;expclusterv1.MachinePool{},
                        handler.EnqueueRequestsFromMapFunc(machinePoolToInfrastructureMapFunc(infrastructurev1beta2.
                                GroupVersion.WithKind(scope.OCIVirtualMachinePoolKind), logger)),
                ).
                Watches(
                        &amp;infrastructurev1beta2.OCIManagedCluster{},
                        handler.EnqueueRequestsFromMapFunc(managedClusterToVirtualMachinePoolMapFunc),
                ).
                Watches(
                        &amp;clusterv1.Cluster{},
                        handler.EnqueueRequestsFromMapFunc(clusterToObjectFunc),
                        builder.WithPredicates(
                                predicates.ClusterPausedTransitionsOrInfrastructureProvisioned(mgr.GetScheme(), ctrl.LoggerFrom(ctx)),
                        ),
                ).
                WithEventFilter(predicates.ResourceNotPaused(mgr.GetScheme(), ctrl.LoggerFrom(ctx))).
                Complete(r)</span>
}

func managedClusterToVirtualMachinePoolMapFunc(c client.Client, gvk schema.GroupVersionKind, log logr.Logger) handler.MapFunc <span class="cov0" title="0">{
        return func(ctx context.Context, o client.Object) []reconcile.Request </span><span class="cov0" title="0">{
                ociCluster, ok := o.(*infrastructurev1beta2.OCIManagedCluster)
                if !ok </span><span class="cov0" title="0">{
                        panic(fmt.Sprintf("Expected a OCIManagedControlPlane but got a %T", o))</span>
                }

                <span class="cov0" title="0">if !ociCluster.ObjectMeta.DeletionTimestamp.IsZero() </span><span class="cov0" title="0">{
                        return nil
                }</span>

                <span class="cov0" title="0">cluster, err := util.GetOwnerCluster(ctx, c, ociCluster.ObjectMeta)
                if err != nil </span><span class="cov0" title="0">{
                        log.Error(err, "couldn't get OCI control plane owner ObjectKey")
                        return nil
                }</span>
                <span class="cov0" title="0">if cluster == nil </span><span class="cov0" title="0">{
                        return nil
                }</span>

                <span class="cov0" title="0">managedPoolForClusterList := expclusterv1.MachinePoolList{}
                if err := c.List(
                        ctx, &amp;managedPoolForClusterList, client.InNamespace(cluster.Namespace), client.MatchingLabels{clusterv1.ClusterNameLabel: cluster.Name},
                ); err != nil </span><span class="cov0" title="0">{
                        log.Error(err, "couldn't list pools for cluster")
                        return nil
                }</span>

                <span class="cov0" title="0">mapFunc := machinePoolToInfrastructureMapFunc(gvk, log)

                var results []ctrl.Request
                for i := range managedPoolForClusterList.Items </span><span class="cov0" title="0">{
                        managedPool := mapFunc(ctx, &amp;managedPoolForClusterList.Items[i])
                        results = append(results, managedPool...)
                }</span>

                <span class="cov0" title="0">return results</span>
        }
}

func (r *OCIVirtualMachinePoolReconciler) reconcileNormal(ctx context.Context, logger logr.Logger, machinePoolScope *scope.VirtualMachinePoolScope) (ctrl.Result, error) <span class="cov8" title="1">{
        machinePoolScope.Info("Handling reconcile OCIVirtualMachinePool")
        // If the OCIMachinePool doesn't have our finalizer, add it.
        controllerutil.AddFinalizer(machinePoolScope.OCIVirtualMachinePool, infrav2exp.VirtualMachinePoolFinalizer)

        if !machinePoolScope.Cluster.Status.InfrastructureReady </span><span class="cov0" title="0">{
                logger.Info("Cluster infrastructure is not ready yet")
                return reconcile.Result{}, nil
        }</span>

        <span class="cov8" title="1">if !machinePoolScope.OCIManagedControlPlane.Status.Ready </span><span class="cov0" title="0">{
                logger.Info("Cluster control plane is not ready yet")
                return reconcile.Result{}, nil
        }</span>

        // Find existing Virtual Node Pool
        <span class="cov8" title="1">nodePool, err := machinePoolScope.FindVirtualNodePool(ctx)
        if err != nil </span><span class="cov0" title="0">{
                r.Recorder.Event(machinePoolScope.OCIVirtualMachinePool, corev1.EventTypeWarning, "ReconcileError", err.Error())
                conditions.MarkUnknown(machinePoolScope.OCIVirtualMachinePool, infrav2exp.VirtualNodePoolReadyCondition, infrav2exp.VirtualNodePoolNotFoundReason, "")
                return ctrl.Result{}, err
        }</span>

        <span class="cov8" title="1">if nodePool == nil </span><span class="cov8" title="1">{
                if nodePool, err = machinePoolScope.CreateVirtualNodePool(ctx); err != nil </span><span class="cov0" title="0">{
                        r.Recorder.Event(machinePoolScope.OCIVirtualMachinePool, corev1.EventTypeWarning, "ReconcileError", err.Error())
                        conditions.MarkFalse(machinePoolScope.OCIVirtualMachinePool, infrav2exp.VirtualNodePoolReadyCondition, infrav2exp.VirtualNodePoolProvisionFailedReason, clusterv1.ConditionSeverityError, "")
                        return ctrl.Result{}, err
                }</span>
                // record the event only when node pool is created
                <span class="cov8" title="1">r.Recorder.Eventf(machinePoolScope.OCIVirtualMachinePool, corev1.EventTypeNormal, "VirtualNodePool",
                        "Created new Virtual Node Pool: %s", machinePoolScope.OCIVirtualMachinePool.GetName())</span>
        }

        <span class="cov8" title="1">machinePoolScope.Info("VirtualNode Pool found", "VirtualNodePoolId", *nodePool.Id)
        machinePoolScope.OCIVirtualMachinePool.Spec.ProviderID = common.String(fmt.Sprintf("oci://%s", *nodePool.Id))
        machinePoolScope.OCIVirtualMachinePool.Spec.ID = nodePool.Id

        machinePoolScope.OCIVirtualMachinePool.Status.NodepoolLifecycleState = fmt.Sprintf("%s", nodePool.LifecycleState)

        switch nodePool.LifecycleState </span>{
        case oke.VirtualNodePoolLifecycleStateCreating:<span class="cov8" title="1">
                machinePoolScope.Info("Node Pool is creating")
                conditions.MarkFalse(machinePoolScope.OCIVirtualMachinePool, infrav2exp.VirtualNodePoolReadyCondition, infrav2exp.VirtualNodePoolNotReadyReason, clusterv1.ConditionSeverityInfo, "")
                return reconcile.Result{RequeueAfter: 30 * time.Second}, nil</span>
        case oke.VirtualNodePoolLifecycleStateUpdating:<span class="cov8" title="1">
                machinePoolScope.Info("Virtual Node Pool is updating")
                return reconcile.Result{RequeueAfter: 30 * time.Second}, nil</span>
        case oke.VirtualNodePoolLifecycleStateActive:<span class="cov8" title="1">
                machinePoolScope.Info("Virtual Node pool is active")
                machines, err := machinePoolScope.ListandSetMachinePoolInstances(ctx, nodePool)
                if err != nil </span><span class="cov0" title="0">{
                        return reconcile.Result{}, err
                }</span>
                <span class="cov8" title="1">providerIDList := make([]string, 0)
                for _, machine := range machines </span><span class="cov8" title="1">{
                        if machine.Status.Ready </span><span class="cov8" title="1">{
                                providerIDList = append(providerIDList, *machine.Spec.ProviderID)
                        }</span>
                }
                <span class="cov8" title="1">machinePoolScope.OCIVirtualMachinePool.Spec.ProviderIDList = providerIDList
                machinePoolScope.SetReplicaCount(int32(len(providerIDList)))

                err = r.reconcileVirtualMachines(ctx, err, machinePoolScope, machines)
                if err != nil </span><span class="cov0" title="0">{
                        return reconcile.Result{}, err
                }</span>
                <span class="cov8" title="1">machinePoolScope.OCIVirtualMachinePool.Status.Ready = true
                // record the event only when pool goes from not ready to ready state
                r.Recorder.Eventf(machinePoolScope.OCIVirtualMachinePool, corev1.EventTypeNormal, "VirtualNodePoolReady",
                        "Node pool is in ready state")
                conditions.MarkTrue(machinePoolScope.OCIVirtualMachinePool, infrav2exp.VirtualNodePoolReadyCondition)
                isUpdated, err := machinePoolScope.UpdateVirtualNodePool(ctx, nodePool)
                if err != nil </span><span class="cov0" title="0">{
                        return reconcile.Result{}, err
                }</span>
                <span class="cov8" title="1">if isUpdated </span><span class="cov8" title="1">{
                        return reconcile.Result{RequeueAfter: 30 * time.Second}, nil
                }</span>

                // we reconcile every 5 minutes in case any reconciliation have happened behind the scenes by OKE service on
                // the virtual node pool(removing unhealthy nodes etc) which has to be percolated to machinepool machines
                <span class="cov8" title="1">return reconcile.Result{RequeueAfter: 300 * time.Second}, nil</span>
        default:<span class="cov8" title="1">
                err := errors.Errorf("Virtual Node Pool status %s is unexpected", nodePool.LifecycleState)
                machinePoolScope.OCIVirtualMachinePool.Status.FailureMessages = append(machinePoolScope.OCIVirtualMachinePool.Status.FailureMessages, err.Error())
                conditions.MarkFalse(machinePoolScope.OCIVirtualMachinePool, infrav2exp.VirtualNodePoolReadyCondition, infrav2exp.VirtualNodePoolProvisionFailedReason, clusterv1.ConditionSeverityError, "")
                r.Recorder.Eventf(machinePoolScope.OCIVirtualMachinePool, corev1.EventTypeWarning, "ReconcileError",
                        "Virtual Node pool has invalid lifecycle state %s, lifecycle details is %s", nodePool.LifecycleState, nodePool.LifecycleDetails)
                return reconcile.Result{}, err</span>
        }
}

func (r *OCIVirtualMachinePoolReconciler) reconcileDelete(ctx context.Context, machinePoolScope *scope.VirtualMachinePoolScope) (_ ctrl.Result, reterr error) <span class="cov8" title="1">{
        machinePoolScope.Info("Handling deleted OCIMachinePool")
        machinePool := machinePoolScope.OCIVirtualMachinePool
        // Find existing Virtual Node Pool
        nodePool, err := machinePoolScope.FindVirtualNodePool(ctx)
        if err != nil </span><span class="cov8" title="1">{
                if ociutil.IsNotFound(err) </span><span class="cov8" title="1">{
                        controllerutil.RemoveFinalizer(machinePoolScope.OCIVirtualMachinePool, infrav2exp.VirtualMachinePoolFinalizer)
                        machinePoolScope.Info("Node pool not found, may have been deleted")
                        conditions.MarkTrue(machinePoolScope.OCIVirtualMachinePool, infrav2exp.VirtualNodePoolNotFoundReason)
                        machinePoolScope.OCIVirtualMachinePool.Status.Ready = false
                        return reconcile.Result{}, nil
                }</span> else<span class="cov0" title="0"> {
                        return reconcile.Result{}, err
                }</span>
        }

        <span class="cov8" title="1">if nodePool == nil </span><span class="cov0" title="0">{
                machinePoolScope.Info("Node Pool is not found, may have been deleted")
                controllerutil.RemoveFinalizer(machinePoolScope.OCIVirtualMachinePool, infrav2exp.VirtualMachinePoolFinalizer)
                conditions.MarkFalse(machinePool, infrav2exp.VirtualNodePoolReadyCondition, infrav2exp.VirtualNodePoolDeletedReason, clusterv1.ConditionSeverityWarning, "")
                return reconcile.Result{}, nil
        }</span>

        <span class="cov8" title="1">machinePoolScope.OCIVirtualMachinePool.Status.NodepoolLifecycleState = fmt.Sprintf("%s", nodePool.LifecycleState)
        machinePoolScope.Info(fmt.Sprintf("Node Pool lifecycle state is %v", nodePool.LifecycleState))
        switch nodePool.LifecycleState </span>{
        case oke.VirtualNodePoolLifecycleStateDeleting:<span class="cov8" title="1">
                // Node Pool is already deleting
                machinePool.Status.Ready = false
                conditions.MarkFalse(machinePool, infrav2exp.VirtualNodePoolReadyCondition, infrav2exp.VirtualNodePoolDeletionInProgress, clusterv1.ConditionSeverityWarning, "")
                r.Recorder.Eventf(machinePool, corev1.EventTypeWarning, "DeletionInProgress", "Virtual Node Pool deletion in progress")
                machinePoolScope.Info("Node Pool is deleting")
                return reconcile.Result{RequeueAfter: 30 * time.Second}, nil</span>
        case oke.VirtualNodePoolLifecycleStateDeleted:<span class="cov8" title="1">
                controllerutil.RemoveFinalizer(machinePoolScope.OCIVirtualMachinePool, infrav2exp.VirtualMachinePoolFinalizer)
                conditions.MarkFalse(machinePool, infrav2exp.VirtualNodePoolReadyCondition, infrav2exp.VirtualNodePoolDeletedReason, clusterv1.ConditionSeverityWarning, "")
                machinePoolScope.Info("Virtual Node Pool is already deleted")
                return reconcile.Result{}, nil</span>
        default:<span class="cov8" title="1">
                err = machinePoolScope.DeleteVirtualNodePool(ctx, nodePool)
                if err != nil </span><span class="cov0" title="0">{
                        machinePoolScope.Error(err, "Terminate virtual node pool request failed")
                        return ctrl.Result{}, err
                }</span> else<span class="cov8" title="1"> {
                        machinePoolScope.OCIVirtualMachinePool.Status.Ready = false
                        conditions.MarkFalse(machinePoolScope.OCIVirtualMachinePool, infrav2exp.VirtualNodePoolReadyCondition, infrav2exp.VirtualNodePoolDeletionInProgress, clusterv1.ConditionSeverityWarning, "")
                        return reconcile.Result{RequeueAfter: 30 * time.Second}, nil
                }</span>
        }
}

func (r *OCIVirtualMachinePoolReconciler) reconcileVirtualMachines(ctx context.Context, err error, machinePoolScope *scope.VirtualMachinePoolScope, specInfraMachines []infrav2exp.OCIMachinePoolMachine) error <span class="cov8" title="1">{
        params := cloudutil.MachineParams{
                Cluster:              machinePoolScope.Cluster,
                MachinePool:          machinePoolScope.MachinePool,
                InfraMachinePoolName: machinePoolScope.OCIVirtualMachinePool.Name,
                Namespace:            machinePoolScope.OCIVirtualMachinePool.Namespace,
                SpecInfraMachines:    specInfraMachines,
                Client:               r.Client,
                Logger:               machinePoolScope.Logger,
                InfraMachinePoolKind: machinePoolScope.OCIVirtualMachinePool.Kind,
                InfraMachinePoolUID:  machinePoolScope.OCIVirtualMachinePool.UID,
        }
        err = cloudutil.CreateMachinePoolMachinesIfNotExists(ctx, params)
        if err != nil </span><span class="cov0" title="0">{
                r.Recorder.Event(machinePoolScope.OCIVirtualMachinePool, corev1.EventTypeWarning, "FailedToCreateNewMachines", err.Error())
                conditions.MarkFalse(machinePoolScope.OCIVirtualMachinePool, clusterv1.ReadyCondition, "FailedToCreateNewMachines", clusterv1.ConditionSeverityWarning, "")
                return errors.Wrap(err, "failed to create missing machines")
        }</span>

        <span class="cov8" title="1">err = cloudutil.DeleteOrphanedMachinePoolMachines(ctx, params)
        if err != nil </span><span class="cov0" title="0">{
                r.Recorder.Event(machinePoolScope.OCIVirtualMachinePool, corev1.EventTypeWarning, "FailedToDeleteOrphanedMachines", err.Error())
                conditions.MarkFalse(machinePoolScope.OCIVirtualMachinePool, clusterv1.ReadyCondition, "FailedToDeleteOrphanedMachines", clusterv1.ConditionSeverityWarning, "")
                return errors.Wrap(err, "failed to delete orphaned machines")
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file101" style="display: none">/*
Copyright (c) 2022 Oracle and/or its affiliates.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package feature

import (
        "k8s.io/apimachinery/pkg/util/runtime"
        "k8s.io/component-base/featuregate"
)

const (
        // MachinePool is used to enable instance pool support
        MachinePool featuregate.Feature = "MachinePool"

        // OKE is used to enable manged cluster(OKE)
        OKE featuregate.Feature = "OKE"
)

func init() <span class="cov0" title="0">{
        runtime.Must(MutableGates.Add(defaultCAPOCIFeatureGates))
}</span>

// defaultCAPOCIFeatureGates consists of all known capa-specific feature keys.
// To add a new feature, define a key for it above and add it here.
var defaultCAPOCIFeatureGates = map[featuregate.Feature]featuregate.FeatureSpec{
        // Every feature should be initiated here:
        MachinePool: {Default: true, PreRelease: featuregate.Beta},
        // Every feature should be initiated here:
        OKE: {Default: true, PreRelease: featuregate.Beta},
}
</pre>
		
		<pre class="file" id="file102" style="display: none">/*
Copyright (c) 2021, 2022 Oracle and/or its affiliates.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package main

import (
        "flag"
        "os"
        "time"

        infrastructurev1beta1 "github.com/oracle/cluster-api-provider-oci/api/v1beta1"
        infrastructurev1beta2 "github.com/oracle/cluster-api-provider-oci/api/v1beta2"
        "github.com/oracle/cluster-api-provider-oci/cloud/config"
        "github.com/oracle/cluster-api-provider-oci/cloud/scope"
        "github.com/oracle/cluster-api-provider-oci/controllers"
        expV1Beta1 "github.com/oracle/cluster-api-provider-oci/exp/api/v1beta1"
        expV1Beta2 "github.com/oracle/cluster-api-provider-oci/exp/api/v1beta2"
        expcontrollers "github.com/oracle/cluster-api-provider-oci/exp/controllers"
        "github.com/oracle/cluster-api-provider-oci/feature"
        "github.com/oracle/cluster-api-provider-oci/version"
        "github.com/oracle/oci-go-sdk/v65/common"
        "github.com/spf13/pflag"
        "k8s.io/apimachinery/pkg/runtime"
        utilruntime "k8s.io/apimachinery/pkg/util/runtime"
        clientgoscheme "k8s.io/client-go/kubernetes/scheme"
        _ "k8s.io/client-go/plugin/pkg/client/auth"
        "k8s.io/client-go/tools/leaderelection/resourcelock"
        "k8s.io/component-base/logs"
        logsV1 "k8s.io/component-base/logs/api/v1"
        _ "k8s.io/component-base/logs/json/register"
        "k8s.io/klog/v2"
        clusterv1 "sigs.k8s.io/cluster-api/api/core/v1beta1"
        expclusterv1 "sigs.k8s.io/cluster-api/api/core/v1beta1"
        ctrl "sigs.k8s.io/controller-runtime"
        "sigs.k8s.io/controller-runtime/pkg/cache"
        "sigs.k8s.io/controller-runtime/pkg/controller"
        "sigs.k8s.io/controller-runtime/pkg/healthz"
        "sigs.k8s.io/controller-runtime/pkg/log/zap"
        metricsserver "sigs.k8s.io/controller-runtime/pkg/metrics/server"
        "sigs.k8s.io/controller-runtime/pkg/webhook"
)

var (
        scheme     = runtime.NewScheme()
        setupLog   = ctrl.Log.WithName("setup")
        logOptions = logs.NewOptions()
)

const (
        AuthConfigDirectory = "AUTH_CONFIG_DIR"
)

func init() <span class="cov0" title="0">{
        utilruntime.Must(clientgoscheme.AddToScheme(scheme))
        utilruntime.Must(infrastructurev1beta1.AddToScheme(scheme))
        utilruntime.Must(infrastructurev1beta2.AddToScheme(scheme))
        utilruntime.Must(clusterv1.AddToScheme(scheme))
        utilruntime.Must(expV1Beta1.AddToScheme(scheme))
        utilruntime.Must(expV1Beta2.AddToScheme(scheme))
        utilruntime.Must(expclusterv1.AddToScheme(scheme))
        //+kubebuilder:scaffold:scheme
}</span>

func main() <span class="cov0" title="0">{
        var metricsAddr string
        var enableLeaderElection bool
        var leaderElectionNamespace string
        var leaderElectionLeaseDuration time.Duration
        var leaderElectionRenewDeadline time.Duration
        var leaderElectionRetryPeriod time.Duration
        var watchNamespace string
        var probeAddr string
        var webhookPort int
        var webhookCertDir string
        // Flags for reconciler concurrency
        var ociClusterConcurrency int
        var ociMachineConcurrency int
        var ociMachinePoolConcurrency int
        var initOciClientsOnStartup bool
        var enableInstanceMetadataServiceLookup bool

        fs := pflag.CommandLine
        logs.AddFlags(fs, logs.SkipLoggingConfigurationFlags())
        logsV1.AddFlags(logOptions, fs)

        flag.StringVar(&amp;metricsAddr, "metrics-bind-address", ":8080", "The address the metric endpoint binds to.")
        flag.StringVar(&amp;probeAddr, "health-probe-bind-address", ":8081", "The address the probe endpoint binds to.")
        flag.BoolVar(&amp;enableLeaderElection, "leader-elect", false,
                "Enable leader election for controller manager. "+
                        "Enabling this will ensure there is only one active controller manager.")
        flag.StringVar(
                &amp;leaderElectionNamespace,
                "leader-election-namespace",
                "",
                "Namespace that the controller performs leader election in. If unspecified, the controller will discover which namespace it is running in.",
        )
        flag.DurationVar(
                &amp;leaderElectionLeaseDuration,
                "leader-elect-lease-duration",
                15*time.Second,
                "Interval at which non-leader candidates will wait to force acquire leadership (duration string)",
        )
        flag.DurationVar(
                &amp;leaderElectionRenewDeadline,
                "leader-elect-renew-deadline",
                10*time.Second,
                "Duration that the leading controller manager will retry refreshing leadership before giving up (duration string)",
        )
        flag.DurationVar(
                &amp;leaderElectionRetryPeriod,
                "leader-elect-retry-period",
                2*time.Second,
                "Duration the LeaderElector clients should wait between tries of actions (duration string)",
        )
        flag.IntVar(&amp;webhookPort,
                "webhook-port",
                9443,
                "Webhook Server port.",
        )
        flag.StringVar(&amp;webhookCertDir, "webhook-cert-dir", "/tmp/k8s-webhook-server/serving-certs/",
                "Webhook cert dir, only used when webhook-port is specified.")
        flag.IntVar(
                &amp;ociClusterConcurrency,
                "ocicluster-concurrency",
                5,
                "Number of OciClusters to process simultaneously",
        )
        flag.IntVar(
                &amp;ociMachineConcurrency,
                "ocimachine-concurrency",
                10,
                "Number of OciMachines to process simultaneously",
        )
        flag.IntVar(
                &amp;ociMachinePoolConcurrency,
                "ocimachinepool-concurrency",
                5,
                "Number of OciMachinePools to process simultaneously",
        )
        flag.BoolVar(
                &amp;initOciClientsOnStartup,
                "init-oci-clients-on-startup",
                true,
                "Initialize OCI clients on startup",
        )
        flag.StringVar(
                &amp;watchNamespace,
                "namespace",
                "",
                "Namespace that the controller watches to reconcile cluster-api objects. If unspecified, the controller watches for cluster-api objects across all namespaces.",
        )
        flag.BoolVar(
                &amp;enableInstanceMetadataServiceLookup,
                "enable-instance-metadata-service-lookup",
                false,
                "Initialize OCI clients on startup",
        )

        opts := zap.Options{
                Development: true,
        }
        opts.BindFlags(flag.CommandLine)

        // Need to use pflags for kubernetes feature flags
        pflag.CommandLine.AddGoFlagSet(flag.CommandLine)
        feature.MutableGates.AddFlag(pflag.CommandLine)
        pflag.Parse()

        if err := logsV1.ValidateAndApply(logOptions, nil); err != nil </span><span class="cov0" title="0">{
                setupLog.Error(err, "unable to start manager")
                os.Exit(1)
        }</span>

        // klog.Background will automatically use the right logger.
        <span class="cov0" title="0">ctrl.SetLogger(klog.Background())

        var watchNamespaces map[string]cache.Config
        if watchNamespace != "" </span><span class="cov0" title="0">{
                watchNamespaces = map[string]cache.Config{
                        watchNamespace: {},
                }
        }</span>

        <span class="cov0" title="0">mgr, err := ctrl.NewManager(ctrl.GetConfigOrDie(), ctrl.Options{
                Scheme: scheme,
                Metrics: metricsserver.Options{
                        BindAddress: metricsAddr,
                },
                WebhookServer: webhook.NewServer(webhook.Options{
                        Port:    webhookPort,
                        CertDir: webhookCertDir,
                }),
                HealthProbeBindAddress:     probeAddr,
                LeaderElection:             enableLeaderElection,
                LeaderElectionID:           "controller-leader-elect-capoci",
                LeaderElectionResourceLock: resourcelock.LeasesResourceLock,
                LeaderElectionNamespace:    leaderElectionNamespace,
                LeaseDuration:              &amp;leaderElectionLeaseDuration,
                RenewDeadline:              &amp;leaderElectionRenewDeadline,
                RetryPeriod:                &amp;leaderElectionRetryPeriod,
                Cache: cache.Options{
                        DefaultNamespaces: watchNamespaces,
                },
        })
        if err != nil </span><span class="cov0" title="0">{
                setupLog.Error(err, "unable to start manager")
                os.Exit(1)
        }</span>
        // Setup the context that's going to be used in controllers and for the manager.
        <span class="cov0" title="0">ctx := ctrl.SetupSignalHandler()

        var clientProvider *scope.ClientProvider
        var region string
        if initOciClientsOnStartup </span><span class="cov0" title="0">{
                authConfigDir := os.Getenv(AuthConfigDirectory)
                if authConfigDir == "" </span><span class="cov0" title="0">{
                        setupLog.Error(err, "auth config directory environment variable is not set")
                        os.Exit(1)
                }</span>

                <span class="cov0" title="0">authConfig, err := config.FromDir(authConfigDir)
                if err != nil </span><span class="cov0" title="0">{
                        setupLog.Error(err, "invalid auth config file")
                        os.Exit(1)
                }</span>

                <span class="cov0" title="0">setupLog.Info("CAPOCI Version", "version", version.GitVersion)
                ociAuthConfigProvider, err := config.NewConfigurationProvider(authConfig)
                if err != nil </span><span class="cov0" title="0">{
                        setupLog.Error(err, "authentication provider could not be initialised")
                        os.Exit(1)
                }</span>

                <span class="cov0" title="0">region, err = ociAuthConfigProvider.Region()
                if err != nil </span><span class="cov0" title="0">{
                        setupLog.Error(err, "unable to get OCI region from AuthConfigProvider")
                        os.Exit(1)
                }</span>

                <span class="cov0" title="0">clientProvider, err = scope.NewClientProvider(scope.ClientProviderParams{
                        OciAuthConfigProvider: ociAuthConfigProvider})
                if err != nil </span><span class="cov0" title="0">{
                        setupLog.Error(err, "unable to create OCI ClientProvider")
                        os.Exit(1)
                }</span>
                <span class="cov0" title="0">_, err = clientProvider.GetOrBuildClient(region)
                if err != nil </span><span class="cov0" title="0">{
                        setupLog.Error(err, "authentication provider could not be initialised")
                        os.Exit(1)
                }</span>
        }
        <span class="cov0" title="0">if enableInstanceMetadataServiceLookup </span><span class="cov0" title="0">{
                common.EnableInstanceMetadataServiceLookup()
        }</span>
        <span class="cov0" title="0">if err = (&amp;controllers.OCIClusterReconciler{
                Client:         mgr.GetClient(),
                Scheme:         mgr.GetScheme(),
                Region:         region,
                ClientProvider: clientProvider,
                Recorder:       mgr.GetEventRecorderFor("ocicluster-controller"),
        }).SetupWithManager(ctx, mgr, controller.Options{MaxConcurrentReconciles: ociClusterConcurrency}); err != nil </span><span class="cov0" title="0">{
                setupLog.Error(err, "unable to create controller", "controller", scope.OCIClusterKind)
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">if err = (&amp;controllers.OCIMachineReconciler{
                Client:         mgr.GetClient(),
                Scheme:         mgr.GetScheme(),
                ClientProvider: clientProvider,
                Region:         region,
                Recorder:       mgr.GetEventRecorderFor("ocimachine-controller"),
        }).SetupWithManager(ctx, mgr, controller.Options{MaxConcurrentReconciles: ociMachineConcurrency}); err != nil </span><span class="cov0" title="0">{
                setupLog.Error(err, "unable to create controller", "controller", scope.OCIMachineKind)
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">if err = (&amp;controllers.OCIManagedClusterReconciler{
                Client:         mgr.GetClient(),
                Scheme:         mgr.GetScheme(),
                Region:         region,
                ClientProvider: clientProvider,
                Recorder:       mgr.GetEventRecorderFor("ocimanagedcluster-controller"),
        }).SetupWithManager(ctx, mgr, controller.Options{MaxConcurrentReconciles: ociClusterConcurrency}); err != nil </span><span class="cov0" title="0">{
                setupLog.Error(err, "unable to create controller", "controller", scope.OCIManagedClusterKind)
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">if err = (&amp;controllers.OCIManagedClusterControlPlaneReconciler{
                Client:         mgr.GetClient(),
                Scheme:         mgr.GetScheme(),
                Region:         region,
                ClientProvider: clientProvider,
                Recorder:       mgr.GetEventRecorderFor("ocimanagedclustercontrolplane-controller"),
        }).SetupWithManager(ctx, mgr, controller.Options{MaxConcurrentReconciles: ociClusterConcurrency}); err != nil </span><span class="cov0" title="0">{
                setupLog.Error(err, "unable to create controller", "controller", scope.OCIManagedClusterControlPlaneKind)
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">if feature.Gates.Enabled(feature.MachinePool) </span><span class="cov0" title="0">{
                setupLog.Info("MACHINE POOL experimental feature enabled")
                setupLog.V(1).Info("enabling machine pool controller")
                if err := (&amp;expcontrollers.OCIMachinePoolReconciler{
                        Client:         mgr.GetClient(),
                        Scheme:         mgr.GetScheme(),
                        ClientProvider: clientProvider,
                        Recorder:       mgr.GetEventRecorderFor("ocimachinepool-controller"),
                        Region:         region,
                }).SetupWithManager(ctx, mgr, controller.Options{MaxConcurrentReconciles: ociMachinePoolConcurrency}); err != nil </span><span class="cov0" title="0">{
                        setupLog.Error(err, "unable to create controller", "controller", scope.OCIMachinePoolKind)
                        os.Exit(1)
                }</span>

                <span class="cov0" title="0">setupLog.Info("OKE experimental feature enabled")
                setupLog.V(1).Info("enabling managed machine pool controller")
                if err = (&amp;expcontrollers.OCIManagedMachinePoolReconciler{
                        Client:         mgr.GetClient(),
                        Scheme:         mgr.GetScheme(),
                        Region:         region,
                        ClientProvider: clientProvider,
                        Recorder:       mgr.GetEventRecorderFor("ocimanagedmachinepool-controller"),
                }).SetupWithManager(ctx, mgr, controller.Options{MaxConcurrentReconciles: ociMachinePoolConcurrency}); err != nil </span><span class="cov0" title="0">{
                        setupLog.Error(err, "unable to create controller", "controller", scope.OCIManagedMachinePoolKind)
                        os.Exit(1)
                }</span>

                <span class="cov0" title="0">if err = (&amp;expcontrollers.OCIVirtualMachinePoolReconciler{
                        Client:         mgr.GetClient(),
                        Scheme:         mgr.GetScheme(),
                        Region:         region,
                        ClientProvider: clientProvider,
                        Recorder:       mgr.GetEventRecorderFor("ocivirtualmachinepool-controller"),
                }).SetupWithManager(ctx, mgr, controller.Options{MaxConcurrentReconciles: ociClusterConcurrency}); err != nil </span><span class="cov0" title="0">{
                        setupLog.Error(err, "unable to create controller", "controller", scope.OCIVirtualMachinePoolKind)
                        os.Exit(1)
                }</span>

                <span class="cov0" title="0">if err = (&amp;expcontrollers.OCIMachinePoolMachineReconciler{
                        Client:         mgr.GetClient(),
                        Scheme:         mgr.GetScheme(),
                        Region:         region,
                        ClientProvider: clientProvider,
                        Recorder:       mgr.GetEventRecorderFor("ocimachinepoolmachine-controller"),
                }).SetupWithManager(ctx, mgr, controller.Options{MaxConcurrentReconciles: ociClusterConcurrency}); err != nil </span><span class="cov0" title="0">{
                        setupLog.Error(err, "unable to create controller", "controller", "OCIMachinePoolMachine")
                        os.Exit(1)
                }</span>
        }

        <span class="cov0" title="0">if err = (&amp;infrastructurev1beta2.OCICluster{}).SetupWebhookWithManager(mgr); err != nil </span><span class="cov0" title="0">{
                setupLog.Error(err, "unable to create webhook", "webhook", "OCICluster")
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">if err = (&amp;infrastructurev1beta2.OCIMachineTemplate{}).SetupWebhookWithManager(mgr); err != nil </span><span class="cov0" title="0">{
                setupLog.Error(err, "unable to create webhook", "webhook", "OCIMachineTemplate")
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">if err = (&amp;infrastructurev1beta2.OCIManagedCluster{}).SetupWebhookWithManager(mgr); err != nil </span><span class="cov0" title="0">{
                setupLog.Error(err, "unable to create webhook", "webhook", "OCIManagedCluster")
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">if err = (&amp;infrastructurev1beta2.OCIManagedControlPlane{}).SetupWebhookWithManager(mgr); err != nil </span><span class="cov0" title="0">{
                setupLog.Error(err, "unable to create webhook", "webhook", "OCIManagedControlPlane")
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">if err = (&amp;expV1Beta2.OCIManagedMachinePool{}).SetupWebhookWithManager(mgr); err != nil </span><span class="cov0" title="0">{
                setupLog.Error(err, "unable to create webhook", "webhook", "OCIManagedMachinePool")
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">if err = (&amp;expV1Beta2.OCIVirtualMachinePool{}).SetupWebhookWithManager(mgr); err != nil </span><span class="cov0" title="0">{
                setupLog.Error(err, "unable to create webhook", "webhook", "OCIVirtualMachinePool")
                os.Exit(1)
        }</span>
        //+kubebuilder:scaffold:builder

        <span class="cov0" title="0">if err := mgr.AddHealthzCheck("healthz", healthz.Ping); err != nil </span><span class="cov0" title="0">{
                setupLog.Error(err, "unable to set up health check")
                os.Exit(1)
        }</span>
        <span class="cov0" title="0">if err := mgr.AddReadyzCheck("readyz", healthz.Ping); err != nil </span><span class="cov0" title="0">{
                setupLog.Error(err, "unable to set up ready check")
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">setupLog.Info("starting manager")
        if err := mgr.Start(ctx); err != nil </span><span class="cov0" title="0">{
                setupLog.Error(err, "problem running manager")
                os.Exit(1)
        }</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
